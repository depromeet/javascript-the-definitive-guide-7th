# 10장 모듈

모듈은 단지 파일 하나에 불과하다. 스크립트 하나는 모듈 하나다.

모듈화는 프로그램 세부사항을 숨기고 전역 네임스페이스를 깔끔하게 유지하여 모듈이 다른 모듈의 변수, 함수 , 클래스를 수정하는 일을 막는 것이다.

```jsx
// 즉시 실행함수 형태

const BitSet = (function() {
  // 비공개 세부 사항
  function isValid(set, n) {...}
  function has(set, byte, bit) {...}
  const BITS= new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
  const MASKS = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]);

  // 모듈의 공개 API
  return class BitSet extends AbstractWritableSet {
    // 생략
  };
})
```

```jsx
// 클로저를 사용하는 모듈화

const modules = {};
function require(moduleName) {return modules[moduleName];}

modules["sets.js"] = (function () {
  const exports = {};

  exports.BitSet = class BitSet{...};

  return exports;
})

modules["stats.js"] = (function () {
  const exports = {};

  const sum = (x, y) => x+ y;
  const square = x => x * x;
  exports.mean = function(data) {...};
  exports.stddev = function(data) {...};

  return exports;
})
```

## 10.2 노드 모듈

노드에서 각 파일은 비공개 네임스페이스를 가진 독립적 모듈이다.

### 노드내보내기

```jsx
const mean = ...
const stddev = ...

module.exports = { mean, stddev }
```

```jsx
exports.mean = ...
exports.stddev = ...
```

### 노드 가져오기

```jsx
const fs = require("fs")

패키지 매니저로 설치한 모듈을 가져올때는 /를 쓰지않고 이름만 쓴다!

const stats = require("./stats.js")
모듈을 가져올 때는 일반적으로 상대경로로 가져온다.
```

## 10.3 ES6 모듈

일반적인 자바스크립트의 스크립트와 ES6 모듈의 중요한 차이가 있다.

일반적인 스크립트에서는 최상위에서 선언한 변수, 함수, 클래스는 모두 모든 스크립트가 공유하는 전역 컨텍스트에 들어간다. 반면, 모듈에서는 각 파일에 비공개 컨텍스트가 있으며 `import`와 `export`문을 사용할 수 있다.

그리고 자동으로 스트릭트 모드에 들어간다. 

스트릭트 모드에선 함수로 호출된 함수의 this는 undefined고, 웹 브라우저와 노드의 스크립트 에서는 this가 전역객체다.
