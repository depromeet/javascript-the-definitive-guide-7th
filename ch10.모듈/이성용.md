# 10장 모듈

모듈화 프로그래밍 의 목표는 큰 프로그램을 코드 모듈로 분리해서 모듈 개발자가 예측하지 못한 상황에서도 코드 전체가 정확히 실행되도록 하는 것이다. 실용적인 관점에서 모듈화(modularity)는 프로그램의 세부 사항을 캡슐화하고 전역 네임스페이스를 깔끔하게 유지해서 모듈이 다른 모듈의 변수, 함수, 클래스를 수정하는 사고를 막는 것을 말한다.

최근까지 자바스크립트는 모듈을 지원하지 않았고 큰 프로젝트 단위로 일하는 프로그래머는 클래스, 객체, 클로저에서 파생된 미약한 모듈성을 최대한 이용해야 했다. 클로저 기반 모듈성이 코드 번들링 도구의 지원에 힘입어 require() 함수라는 형태로 실용화됐으며, 노드에서 이 시스템을 도입했다. require()에 기반한 모듈은 노드 프로그래밍 환경에서 필수적인 부분으로 정착했지만 자바스크립트 언어에서 공식적으로 받아들이지는 않았다. ES6는 require() 대신 import와 export 키워드를 사용하는 모듈 시스템을 도입했다. import와 export 가 자바스크립트의 일부분이 된 지 몇 해가 지났지만 비교적 최근에서야 웹 브라우저와 노드에서 받아들여졌다. 실질적으로 자바스크립트 모듈성은 아직 코드 번들링 도구에 의존하고 있다.

## 클래스, 객체, 클로저를 사용하는 DIY 모듈

클래스와 객체를 통한 모듈화는 널리 쓰이고 유용하기도 하지만 그다지 발전되지는 않았다. 무엇보다도 모듈 내부의 세부 사항을 숨길 방법이 없다.

함수에서 선언한 로컬 변수와 중첩 된 함수는 그 안에서만 사 용할 수 있는 비공개 값이다. 즉, 즉시 호출하는 함수 표현식을 사용해 세부 사항과 유틸리티 함수를 내부에 숨기고 모듈의 공개 API만 반환해서 일종의 모듈성을 얻을 수 있다.

```jsx
const BitSet = (function() { // BitSet을 반환합니다.
    // 비공개 세부 사항
    function isValid(set, n) { ... }
    function has(set, byte, bit) { ... }
    const BITS = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
    const MASKS = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]);

    // 모듈의 공개 API는 여기서 정의하고 반환하는 BitSet 클래스뿐입니다.
		// 위에서 정의한 비공개 함수와 상수는 BitSet 클래스만 사용할 수 있고
		// 클래스 사용자에게는 보이지 않습니다.
    return class BitSet extends AbstractWritableSet {
        // ... implementation omitted ...
    };
}());
```

이렇게 모듈성을 확보하는 것은 모듈에 아이템 이 하나 이상 있을 때 더 흥미롭다.

```jsx
// 다음과 같이 통계 모듈을 정의합니다.
const stats = (function() {
    // 모듈에서만 사용하는 비공개 유틸리티 함수
    const sum = (x, y) => x + y;
    const square = x => x * x;

    // 내보낼 공개 함수
    function mean(data) {
        return data.reduce(sum)/data.length;
    }

    // 내보낼 공개 함수
    function stddev(data) {
        let m = mean(data);
        return Math.sqrt(
            data.map(x => x - m).map(square).reduce(sum)/(data.length-1)
        );
    }

    // 공개 함수를 객체 프로퍼티로 내보냅니다.
    return { mean, stddev };
}());

// 모듈은 다음과 같이 사용합니다.
stats.mean([1, 3, 5, 7, 9])   // => 5
stats.stddev([1, 3, 5, 7, 9]) // => Math.sqrt(10)
```

### 클로저를 사용하는 자동 모듈화

```jsx
const modules = {};
function require(moduleName) { return modules[moduleName]; }

modules ["sets.js"] = (function() {
	const exports = {};
	...
	return exports;
}());

modules ["stats.js"] = (function() {
	const exports = {};
	...
	return exports;
}());

// 필요한 모듈 또는 그 콘텐츠 참조를 가져옵니다.
const stats = require("stats.js");
const BitSet = require("sets.js").BitSet;

// 모듈을 사용하는 코드를 작성합니다.
let s = new BitSet(100);
s.insert(10);
s.insert(20);
s.insert(30);
let average = stats.mean([...s]); // 평균은 20입니다.
```

이 코드는 웹팩이나 파셀 같은 웹브라우저용 코드 번들링 도구가 하는 일을 간단히 요약한 것이며 노드 프로그램에서 사용하는 require() 함수도 이와 비슷하게 동작한다.

## require()를 사용하는 노드 모듈

노드 프로그래밍 에서는 일반적으로 프로그램을 여러 개의 파일로 나눈다. 이 파 일은 빠른 파일 시스템에 존재한다고 가정하므로, 비교적 느린 네트워크 연결을 통해 자바스크립트 파일을 불러오는 웹 브라우저와 달리 노드 프로그램을 파일 하나로 모을 필요가 없다.

노드에서 각 파일은 비공개 네임스페이스를 가진 독립적 모듈이다. 파일에서 정의한 상수, 변수, 함수, 클래스는 모두 파일에서 내보내지 않는 한 비공개이다. 모듈에서 명시적으로 내보내야만 다른 모듈에서 그 값을 가져올 수 있다.
노드 모듈은 require() 함수를 통해 다른 모듈을 가져오고, Exports 객체의 프로 퍼티를 수정하거나 module.exports 객체 자체를 바꾸는 방법으로 공개 API를 내보낸다.

### 노드 내보내기

```jsx
exports.mean = data => data.reduce(sum)/data.length;
exports.stddev = function(d) {
	let m = exports.mean(d);
	return Math.sqrt(d.map(x => x - m).map(square).reduce(sum)/(d.length-1));
};

module.exports = class BitSet extends AbstractWritableSet {
	// 클래스 바디
};

// 공개와 비공개 함수를 모두 정의합니다.
const sum = (x, y) => x + y;
const square = x => x * x;
const mean = data => data.reduce(sum)/data.length;
const stddev = d => {
	let m = mean(d);
	return Math.sqrt(d.map(x => x - m).map(square).reduce(sum)/(d.length-1));
};

// 공개할 것만 내보냅니다.
module.exports = { mean, stddev };
```

### 노드 가져오기

```jsx
// 노드에 내장된 모듈입니다.
const fs = require("fs"); // 내장된 파일 시스템 모듈
const http = require("http"); // 내장된 HTTP 모듈
// 익스프레스는 따로 설치한 서드 파티 모듈입니다.
const express = require("express");

const stats = require("./stats.js");
const BitSet = require("./utils/bitset.js");

// 함수를 포함해 stats 객체 전체를 가져옵니다. 
const stats = require("./stats.js");
// 필요 없는 함수도 포함됐지만 이들은 모두 "stats" 네임스페이스로 정리되어 있습니다. 
let average = stats.mean(data);
// 분해 할당을 통해 원하는 함수만 로컬 네임스페이스에 가져올 수도 있습니다.
const { stddev } = require("./stats.js");
// 간결해졌지만 stddev() 함수의 네임스페이스가 사라졌습니다.
let sd = stddev(data);
```

### 웹의 노드 스타일 모듈

Exports 객체와 require() 함수는 노드 모듈에서 사용한다. 웹팩 같은 번들링 도구로 코드를 처리한다면 웹 브라우저에서도 이런 스타일의 모듈을 사용할 수 있다. 최근까지도 널리 사용된 방법이므로 웹팩으로 처리한 코드를 자주 볼 수 있다.