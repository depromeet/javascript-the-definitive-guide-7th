# 15장 웹 브라우저의 자바스크립트

이 장에서 웹 API를 모두 설명하는 것은 불가능하지만, 가장 중요한 API는 모두 소개하고 즉시 사용할 수 있도록 자세히 설명한다.

## 웹 프로그래밍 기본

### HTML <script> 태그 속의 자바스크립트

```tsx
<!DOCTYPE html>
<!-- This is an HTML5 file -->
<html>
  <!-- The root element -->
  <head>
    <!-- Title, scripts & styles can go here -->
    <title>Digital Clock</title>
    <style>
                               /* A CSS stylesheet for the clock */
      #clock {                        /* Styles apply to element with id="clock" */
        font: bold 24px sans-serif;   /* Use a big bold font */
        background: #ddf;             /* on a light bluish-gray background. */
        padding: 15px;                /* Surround it with some space */
        border: solid black 2px;      /* and a solid black border */
        border-radius: 10px;          /* with rounded corners. */
      }
    </style>
  </head>
  <body>
    <!-- The body holds the content of the document. -->
    <h1>Digital Clock</h1>
    <!-- Display a title. -->
    <span id="clock"></span>
    <!-- We will insert the time into this element. -->
    <script>
      // Define a function to display the current time
      function displayTime() {
        let clock = document.querySelector('#clock'); // Get element with id="clock"
        let now = new Date(); // Get current time
        clock.textContent = now.toLocaleTimeString(); // Display time in the clock
      }
      displayTime(); // Display the time right away
      setInterval(displayTime, 1000); // And then update it every second.
    </script>
  </body>
</html>
```

js 파일에 저장했다면 다음과 같이 <script> 태그에서 파일을 참조할 수 있다.

`<script src="scripts/digital_clock.js"></script>`

방대한 자바스크립트 코드를 HTML 파일에서 제거해 단순화합니다. 즉, ‘내용’과 ‘동작’을 분리한다.

여러 개의 웹 페이지에서 같은 자바스크립트 코드를 공유할 때 src 속성을 쓰면 코드 하나만 관리해도 된다.

자바스크립트 코드를 여러 페이지에서 공유한다면 한 번만 내려받으면 된다. 첫 번째 페이지에서 코드를 내려받으면 다른 페이지는 브라우저 캐시에서 가져 올 수 있다.

src 속성은 임의의 URL을 값으로 받으므로 한 서버에 있는 자바스크립트 프로 그램이나 웹 페이지가 다른 웹 서버에 있는 코드를 가져올 수 있다. 인터넷 광고는 대부분 이를 바탕으로 만들어진다.

**모듈**

자바스크립트 프로그램을 모듈로 작성했다면 (그리고 코드 번들링 도구를 써서 모듈을 하나의 자바스크립트 파일로 조합하지 않았다면) 반드시 최상위 모듈을 <script type="module”> 태그로 불러와야 한다.

**스크립트 타입 지정**

웹 초기에는 언젠가 브라우저에서 자바스크립트가 아닌 다른 언어가 쓰일 것을 염두에 두고 <script> 태그에 language="javascript", type="application/java script" 같은 속성을 추가했다. 하지만 이는 완전히 불필요하다. 자바스 크립트는 웹의 기본 언어이자 유일한 언어이다. language 속성은 폐기됐으며 <script> 태그에 type 속성을 사용하는 경우는 단 두 가지뿐이다.

- 스크립트가 모듈일 때
- 웹 페이지에 데이터를 가져오지만 표시하지는 않을 때(15.3.4절 참고)

**스크립트 실행 시점: async와 defer**

<script> 태그에 defer, async 속성을 써서 스크립트 실행 방식을 바꿀 수 있다.

defer, async 속성은 모두 연결된 스크립트에 HTML을 만드는 document.write()가 없으므로 브라우저가 스크립트를 다 내려받을 때까지 기다리지 않고 문서 분석과 렌더링을 계속해도 된다.

defer 속성은 문서를 완전히 내려받고 분석해서 조작 할 준비가 끝날 때까지 스크립트 실행을 지연(defer)하라는 의미입니다.

async 속성은 브라우저가 스크립드를 가능한 빨리 실행하되 스크립트를 내려받는 동안 문 서 분석을 계속해도 된다는 뜻입니다.

<script> 태그에 두 속성이 모두 존재한다면 async 속성이 우선순위를 갖습니다.

지연된 스크립트는 문서 출처 순서대로 실행된다. 비동기 스크립트는 불러오는 즉시 실행되므로 문서 출처대로 실행되지 않을 수도 있다.

type="module" 속성이 있는 스크립트는 기본적으로 defer 속성이 있는 것처럼 문서 로딩이 끝난 후 실행된다. async 속성을 쓰면 문서 로딩이 끝날 때까지 대기하지 않고 가져온 모듈 전부를 불러오는 즉시 실행을 시작한다.

async, defer 속성을 쓰지 않고 스크립트를 HTML 파일의 마지막에 불러오기만 해도 같은 효과를 볼 수 있다. 이렇게 하면 브라우저가 문서 로드와 분석을 이미 끝낸 상태이므로 스크립트에서 문서 콘텐츠를 조작해도 안전하다.

**필요에 따른 스크립트 로드**

문서를 처음 불러올 때는 필요가 없지만 사용자가 버튼을 클릭하거나 메뉴를 여는 등 어떤 행동을 했을 때만 필요한 자바스크립트 코드도 있다.

모듈을 사용해 코드를 개발했다면 import()를 써서 필요한 모듈만 불러 올 수 있다.
모듈을 사용하지 않는다면 스크립트를 불러올 때 문서에 <script> 태그를 추가 해서 자바스크립트 파일을 불러올 수 있다.

```tsx
// 지정된 URL에서 비동기적으로 스크립트를 불러와서 실행합니다.
// 스크립트를 불러오면 해석되는 프라미스를 반환합니다
function importScript(url) {
  return new Promise((resolve, reject) => {
    let s = document.createElement('script'); // <script> 요소 생성
    s.onload = () => {
      resolve();
    }; // 프라미스 해석
    s.onerror = (e) => {
      reject(e);
    }; // 실패 시 거부
    s.src = url; // 스크립트 URL 설정
    document.head.append(s); // 문서에 <script> 추刀F
  });
}
```

### 문서 객체 모델

Document 객체는 브라우저 창이나 탭에 표시되는 HTML 문서를 나타내는 객체이며 클라이언트 사이드 자바스크립트 프로그래밍에서 가장 중요한 객체 중 하나다.

DOM API는 HTML 문서의 트리 구조를 반영한다. 문서에 존재하는 HTML 태그마다 그에 대응하는 자바스크립트 Element 객체가 있고, 문서에 존재하는 텍스트마다 그에 대응하는 Text 객체가 있다. Element, Text, Document 클래스는 모두 Node 클래스의 서브클래스이며 Node 객체는 트리 구조로 되어 있어, 자바스크립트에서 DOM API를 사용해 검색하고 이동할 수 있다.

노드의 바로 위에 있는 노드는 그 노드의 부모 (parent)

한 노드의 바로 아래 있는 노드는 자식(children)

같은 레벨에 있는 노드이고, 서로 부모도 같다면 그들은 형제 (sibling)

어떤 노드의 아래에 있는 노드는 몇 단계에 걸쳐 있든 그 노드의 자손(descendant)

부모, 조부모 등 어떤 노드의 위에 있는 노드는 몇 단계 에 걸쳐 있든 그 노드의 조상(an- cestor)이다.

DOM API에는 새로운 Element, Text 노드를 생성하고 이들을 다른 Element 객체의 자식으로 문서에 삽입하는 메서드가 있다. 문서 안에서 요소를 이동하거나 완전히 제거하는 메서드도 있다.

각 HTML 태그 타입에 대응하는 자바스크립트 클래스가 있고 문서에 존재하는 각 태그는 클래스의 인스턴스로 표현된다.

### 웹 브라우저의 전역 객체

브라우저 창이나 탭마다 이에 대응하는 전역 객체가 하나씩 있다. 워커 스레드를 제외한 모든 자바스크립트 코드는 전역 객체를 공유한다. 문서에 스크립트나 모듈이 얼마나 많든 관계없습니다. 스크립트에서 전역 객체에 프로퍼티를 정의하면 그 프로퍼티는 다른 스크립트 전체에서 볼 수 있다.

자바스크립트의 표준 라이브러리는 전역 객체에 정의된다.

웹 브라우저에서 전역 객체는 두 가지 임무를 수행한다. 전역 객체는 내장 타입과 함수를 정의하기도 하지만 현재 웹 브라우저 창을 나타내기도 하며 그 창의 브라우징 히스토리를 나타내는 history, 창의 너비를 픽셀로 나타내는 inner Width 같은 프로퍼티를 정의하기도 한다. 이 전역 객체에는 window 프로퍼티가 있으며 그 값은 전역 객체 자체이다. 따라서 클라이언트 사이드 코드에서 window를 입력해 전역 객체를 참조할 수 있다. 전역 객체와 관련된 기능을 사용할 때는 앞에 window.를 붙이는 편이 좋다. 예를 들어 innerWidth보다는 window, inner Width가 더 명확하다.

### 네임스페이스를 공유하는 스크립트

모듈의 최상위 레벨, 즉 다른 함수나 클래스 정의 바깥에서 정의한 상수, 변수, 함 수, 클래스는 명시적으로 내보내지 않는 한 그 모듈에서만 사용하는 비공개 변수이다.

모듈이 아닌 스크립트에서는 완전히 다르다. 스크립트의 최상위 코가 상수, 변수, 함수, 클래스를 정의하면 그 선언은 같은 문서에서 실행된 모든 스 크립트에서 볼 수 있다. 어떤 스크립트에서 함수 f()를 정의하고 다른 스크립트에서 클래스 e를 정의한다면 세 번째 스크립트에서는 그들을 가져오지 않고도 함수를 호출하고 클래스의 인스턴스를 만들 수 니다. 따라서 모듈을 사용하지 않는다면 문서에 존재하는 독립적인 스크립트들이 네임스페이스를 공유하며 거대한 스크립트의 일부인 것처럼 행동한다. 작은 프로그램에서는 편리할 수도 있지만 큰 프로그램에서는 겹치는 이름을 피하는 일도 고역이 될 수 있으벼 서드 파티 라이브러리를 사용한다면 이 문제가 더 커질 수 있다.

반면 ES6의 const, let, class는 최상위 레벨에서 사용하더라도 전역 객체가 아니라 공유된 네임스페이스 안에 생성된다. 스크립트에서 클래스 e를 정의하면 다른 스크립트에서는 new window.C()가 아니라 new C()로 그 클래스의 인스턴스를 만든다.

### 자바스크립트 프로그램 실행

웹 페이지에 <iframe> 요소로 임베드된 프레임이 있다면, 그 임베드된 문서의 자바스크립트 코드는 임베드한 문서와는 다른 전역 객체와 Document 객체를 가지므로 별도의 자바스크립트 프로그램이라고 볼 수 있다. 하지만 앞서 말했듯 자바스크립트 프로그램의 경계를 정하는 공식 정의는 없다. 포함하는 문서와 포함된 문서를 같은 서버에서 불러왔다면 각 문서의 코드가 상호작용할 수 있으며 이들을 프로그램 하나를 이루는 각 부분으로 생각할 수도 있다.

자바스크립트 프로그램은 두 단계(phase)로 실행된다고 생각해도 무방하다.

첫 번째 단계에서는 문서 콘텐츠를 불러오고 <script> 요소의 코드를 실행한다. 스크립트는 일반적으로 문서 순서대로 실행되지만 async, defer 속성에 의해 순서가 바뀔 수 있다. 스크립트에 포함된 자바스크립트 코드는 위쪽에서 아래쪽으로 실행되지만, 자바스크립트의 조건문, 루프, 기타 제어문에 의해 순서가 바뀔 수 있다. 일부 스크립트는 첫 번째 단계에서는 거의 아무 일도 하지 않고 두 번째 단계에 사용할 함수와 클래스를 정의하기만 한다. 어떤 스크립트는 첫 번째 단계 에서만 동작하고 두 번째 단계에서는 아무것도 하지 않는다. 문서의 마지막에 있는 스크립트가 <hl>, <h2> 태그를 모두 찾아서 차례를 만들어 문서 처음에 삽입한다고 하자. 이 작업은 첫 번째 단계에서 완전히 끝날 수 있다.

문서 로딩이 끝나고 스크립트를 전부 실행하면 자바스크립트는 두 번째 단계에 들어간다. 이 단계는 비동기적이며 이벤트 주도적이다. 스크립트가 두 번째 단계에서 동작하려면 반드시 첫 번째 단계에서 하나 이상의  벤트 핸들러나 다른 콜백 함수를 등록해야 한다. 이벤트 주도적인 두 번째 단계에서 웹 브라우저는 비동기적으로 일어나는 이벤트에 응답해 이벤트 핸들러나 기타 콜백을 호출한다. 이벤트 핸들러는 대부분 마우스 클릭이나 키 입력 등 사용자의 입력에 응답하지만 네트워크 활동, 문서나 자원 로딩, 경과한 시간, 자바스크립트 코드의 에러 등으로도 호출될 수 있다.

두 번째 단계에서 처음 일어나는 이벤트 중에는 DOMContentLoaded와 load 이벤트가 있다. DOMContentLoaded 이벤트는 HTML 문서의 로딩과 분석이 완전히 끝났을 때 일어난다. load 이벤트는 이미지 같은 문서의 외부 자원을 완전히 불러 왔을 때 일어난다. 자바스크립트 프로그램에서 이들 이벤트를 시작 신호로 사용 할 때가 많다. 스크립트에서 함수를 정의하고 load 이벤트가 발생했을 때 실행 되도록 이벤트 핸들러 함수로 등록하기만 하는 것입니다. 그리고 load 이벤트 핸 러에서 문서를 조작하고 기타 프로그램에서 의도한 작업을 수행한다. load 같은 이벤트 핸들러 에서 다른 이벤트 핸들러를 등록하는 경우도 많다.

자바스크립트 프로그램의 첫 번째 단계는 비교적 짧으며, 1초 안에 이루어지는 것이 이상적이다. 문서 로딩이 끝나면, 문서가 웹 브라우저에 표시되는 동안 이벤트 주도적인 두 번째 단계가 계속 이어진다.

**클라이언트 사이드 자바스크립트 스레드 모델**

자바스크립트는 싱글 스레드 언어이며, 싱글 스레드 실행 모델은 두 이벤트 핸들러 가 절대 동시에 실행되지 않으므로 프로그래밍이 훨씬 단순하다. 콘텐츠를 수정 할 때 다른 스레드가 같은 콘텐츠를 동시에 수정하게 될 일도 없고, 락(lock), 교착 상태(deadlock), 경합 조건(race condition)을 걱정할 필요도 없다.

싱글 스레드는 웹 브라우저가 스크립트와 이벤트 핸들러를 실행하는 동안 사용자 입력에 반응하지 않는다는 의미이다. 따라서 자바스크립트 프로그래머는 스크립트와 이벤트 핸들러가 너무 오래 실행되게 만들어서는 안 된다. 스크립트에서 과도한 계산을 수행하면 문서 로딩이 지연되고 사용자는 스크립트 실행이 완료 될 때까지 문서 콘텐츠를 볼 수 없다. 이벤트 핸들러에서 과도한 계산을 수행 하면 브라우저의 응답이 멈추고 사용자는 브라우저가 다운됐다고 생각할 수도 있다.

웹 플랫폼은 ‘웹 워커’를 통해 동시성을 구현한다. 웹 워커는 사용자 인터페이스를 멈추지 않으면서 실행되는 백그라운드 스레드이다. 웹 워커 스레드에서 실행되는 코드는 문서 콘텐츠에 접근할 수 없고, 메인 스레드나 다른 워커와는 상태를 공유하지 않으면서 오로지 비동기 메시지 이벤트를 통해서만 통신한다. 메인 스레드는 이런 동시성을 인지하지 못하므로 웹 워커는 자바스크립트 프로그램의 싱글 스레드 실행 모델을 망치지 않는다.

**클라이언트 사이드 자바스크립트 타임라인**

1. 웹 브라우저가 Document 객체를 생성하고 웹 페이지 분석을 시작한다. HTML 요소와 텍스트 콘텐츠를 분석할 때마다 Element 객체와 Text 노드를 문서 에 추가한다. 이 단계에서 document.readyState 프로퍼티의 값은 loading이다.
2. HTML 파서가 async, defer, type="module" 속성이 없는 <script> 태그를 만 면 스크립트 태그를 문서에 추가하고 스크립트를 실행한다. 스크립트는 동기적으로 실행되고 HTML 파서는 스크립트를 내려받아 실행하는 동안 일시 중지한다. 이런 스크립트는 document.write()를 사용해 입력 스트림에 텍스트를 삽입할 수 있으며 그 텍스트는 파서가 재개될 때 문서의 일부분이 된다. 이런 스크립트는 나중에 사용할 이벤트 핸들러를 등록하기만 하는 경우가 대부분이지만, 이 시점에는 자신이 존재하는 것처럼 문서 트리를 이동하고 조작 할 수 있다. 즉, async나 defer 속성이 없는 비모듈 스크립트는 자기 자신의 <script> 태그와 그 앞에 있는 문서 콘텐츠를 볼 수 있다.
3. 파서가 async 속성이 있는 <script> 요소를 만나면 스크립트 텍스트를 내려 받기 시작하며, 스크립트가 모듈이라면 가져오는 모듈 역시 재귀적으로 내려 받아 문서 분석을 계속한다. 스크립트는 내려받은 후 가능한 한 빨리 실행 되지만 파서는 내려받기가 끝나기를 기다리지 않는다. 비동기 스크립트는 document.write() 메서드를 사용해서는 안 된다. 비동기 스크립트는 자신의 <script> 태그와 그 앞에 있는 문서 콘텐츠를 볼 수 있고, 나머지 문서 콘텐츠 예는 접근할 수도 있고 접근하지 못할 수도 있다.
4. 문서 분석이 완전히 끝나면 document.readyState 프로퍼티가 interactive로 바뀐다.
5. defer 속성이 있는 스크립트, async 속성이 없는 모듈 스크립트는 문서 순서대로 실행된다. 비동기 스크립트도 이때 실행될 수 있다. 지연된 스크립트는 문서 전체에 접근할 수 있으며, document.write() 메서드를 사용해서는 안 된다.
6. 브라우저가 Document 객체에서 DOMContentLoaded 이벤트를 일으킵니다. 이 이벤트는 스크립트 단계를 두 번째 단계로 전환합니다. 이 시점에서 아직 실행 되지 않은 async 스크립트가 있을 수 있다.
7. 이 시점에서 문서 분석은 완전히 끝났지만 브라우저는 여전히 이미지 같은 콘텐츠를 기다리고 있을 수 있다. 콘텐츠 로딩이 끝나고 async 스크립트 로딩과 실행도 끝나면 document. readyState 프로퍼티는 complete로 바뀌고 웹 브라우저는 Window 객체에서 load 이벤트를 일으킨다.
8. 이제부터 사용자의 입력 이벤트, 네트워크 이벤트, 타이머 종료 등에 의해 이 벤트 핸들러가 비동기적으로 호출된다.

### 프로그램 입출력

다른 프로그램과 마찬가지로 클라이언트 사이드 자바스크립트 프로그램도 입력 데이터를 처리해 출력 데이터를 만든다.

- 자바스크립트 코드에서 DOM APK15.3절）를 통해 접근할 수 있는 문서 콘텐츠 자체
- 이벤트 형태인 사용자 입력. HTML <button> 요소를 마우스로 클릭하거나 터치 스크린을 탭하는 것, HTML <textarea> 요소에 텍스트 입력 등이 이에 해당한다.
- 문서 URL은 클라이언트 사이드 자바스크립트에서 document.URL로 접근할 수 있다. 이 문자열을 URL() 생성자에 전달하면 URL의 경로, 검색 , 프래그먼트 등에 쉽게 접근할 수 있습니다.
- HTTP ‘쿠키’ 요청 헤더 콘텐츠는 document.cookie로 사용할 수 있습니다. 쿠키는 보통 서버 사이드에서 사용자 세션을 관리할 때 사용하지만 클라이언트 사이드에서도 필요하다면 쿠키를 읽고 쓸 수 있다.
- 전역 navigator 프로퍼티를 통해 웹 브라우저, 운영 체제와 그 기능에 접근할 수 있습니다. 예를 들어 navigator.userAgent는 웹 브라우저를 식별하는 문자열이고 navigator.language는 사용자가 선호하는 언어이며 navigator.hardwareConcurrency는 웹 브라우저가 사용할 수 있는 논리적 CPU의 개수입니다. 마찬가지로 전역 screen 프로퍼티의 screen.width, screen.height 프로퍼티를 통해 사 자의 디스플레이 크기에 접근할 수 있다. 어떤 면에서는 웹 브라우저의 navigator, screen 객체를 노드 프로그램의 환경 변수라고 생각해도 된다.

클라이언트 사이드 자바스크립트는 DOM API 또는 리액트, 앵귤러 같은 프레임워크를 통해 HTML 문서를 조작한다. 클라이언트 사이드 코드는 console.log()나 관련 메서드를 통해 출력할 수도 있다. 하지만 콘솔을 통한 출력은 웹 개발자 콘솔에만 보이므로 디버깅에는 적합하지만 사용자에게 전달하기에는 적합 하지 않다.

### 프로그램 에러

자바스크립트 프로그램이 실행되는 동안 예외가 일어나고 그 예외를 처리할 catch 문이 없다면 개발자 콘솔에 에러 메시지가 표시되지만 등록된 이벤트 핸들러는 계속 실행되며 이벤트에 반응한다.

잡히지 않은 예외가 일어났을 때 최후의 수단으로 호출될 에러 핸들러가 필요하다면, Window 객체의 onerror 프로퍼티에 에러 핸들러 함수를 정의한다. 잡히지 않은 예외가 콜 스택을 따라 전달되고 개발자 콘솔에 에러 메시지가 표시된다.

프라미스가 거부되고 이를 처리할 .catch() 함수가 없다면 처리하지 않은 예외가 있는 것과 비슷하다. 프로그램에 예상치 못한 에러나 논리 에러가 있는 것이다. window.onunhandledrejection 함수를 정의하거나 window.addEventListener()를 써서 unhandledrejection 이벤트 핸들러를 등록해 이를 감지할 수 있다.

onerror와 onunhandledrejection 핸들러를 정의할 일은 많지 않지만 fetch() 함수 등을 사용해 사용자의 브라우저에서 일어난 예상하지 못한 에러를 서버에 보고 하는 메커 니즘을 준비할 때 꽤 유용하게 쓸 수 있다.

### 웹 보안 모델

웹 페이지에서 방문자 개인의 장치에 임의의 자바스크립트 코드를 실행할 수 있다는 것은 분명 보안에 영향을 준다. 브라우저 제조사들은 아래 두 가지 상반되는 목표 간의 균형을 맞추기 위해 노력해 왔다.

- 유용한 웹 애플리케이션을 사용할 수 있는 강력한 클라이언트 사이드 API를 정의하는 것
- 악의적인 코드에서 데이터를 읽기나 수정하지 못하게 하고, 개인 정보에 접근하지 못하게 방지하는 것

**자바스크립트에서 할 수 없는 일**

악의적인 코드에 대한 웹 브라우저의 첫 번째 방어선은 특정 기능을 지원하지 않는 것이다.

클라이언트 사이드 자바스크립트는 클라이언트 컴퓨터의 디렉터리를 읽을 수 없고 파일을 수정하거나 삭제할 수 없다. 따라서 자바스크립트 프로그램은 데이터를 삭제하거나 바이러스를 옮길 수 없다.

마찬가지로 클라이언트 사이드 자바스크립트에는 범용 네트워크 기능도 없다. 클라이언트 사이드 자바스크립트 프로그램은 HTTP 요청(15.11.1 절)을 보낼 수 있고, 특별한 서버와 통신하도록 소켓 비슷한 API를 정의한 웹소켓(15.11.3절)이라 는 표준도 있다. 하지만 어느 API도 방대한 네트워크에 제한 없이 접근하도록 허용하지는 않는다. 클라이언트 사이드 자바스크립트로 범용 인터넷 클라이언트와 서버를 만들 수는 없다.

**동일 출처 정책**

동일 출처 정책(same-origin policy)은 자바스크립트 코드에서 접근할 수 있는 웹 콘텐츠를 제어하는 보안 제한이다. 동일 출처 정책은 일반적으로 <iframe> 요소 를 통해 웹 페이지를 불러올 때 작용한다. 한 프레임에 있는 자바스크립트 코드와 다른 프레임의 콘텐츠 사이의 상호작용을 지배한다. 구체적으로 말해 스크립트는 자신을 포함한 문서와 같은 서버에서 가져온 창과 문서의 프로퍼티만 읽을 수 있다.

문서 출처는 그 문서를 불러온 URL의 프로토콜, 호스트, 포트로 정의됩니다.

다른 웹 서버에서 가져왔다면 출처가 다른 문서로 간주합니다.

호스트가 같더라도 다른 포트에서 가져온 문서는 출처가 다른 것으로 간주한다.

또한 서버가 같더라 도 http: 프로토콜로 가져온 문서는 https: 프로토콜로 가져온 문서와 출처가 다르 다고 간주한다.

브라우저는 일반적으로 file: URL을 별도의 출처로 취급하므로, 같은 서버 에서 하나 이상의 문서를 가져와 표시하는 프로그램을 만들고 있다면 로컬에서 file: URL로는 테스트할 수 없고 개발 과정에 정적 웹 서버를 사용해야 한다.

스크립트 자체의 출처는 동일 출처 정책과 관련이 없다. 문제가 되는 것은 스크립트를 포함한 문서의 출처이다.

동일 출처 정책은 스크립트를 사용한 HTTP 요청에도 적용된다. 자바스크립트 코드는 자신을 포함하는 문서를 가져온 웹 서버에 HTTP 요청을 제한 없이 보낼 수 있지만 다른 웹 서버와 통신할 수는 없다. (CORS로 허용된 웹 서버는 허용된다)

스크립트는 document.domain 을 도메인 접미사로 설정해, 이렇게 여러 개의 도메인을 사용하는 웹사이트를 지원할 수 있다. 즉 [https://orders.example.com에서](https://orders.example.xn--com-k94n91q/) 가져온 스크립트는 document.domain을 example.com으로 설정해 자신의 출처를 [https://example.com으로](https://example.xn--com-ky7m580d/) 바꿀 수 있다. 하지만 document.domain을 orders.example, [ample.com](http://ample.com/), com 등으로 바꿀 수는 없다.

동일 줄처 정책을 완화하는 두 번째 방법은 CORS(Cross-Origin Resource Sharing) (교차 출처 간 자원 공유)이다. CORS는 HTTP를 Origin: 요청 헤더와 Access-Control-Allow-Origin 응답 헤더로 확장한다. CORS를 써서 헤더에 파일을 요청할 수 있는 출처를 명시적으로 나열하거나 와일드카드를 써서 어떤 사이트에든 제한 없이 파일을 요청하게 할 수 있다. 브라우저는 CORS 헤더를 지원하며 이 헤더가 존재하지 않으면 동일 출처 제한을 완화하지 않는다.

**교차 사이트 스크립트**

교차 사이트 스크립트(Cross-site scripting)(XSS)는 공격자가 대상 웹사이트에 HTML 태그나 스크립트를 주입하는 보안 문제를 통틀어 가리키는 용어다. 클 라이언트 사이드 자바스크립트 프로그래머는 반드시 교차 사이트 스크립트를 염두에 두고 방어해야 한다.

```tsx
<script>
let name = new URL(document.URL).searchParams.get("name11);
document.queryselector('hl').innerHTML = "Hello " + name;
</script>

http://www.example.com/greet.html?name=%3Cimg%20src=%22x.png%22잉200nload=%22alert(%27hacked%27)%22/잉3E
```

교차 사이트 스크립트 공격이라는 이름은 하나 이상의 사이트가 연관됨을 의미한다. 사이트 B에 위 예제와 같이 조작된, 사이트 A를 가리키는 링크가 있다고 하자. 사이트 B에서 사용자가 그 링크를 클릭하도록 유도하면 사용자는 사이트 A로 이동하지만, 사이트 A는 이제 사이트 B의 코드를 실행한다. 그 코드가 사이트 A의 페이지를 훼손하거나 제대로 동작하지 않게 만들 수도 있다. 더 위험한 것은, 악의적인 코드가 사이트 A에 저장된 계좌 번호나 개인 식별 정보 같은 쿠키를 읽고 이를 사이트 B에 전송할 수 있다는 것이다. 주입된 코드로 사용자의 키 입력을 추적해 사이트 B에 전송할 수도 있다.

일반적으로 XSS 공격을 방지하는 방법은 신뢰할 수 없는 데이터로 문서 콘텐츠 를 동적으로 생성하기 전에 HTML 태그를 모두 제거하는 것이다. 예를 들어 다음과 같이 greet.html을 수정해 신뢰할 수 없는 입력 문자열의 HTML 특수 문자를 이와 동등한 HTML 엔티티로 교체하는 방법이다.

XSS 문제를 방지하는 또 다른 방법은 신뢰할 수 없는 콘텐츠는 항상 sandbox 속성 이 있는 <iframe>에 표시해서 스크립트나 기타 기능을 비활성화하는 것이다.

교차 사이트 스크립트는 웹의 구조에 깊이 뿌리박힌 유해한 취약점이다. 이 취약점을 자세히 이해하는 일은 그만한 가치가 있지만 더 깊이 설명하는 것은 이 책의 범위를 벗어난다. 교차 사이트 스크립트를 방어하는 방법을 다룬 온라인 자료는 많다.

## 이벤트

클라이언트 사이드 자바스크립트 프로그램은 비동기적인 이벤트 주도 프로그래밍 모델을 사용한다. 웹 브라우저는 문서, 브라우저, 요소, 객체에 뭔가 흥미로운 일 이 일어날 때마다 이벤트를 일으킨다.

자바스크립트 애플리케이션이 어떤 이벤트 타입에 관심이 있다면 그 타입의 이벤트가 일어날 때 호출되도록 하나 이상의 함수를 등록할 수 있다.

**이벤트 타입**

이벤트 종류를 지정하는 문자열 (mousemove, keydown, load)

이벤트 타입은 단순한 문자열이므로 이벤트 이름이라 부를 때도 있다.

**이벤트 대상**

이벤트가 일어난, 또는 이벤트와 연관된 객체이다. (Window, Document, Element)

**이벤트 핸들러 또는 이벤트 리스너**

이 함수는 이벤트를 처리하거나 이벤트에 반응한다. 애플리케이션은 이벤트 타입과 이벤트 대상을 지정해 웹 브라우저에 이벤트 핸들러 함수를 등록한다. 지정된 대상에서 지정된 타입의 이벤트가 일어나면 브라우저가 핸들러 함수를 호출한다. 객체에서 이벤트 핸들러가 호출되면 브라우저가 이벤트를 ‘일으켰 다’, ‘전달했다’라고 한다.

**이벤트 객체**

이벤트 객체는 특정 이벤트와 연관되어 있으며 해당 이벤트에 관한 세부 정보를 포함한다. 이벤트 객체는 이벤트 핸들러 함수에 인자로 전달된다.

**이벤트 전달**

브라우저는 이 프로세스를 통해 어떤 객체 에서 이벤트 핸들러를 호출할지 결정한다. Window 객체의 load 이벤트나 Worker 객체의 message 이벤트처럼 특 정 객체에 국한되는 이벤트는 전달(propagation)이 필요 없다. 반면 HTML 문서의 요소에서 일어나는 일부 이벤트는 문서 트리를 따라 전달된다.

일부 이벤트에는 연관된 기본 동작이 있다. 예를 들어 하이퍼링크에서 클릭 이벤트가 일어났을 때 기본 동작은 브라우저가 링크를 따라가서 새로운 페이지를 불 러오는 것이다. 이벤트 핸들러는 이벤트 객체의 메서드를 호출해 기본 동작을 방지할 수 있다.

### 이벤트 범주

**장치 의존적인 입력 이벤트**

이 이벤트는 마우스나 키보드 같은 특정 입력 장치에 직접적으로 묶여 있다.

mousedown, mousemove, mouseup, touchstart, touchmove, touchend, keydown, keyup

**장치 독립적인 입력 이벤트**

이런 입력 이벤트는 특정 입력 장치에 매여 있지 않다.

click, input, pointerdown, pointermove, pointerup

**사용자 인터페이스 이벤트**

UI 이벤트는 고수준 이벤트이며 웹 애플리케이션의 사용자 인터페이스로 동작 하는 HTML 폼 요소에서 자주 사용된다.

focus, change, submit

**상태 전환 이벤트**

일부 이벤트는 사용자의 활동이 아니라 네트워크와 브라우저 활동에 의해 일어나며 일종의 라이프 사이클이나 상태가 변경됐음을 알린다.

load, DOMContentLoaded, online, offline

**API 전용 이벤트**

HTML과 관련 명세에서 정의하는 다양한 웹 API도 자신만의 이벤트 타입을 갖는다.

<video>, <audio> → waiting, playing, seeking, volume change, 

IndexedDB API → success, error

### 이벤트 핸들러 등록

이벤트 핸들러를 등록하는 방법은 기본적으로 두 가지입니다.

웹 초기부터 사용되던 첫 번째 방법은 이벤트 대상인 요소나 객체에 프로퍼티를 설정하는 방법이다.

더 새롭고 일반적인 두 번째 방법은 객체나 요소의 addEventListener() 메서드에 핸들러를 전달하는 방법이다.

**이벤트 핸들러 프로퍼티 설정**

이벤트 핸들러를 등록하는 가장 단순한 방법은 이벤트 대상의 프로퍼티를 원하는 이벤트 핸들러 함수로 설정하는 방법이다. 관습적으로 이벤트 핸들러 프로퍼티 이름은 onclick, onchange, onload, onmouseover처럼 on 다음에 이벤트 이름을 붙인다. 이런 프로퍼티 이름은 대소문자를 구분하며 mousedown처럼 여러 단어로 구성 되어 있어도 전부 소문자로 쓴다.

<aside>
💡 리액트 프레임워크를 사용해 클라이언트 사이드 사용자 인터페이스를 만들어 본 경험만 있다면 생소하게 느껴질 수도 있다. 리액트는 클라이언트 사이드 이벤트 모델을 약간 바꾼 부분이 많은데 프로퍼티 이름을 onClick, onMouseOver처럼 카멜 케이스(camelCase)로 바꾼 것도 그 일환이다. 하지만 네이티브 웹 플랫폼에서는 이벤트 핸들러 프로퍼티를 모두 소문자로 쓴다.

</aside>

```tsx
// Window 객체의 onload 프로퍼티를 함수로 설정합니다.
// 이 함수가 이벤트 핸들러이며 문서를 불러올 때 호출됩니다.
window.onload = function () {
  // <form> 요소를 찾습니다.
  let form = document.querySelector('form#shipping');
  // 폼을 전송하기 전에 호출될 이벤트 핸들러 함수를 등록합니다.
  // isFomValidO는 다른 곳에서 정의했다고 가정합니다.
  form.onsubmit = function (event) {
    // 사용자가 폼을 전송할 때
    if (!isFormValid(this)) {
      // 폼 입력이 유효한지 체크합니다.
      event.preventDefault(); // 유효하지 않다면 폼 제출을 막습니다.
    }
  };
};
```

이벤트 핸들러 프로퍼티의 단점은 이벤트 대상이 이벤트 타입 하나당 최대 한 개의 핸들러만 받는다는 가정하에 설계됐다는 점이다. addEventListener()는 이전에 등록한 핸들러를 덮어 쓰지 않으므로 일반적으로 addEventListener()를 사용해 이 벤트 핸들러를 등록하는 게 더 좋다.

**이벤트 핸들러 속성 설정**

요소의 이벤트 핸들러 프로퍼티는 대응하는 HTML 태그의 속성으로 직접 정의할 수도 있다. 예를 들어 Window 요소에 등록할 핸들러를 HTML <body> 태그의 속성으로 정의할 수 있다. 이런 방식은 최신 웹 개발에서는 거의 사용하지 않지만 어쨌든 가능하긴 하며, 여전히 기존 코드에 남아 있는 경우도 있다.

이벤트 핸들러를 HTML 속성으로 정의할 때 속성 값은 자바스크립트 코드 문자열이어야 한다. 이 코드는 완료한 함수 선언이 아니라 이벤트 핸들러 함수의 바디여야 한다. 즉 HTML 이벤트 핸들러 코드를 중괄호로 둘러싸거나 앞에 func tion 키워드를 붙여서는 안 된다.

`<button onclick="console.log('Thank you');">Please Click</button>`

HTML 이벤트 핸들러 속성에 자바스크립트 문이 여러 개 포함됐다면 각 문을 세미콜론으로 구분하거나 속성 값을 여러 행으로 나눠 써야 한다.

자바스크립트 코드 문자열을 HTML 이벤트 핸들러 속성의 값으로 지정하면 브라우저는 함수 문자열을 다음과 같이 변환한다.

```tsx
function(event) {
	with(document) {
		with(this.form 11 {}) {
			with(this) { /* 코드 */ }
    } 
  }
}
```

event 인자는 핸들러 코드에서 현재 이벤트 객체를 event로 참조할 수 있다는 의미다. with 문은 핸들러 코드에서 대상 객체, 이를 포함하는 <form>, 포함하는 문서 객체를 마치 스코프에 존재하는 변수처럼 직접 참조할 수 있다는 뜻이다. 스트릭트 모드는 with 문을 금지하지만 HTML 속성의 자바스크립트 코드는 스트릭트 모드가 아니다. 이런 식으로 정의된 이벤트 핸들러는 예상하지 못 한 변수가 정의된 환경에서 실행된다. 이는 혼란스러운 버그를 유발할 수 있으며 HTML에 이벤트 핸들러를 작성하지 않는 이유이기도 하다.

**addEventListener()**

Window, Document, Element 객체는 모두 이벤트 대상이 될 수 있으며 이들의 addEventListener() 메서드를 통해 해당 객체에 이벤트 핸들러를 등록할 수 있다.

```tsx
<button id="mybutton">Click me</button>
<script>
let b = document.querySelector("#mybutton");
b.onclick = function() { console.log("Thanks for clicking me!"); };
b.addEventListener("click", () => { console.log("Thanks again!"); });
</script>
```

addEventListener()를 여러 번 호출해 같은 객체의 같은 이벤트 타입에 하나 이상의 핸들러 함수를 등록할 수 있다. 객체에서 이벤트가 일어나면 해당 타입의 이벤트에 등록된 핸들러가 등록 순서대로 호출된다. 같은 객체에서 같은 인자로 addEventListener()를 여러 번 호출해도 바뀌는 건 없다. 핸들러 함수는 한 번만 등록되며 핸들러 호출 순서도 바뀌지 않는다.

removeEventListener() 메서드는 addEventListener()의 반대이다. 같은 인자를(선택 사항으로는 세 번째 인자도) 받지만 이벤트 핸들러 함수를 추가하는게 아니라 제거한다.

addEventListener()가 선택 사항으로 받는 세 번째 인자는 불 값 또는 객체다. true를 전달하면 핸들러 함수는 캡처링 이벤트 핸들러로 등록되며 이벤트 전달의 다른 단계에서 호출된다. 이벤트 리스너를 등록할 때 세 번째 인자로 true를 전달했으면 핸들러를 제거할 때도 반드시 removeEventListener()에 세 번째 인자로 true를 전달해야 한다.

캡처링 이벤트 핸들러를 등록하는 건 addEventListener()가 지원하는 세 가지 옵 션 중 하나일 뿐이다. 다음과 같이 불 값 대신 객체를 전달해 원하는 옵션을 명시적으로 지정할 수 있다.

```tsx
document.addEventListener("click”, handleClick, {
	capture: true,
	once: true,
	passive: true
});
```

옵션 객체의 capture 프로퍼티가 true이면 이벤트 핸들러는 캡처링 핸들러로 등록된다. 이 프로퍼티가 false이거나 생략됐다면 핸들러는 캡처링을 사용하지 않는다.

옵션 객체의 once 프로퍼티가 true이면 이벤트 리스너는 한 번 호출된 뒤 자동으로 제거된다. 이 프로퍼티가 false이거나 생략됐다면 핸들러는 절대 자동으로 제거되지 않는다.

옵션 객체의 passive 프로퍼티가 true이면 이벤트 핸들러는 절대 preventDefault()를 호출해서 기본 동작을 취소하지 않는다. 이 옵션은 모바일 장치의 터치 이벤트에서 특히 중요합니다. 만약 touchmove 이벤트의 이벤트 핸들러가 브라우저의 기본 스크롤을 방해한다면 브라우저는 부드러운 스크롤 동작 을 구현할 수 없다. passive 프로퍼티는 이런 식으로 방해가 될 가능성이 있는 이벤트 핸들러를 등록할 때, 웹 브라우저에 이벤트 핸들러가 실행되는 동안 스크롤 같은 기본 동작을 수행해도 안전하다고 알려 주는 역할을 한다. 부드러운 스 크롤은 사용자 경험에 매우 중요하며 파이어폭스와 크롬은 touchmove, mousewheel 이벤트에 이 프로퍼티를 기본적으로 적용한다. 따라서 이런 이벤트에서 preventDefault()를 실제로 호출하려 한다면 passive 프로퍼티를 명시적으로 false로 설정해야 한다.

removeEventListener()에도 옵션 객체를 전달할 수 있긴 하지만 의미 있는 프로퍼티는 capture 프로퍼티 하나뿐이다. 이벤트 리스너를 제거할 때 once나 passive는 아무 의미 없으며 무시된다.

### 이벤트 핸들러 호출

이벤트 핸들러를 등록하면 웹 브라우저는 지정된 객체에 지정된 타입의 이벤트가 일어날 때마다 자동으로 이벤트 핸들러를 호출한다.

**이벤트 핸들러 인자**

이벤트 핸들러는 인자로 이벤트 객체 하나만 받는다. 이벤트 객체의 프로퍼티는 다음과 같이 이벤트에 관한 세부 사항을 제공한다.

type

일어난 이벤트 타입

target

이벤트가 일어난 객체

currentTarget

전달되는 이벤트라면 현재 이벤트 핸들러가 등록된 객체

timestamp

타임스탬프는 이벤트가 일어난 시간을 밀리초 단위로 나타내지만 절대적인 시간은 아니다. 두 번째 이벤트의 타임스탬프에서 첫 번째 이벤트의 타임스탬프를 빼는 방식으로 두 이벤트 사이에 경과한 시간을 알 수 있다.

isTrusted

웹 브라우저 자체에서 전달한 이벤트는 true, 자바스크립트 코드가 전달한 이벤트는 false다.

일부 이벤트에는 이외에도 다른 프로퍼티가 있다. 예를 들어 마우스와 포인터 이벤트의 clientX, clientY 프로퍼티는 이벤트가 일어난 좌표다.

**이벤트 핸들러 컨텍스트**

프로퍼티를 설정해 이벤트 핸들러를 등록하는 것은 마치 대상 객체에 새로운 메서드를 정의하는 것처럼 보인다.

`target.onclick = function() { /* 핸들러 코드 */ };`

따라서 이벤트 핸들러가 자신이 정의된 객체의 메서드처럼 호출되는 것도 놀라운 일이 아니다. 즉, 이벤트 핸들러의 바디 안에서 this 키워드는 이벤트 핸들러가 등록된 객체를 가리킨다.
핸들러는 대상을 this 값으로 해서 호출하며 , addEventListener()를 사용해 등록 한 핸들러도 마찬가지다. 하지만 화살표 함수로 정의된 핸들러는 그렇지 않다. 화살표 함수는 항상 자신이 정의된 스코프를 this 값으로 가진다.

**핸들러 반환 값**

최신 자바스크립트에서 이벤트 핸들러는 아무것도 반환해선 안 된다. 오래된 코드에는 이벤트 핸들러에 반환 값이 있고, 그 반환 값은 일반적으로 브라우저에 이벤트와 연관된 기본 동작을 수행하지 말라는 신호 구실을 한다.

예를 들어 폼의 전송 버튼에 있는 onclick 핸들러가 false를 반환한다면 (보통 이벤트 핸들러가 사용자 입력이 클라이언트 사이드 유효성 검사를 만족하지 못한다고 판단했을 때) 웹 브라우저는 폼을 전송하지 않는다.

브라우저의 기본 동작을 막는 표준 방법은 이벤트 객체에서 preventDefault() 메서드를 호출하는 것이다.

**호출 순서**

이벤트 대상의 이벤트 타입 하나에 이벤트 핸들러를 하나 이상 등록할 수 있다. 등록된 타입의 이벤트가 일어나면 브라우저는 핸들러를 등록된 순서대로 호출 한다. addEventListener()로 등록된 이벤트 핸들러와 객체 프로퍼티로 등록된 이벤트 핸들러가 섞여 있어도 마찬가지로 순서를 지킨다.

### 이벤트 전달

이벤트 대상이 Window 객체, 또는 기타 독립된 객체라면 브라우저는 이벤트에 반응해 그 객체에 적절한 핸들러를 호출하기만 한다. 반면 이벤트 대상이 Document 객체, 또는 그에 포함된 Element 객체라면 상황이 좀 복잡해진다.

대부분의 이벤트는 대상 요소에서 이벤트 핸들러를 호출한 뒤에도 DOM 트리를 따라 ‘버블링’하며 올라간다 . Document 객체를 지나 Window 객체까지 거슬러 올라간다. 이벤트 버블링은 개별 문서 요소 여러 개에 일일이 핸들러를 등록하는 일을 피하기 위해 만들어진 메커니즘이다.

대부분의 요소 이벤트는 버블링을 통해 거슬러 올라간다. focus, blur, scroll 이벤트는 예외다 load 이벤트는 버블링이 일어나지만 Document 객체에서 멈추며 Window 객체까지 전달되지는 않는다. (Window 객체의 load 이벤트 핸들 러는 문서 전체의 로딩이 끝났을 때만 호출된다.)

이벤트 버블링은 이벤트 전달의 세 번째 단계

대상 객제 자제에서 이벤트 핸들러를 호출하는 게 두 번째 단계

대상 핸들러를 호출하기 전에 일어 나는 첫 번째 단계를 ‘캡처링’ 단계라 부른다.

addEventListener()는 선택 사항인 세 번째 인자를 받는다고 했다. 그 인자가 true이거나 capture 프로퍼티가 true인 객체이면 이벤트 핸들러는 이벤트 전달의 첫 번째 단계 동안 캡처링 이벤트 핸들러로 등록된다. 이벤트 전달의 캡처링 단계는 버블링 단계를 거꾸로 한 것과 비슷하다. Window 객체의 캡처링 핸들러가 처음 호출되고, 다음은 Document 객체의 캡처링 핸들러, 다음은 body 요소의 캡처링 핸들러, 이런 식으로 DOM 트리 를 따라 내려오면서 이벤트 대상의 부모에서 캡처링 이벤트 핸들러를 호출할 때까지 계속한다. 이벤트 대상 자체에 등록된 캡처링 이벤트 핸들러는 호출되지 않는다.

이벤트 캡처링을 사용하면 대상에 도달하기 전에 이벤트를 먼저 살펴볼 기회가 있다. 캡처링 이벤트 핸들러는 디버깅에 사용하기도 하고 다음 절에서 설명할 이벤트 취소와 함께 대상 이벤트 핸들러가 실제로 호출되지 않게 이벤트를 거르는 용도로 사용하기도 한다. 이벤트 캡처링은 마우스 드래그 처리에 흔히 사용된다. 마우스 움직임에 관련된 이벤트는 드래그 대상인 문서 요소가 아니라 드래그되 는 객체에서 처리해야 한다.

### 이벤트 취소

이벤트 핸들러를 등록하면 이벤트 객체에서 preventDefault() 메서드를 호출해 브라우저의 기본 행동 을 막을 수 있다. (핸들러 등록 시 passive 옵션을 사용하면 preventDefault()는 무력화됩니다.)

이벤트 객체의 stopPropagation() 메서드를 호출해 이벤트의 전달을 취소할 수도 있다.

stopPropagation() 호출된 뒤 다른 객체의 이벤트 핸들러는 호출되지 않는다. stopPropagation()은 캡처링 단계에서, 이벤트 대상 자체에서, 버블링 단계에서 동작한다. stopImmediatePropagation()은 stopPropagatiorn()과 마찬가 지로 동작하지만 같은 객체에 후순위로 등록된 나머지 이벤트 핸들러의 호출도 방지한다.

### 커스텀 이벤트 전달

클라이언트 사이드 자바스크립트의 이벤트 API는 비교적 강력하며 이를 통해 직접 이벤트를 정의하고 전달할 수 있다.

자바스크립트 객체에 addEventListener() 메서드가 있다면 그 객체는 ‘이벤트 대상’이므로 dispatchEvent() 메서드 또한 가지고 있다. CustomEvent() 생성자로 이벤트 객체를 생성하고 dispatchEvent()에 전달할 수 있다.

CustomEvent()의 첫 번째 인자는 이벤트 타입을 나타내는 문자열이고 두 번째 인자는 이벤트 객체의 프로퍼티를 지정하는 객체입니다. 이 객체의 detail 프로퍼티에 문자열, 객체, 기타 이벤트 콘텐츠를 나타내는 값을 사용한다. 이벤트가 문서 트리를 버블링해 올라가길 원한다면 두 번째 인자에 bubbles:true를 추가한다.

```tsx
// 작업 중임을 UI에 알리는 커스텀 이벤트를 전달합니다.
document.dispatchEvent(new CustomEvent("busy", { detail: true }));

// 네트워크 동작
fetch(url)
	.then(handleNetworkResponse)
	.catch(handleNetworkError)
	.finally(() => {
		// 네트워크 요청이 성공하거나 실패하면 작업이 끝났으므로
		// 이제 바쁘지 않음을 알리는 또 다른 이벤트를 UI에 전달합니다.
		document.dispatchEvent(new CustomEvent("busy", { detail: false }));
	})；

// 프로그램의 다른 곳에서 busy 이벤트를 받아
// 모래시계를 표시하거나 숨겨서 사용자에게 알립니다.
document.addEventListener("busy", (e) => {
	if (e.detail) {
		showSpinner();
	} else 
		hideSpinner();
	}
});
```

## 문서 스크립트

클라이언트 사이드 자바스크립트의 목적은 정적인 HTML 문서를 대화형 웹 애플리 케이션으로 바꾸는 것이다. 따라서 웹 페이지의 콘텐츠를 변경하는 것이야말로 자바스크립트의 원래 목적이다.
Window 객체에는 항상 Document 객체를 참조하는 document 프로퍼티가 있다. 브라우저 창의 콘텐츠를 나타내는 Document 객체가 이 절의 주제다. 하지만 Document 객체는 단독으로 존재하지 않는다. Document 객체는 문서 콘텐츠를 표현하고 조작하는 DOM의 중심이다.

### 문서 요소 선택

전역 document 프로퍼티는 Document 객체를 참조하며 Document 객체에는 각각 <head>, <body> 태그에 대응하는 Element 객체를 참조하는 head, body 프로퍼티가 있다. 프로그램에서 문서의 더 깊은 곳에 존재하는 요소를 조작하기 위해서는 반드시 어떤 식으로든 그 요소를 참조하는 Element 객체를 선택해야 한다.

**css 선택자로 요소 선택**

DOM 메서드 querySelector(), querySelectorAll()은 지정된 CSS 선택자에 일치하는 요소를 찾는다.

```tsx
div // <div> 요소
#nav // id가 nav인 요소
.warning // 클래스 속성에 warning이 있는 요소
p[lang="fr"] // 프랑스어로 작성된 문단: <p lang="fr">
*[name="x"] // name 속성이 x인 요소 전체
span-fatal.error // 클래스에 fatal과 error가 있는 span 요소
span[lang="fr"].warning // warning 클래스가 있는 프랑스어 span 요소
#log span // id가 log인 요소의 자손인 span 요소
#log>span // id가 log인 요소의 자식인 span 요소
body>hl:first-child // body의 자식인 hl 중 첫 번째
img + p.caption // 이미지 바로 다음에 있고 클래스가 caption인 문단
h2 ~ p // h2 다음에 있는 형제인 문단
button, input[type="button"] // 버튼 전체, type이 button인 input 요소 전체

// id가 spinner인 요소를 찾습니다.
let spinner = document.queryselector("#spinner");

// hl, h2, h3 태그가 붙은 Element 객체를 모두 찾습니다.
let titles = document.querySelectorAH("hl, h2, h3");
```

querySelectorAll()의 반환 값은 Element 객체 배열이 아니라 배열 비슷한 객체인 노드리스트(NodeList)이다. 노드리스트 객체에는 length 프로퍼티가 있고 배열과 마찬가지로 인덱스할 수 있으므로 전통적인 for 루프로 순회할 수 있다. 노드리스트는 이터러블이기도 하므로 for/of 루프에서도 사용할 수 있다. 노드 리스트를 배열로 변환하려면 Array.from()에 전달하기만 하면 된다.

지정된 선택자에 일치하는 것이 없으면 querySelectorAll()이 반환하는 노드리스트의 length 프로퍼티 값은 0이다.

querySelector(), querySelectorAll()은 Document 클래스뿐만 아니라 Element 클래스에서도 지원한다. 이들 메서드를 요소에서 호출하면 해당 요소의 자손 중에서 일치하는 요소만 반환한다.

CSS에는 ::first-line, ::first-letter 가상 요소가 있다. 이들은 실제 요소가 아니라 Text 노드에 일치한다. querySelectorAll(), querySelector()에는 가상 요소를 사용할 수 없다. 또한 대부분의 브라우저가 :link, :visited 가상 클래스에 일치하는 것은 반환하지 않는다. 이들은 사용자의 브라우징 히스토리 정보를노출하기 때문이다.

closest() 역시 CSS에 기반한 요소 선택 메서드다. 이 메서드는 Element 클래스의 메서드이며 인자로 선택자를 받는다. 선택자가 요소 자체와 일치하면 해당 요소를 반환한다. 그렇지 않다면 선택자와 일치하는 가장 가까운 조상 요소를 반환하고, 조상 요소 중에 일치하는 것이 없으면 null을 반환한다.

어떤 면에선 closest()는 querySelector()의 반대이다. closest()는 요소에서 시작하고 트리를 올라가면서 일치하는 것을 찾는다. 반대로 querySelector()는 요소에서 시작해 트리를 내려가면서 일치하는 것을 찾는다. 문서 트리 상위에서 이벤트 핸들러를 등록했을 때 closest()를 유용하게 쓸 수 있다. 예를 들어 click 이벤트를 처리할 때 이벤트 대상이 하이퍼링크인지 확인하고 싶을 수 있다. 이벤트 객체는 대상이 무엇인지 알려 주지만, 대상이 하이퍼링크의 <a> 태그 자체가 아니라 그 안에 포함된 링크 텍스트일 수도 있다. 다음과 같이 이벤트 핸들러를 사용해 가장 가까운 하이퍼링크를 찾을 수 있다.

```tsx
// 가장 가까운, href 속성이 있는 a 태그를 찾습니다.
let hyperlink = event.target.closest("a[href]");

// 요소 e가 리스트 요소 안에 있다면 true를 반환합니다.
function insideList(e) {
	return e.closest("ul,ol,dl") !== null;
}

// e가 제목 요소이면 true를 반환합니다.
function isHeading(e) {
	return e.matches("hl,h2,h3,h4,h5,h6");
}
```

**다른 요소 선택 메서드**

DOM에는 querySelector(), querySelectorAll() 외에도 여러 가지 요소 선택 메서드가 있지만 이들은 이제 자주 쓰이지 않는다. 물론 이 메서드 중 일부는 여전히 웹에 존재하고, 특히 getElementByld()는 자주 보일 것이다.

```tsx
// id로 요소를 찾습니다. 인자는 id이며 CSS 선택자 전치사인 #은 쓰지 않습니다.
// document.querySelector("#sect1")와 비슷합니다.
let sectl = document.getElementByld("sectl");

// name 속성이 color인 요소를 모두 찾습니다.
// document.querySelectorAll('*[name="color"]');과 비슷합니다.
let colors = document.getElementsByNameCcolor");

// hl 요소를 모두 찾습니다. document.querySelectorAll("hl")과 비슷합니다.
let headings = document.getElementsByTagName("hl");

// getElementsByTagName()은 Element 객체에도 존재합니다.
// sectl 요소 안에 있는 h2 요소를 모두 찾습니다.
let subheads = sect1.getElementsByTagName("h2");

// 클래스가 tooltip인 요소를 모두 찾습니다.
// document.querySelectorAll(".tooltip")과 비슷합니다.
let tooltips = document.getElementsByClassName("tooltip");

// sectl의 자손 중 클래스가 sidebar인 요소를 모두 찾습니다.
// sectl.querySelectorAll(".sidebar")과 비슷합니다.
let sidebars = sect1.getElementsByClassName("sidebar");
```

querySelectorAll()과 마찬가지로 위 예제의 메서드는 모두 노드리스트를 반환하며, getElementByld()만 예외로 Element 객체 하나를 반환한다. 하지만 querySelectorAll()과 달리 이 오래된 선택 메서드들은 ‘살아 있는’ 노드리스트를 반환한다. 즉, 문서 콘텐츠나 구조가 변하면 이들이 반환하는 노드리스트의 콘텐츠나 길이도 그에 따라 바뀐다.

**미리 선택된 요소**

역사적인 이유로 Document 클래스에는 특정 노드에 접근하는 단축 프로퍼티가 있다. 예를 들어 images, forms, links 프로퍼티로 문서에 존재하는 <img>, <form>, <a> 요소에 쉽게 접근할 수 있다. 단, <a> 태그에 href 속성이 있어야 한다. 이 프로퍼티들은 노드리스트 객체와 아주 비슷한 HTMLCollection 객체를 참조하는데, HTMLCollection 객체는 요소 ID나 이름으로도 인덱스된다는 점이 다르다. 예를 들어 document.forms 프로퍼티를 쓰면 <form id=Uaddressn> 태그에 다음과 같이 접근할 수 있다.

`document.forms.address;`

더 오래된 API 중에는 document.all 프로퍼티도 있습니다. 이 프로퍼티는 HTML Collection과 마찬가지로 문서의 요소를 모두 찾습니다. 하지만 document.all은 폐 기 됐으므로 사용하지 말아야 한다.

### 문서 구조와 순회

문서에서 요소를 선택한 뒤 그 요소와의 관계를 통해 부모, 형제, 자식 요소를 찾아야 할 때도 있다. 순회(traversal) API는 문서를 Element 객체의 트리로 취급하며 Text 노드는 무시한다. 순회 API에는 메서드가 없다. 이 API는 주어진 요소의 부모, 자식, 형제를 참조하는 Element 객체의 프로퍼티일 뿐이다.

parentNode
요소의 부모를 참조한다. 부모 역시 또 다른 Element 객체이거나 Document 객체다.

children
이 노드리스트는 요소의 자식 인 요소를 포함하지만, 요소가 아닌 자식 인 Text 노드와 Comment 노드는 제외한다.

childElementCount
자식 요소 개수이다. children.length와 같은 값을 반환한다.

firstElementChild, lastElementChild
요소의 자식 중 첫 번째와 마지막을 각각 참조한다. 자식인 요소가 없다면 null 이다.

nextElementSibling, previousElementSibling
요소의 바로 앞이나 바로 다음에 있는 형제 요소를 참조하며 그런 형제가 없다면 null이다.

document.children[0].children[1]
document.firstElementChild.firstElementChild.nextElementSibling
(표준 HTML 문서 에서 두 표현식은 모두 <body> 요소를 참조한다.)

```tsx
// 문서나 요소 e를 재귀적으로 이동하며 e와 그 자손에서 함수 f를 호출합니다.
function traverse(e, f) {
	f(e); // e에서 f()를 호출합니다.
	for(let child of e.children) { // 자식을 순회하면서
		traverse(child, f); // 재귀 호출합니다.
	}
}

function traverse2(ef f) {
	f(e); // e에서 f()를 호출합니다.
	let child = e.firstElementChild; // 연결 리스트 스타일로 자식을 순회합니다.
	while(child !== null) {
		traverse2(child, f); // 재귀 호출합니다.
		child = child.nextElementsibling;
	}
}
```

**노드 트리인 문서**

Text 노드를 포함하여 문서 전체나 일부를 순회할 때는 Node 객체의 다른 프로퍼티를 사용한다. 이 프로퍼티에는 Element 노드, Text 노드, Comment 노드도 포함된다.
모든 Node 객체 에는 다음 프로퍼티가 있다.

parentNode
현재 노드의 부모. Document 객체처럼 부모가 없는 경우에는 null입니다.

childNodes
현재 노드의 자식 전체(자식 요소뿐만이 아닙니다)를 포함하는 읽기 전용 노드 리스트

firstChild, lastChild
현재 노드의 첫 번째와 마지막 자식 노드. 현재 노드에 자식이 없으면 null입니다.

nextSibling, previousSibling
현재 노드의 다음, 이전 형제 노드. 이 프로퍼티는 노드를 이중으로 연결된 리스트로 연결합니다.

nodeType
노드의 종류를 나타내는 숫자이다. Document 노드는 9, Element 노드는 1, Text 노드는 3, Comment 노드는 8이다.

nodeValue
Text나 Comment 노드의 텍스트 콘텐츠이다.

nodeName
요소의 HTML 태그 이름을 대문자로 변환한 문자열이다.

문서의 첫 번째 자식의 두 번째 자식 노드를 선택하는 표현식은 다음과 같이 만듭니다.

document.childNodes[0].childNodes[1]
document.firstChild.firstChild.nextSibling

```tsx
<html>
<head>
	<title>Test</title>
</head>
	<body>hello World!</body>
</html>
```

```tsx
// 요소 e의 일반 텍스트 콘텐츠를 반환하고 자식 요소로 재귀합니다.
// 이 메서드는 textcontent 프로퍼티와 비슷하게 동작합니다.
function textcontent(e) {
	let s = HH; // 텍스트를 여기 합칩니다.
	for(let child = e.firstChild; child !== null; child = child.nextSibling) {
		let type = child.nodeType;
		if (type === 3) { // Text 노드
			s += child.nodeValue; // 텍스트 콘텐츠를 문자열에 합칩니다.
		} else if (type === 1) { // Element 노드
			s += textContent(child); // 재귀 호출
		}
	}
	return s; 
}
```

### 속성

HTML 요소는 태그 이름, 속성이라 불리는 이름-값 쌍 세트로 구성된다. 예를 들어 하이퍼링크를 정의하는 <a> 요소의 href 속성 값은 링크의 대상이다.

Element 클래스에는 속성을 검색, 설정, 확인, 제거하는 getAttribute(), setAttribute(), hasAttribute(), removeAttribute() 메서드가 있다. 하지만 표준 HTML 요소의 표준 속성은 모두 그 요소를 나타내는 HTMLElement 객체의 프로퍼티로 존재하며 getAttribute()나 비슷한 메서드를 호출하는 것보다는 그냥 자바스크립트 프로퍼티를 사용하는 게 훨씬 쉽다.

**요소 프로퍼티인 HTML 속성**

```tsx
let image = document.querySelector("#main_image");
let url = image.src; // src 속성은 이미지의 URL입니다.
image.id === "main_image" // => true; 이미지를 id로 검색했습니다.

let f = document.querySelector("form"); // 문서의 첫 번째 폼
f.action = "https://www.example.com/submit"; // 제출할 URL을 정합니다.
f.method = "POST"; // HTTP 요청 타입을 설정합니다.
```

<input> 요소 같은 일부 요소에서는 HTML 속성 이름이 다른 이름의 프로퍼티와 연결되기도 한다. 예를 들어 <input>의 HTML value 속성은 자바스크립트 default Value 프로퍼티에 반영된다. <input> 요소의 자바스크립트 value 프로퍼티는 사용자가 현재 입력한 내용이지만, value 프로퍼티를 바꿔도 defaultvalue 프로퍼티나 value 속성은 영향받지 않다.

HTML 속성은 대소문자를 구분하지 않지만 자바스크립트 프로퍼티 이름은 대소문자를 구분한다. 속성 이름을 자바스크립트 프로퍼티로 변환할 때는 소문자를 쓴다. 속성 이름이 둘 이상의 단어로 이루어졌다면 두 번째 이후의 단어 첫 글 자를 대문자로 바꿔서 defaultChecked, tabindex처럼 표기한다. 하지만 onclick 같은 이벤트 핸들러 프로퍼티는 예외이며 모두 소문자로 작성한다.

일부 HTML 속성 이름 중에는 자바스크립트 예약어와 같은 이름도 있다. 이런 경우 일반적인 규칙은 프로퍼티 이름 앞에 전치사 html을 붙이는 것이다. 예를 들어 <label> 요소의 HTML for 속성은 자바스크립트 htmlFor 프로퍼티로 바뀐다. HTML class 속성은 이 규칙의 예외이며 자바스크립트 코드에서는 className 으로 바뀐다

HTML 속성을 나타내는 프로퍼티의 값은 보통 문자열이다. <input> 요소의 defaultChecked, maxLength 속성처럼 불이나 숫자 값을 사용하는 경우에는 프로퍼티도 불 또는 숫자이다. 이벤트 핸들러 속성의 값은 항상 함수 또는 null이다.

하지만 프로퍼티 기반 API에는 요소에서 속성을 제거할 수 있는 방법이 없다. delete 연산자는 이런 목적으로 사용할 수 없다. 속성을 제거하려면 remove Attribute() 메서드를 사용한다.

```tsx
<input id="test" value="test">
<script>
let input = document.getElementById('test')
console.log(input.value) // test
console.log(input.defaultValue) // test
input.value = 'text'
console.log(input.value) // text. 하지만 요소의 value 속성은 여전히 test입니다.
console.log(input.defaultvalue) // test
input.defaultvalue = 'text'
console.log(input.value) // text. 요소의 value 속성도 text로 바뀝니다.
console.log(input.defaultValue) // text
```

**class 속성**

HTML 요소의 class 속성은 특히 중요한 속성이다. 이 속성의 값은 요소에 적용되는 CSS 클래스를 공백으로 구분한 리스트이며 요소의 스타일을 결정한다. class는 자바스크립트 예약어이므로 이 속성은 Element 객체의 className 프로퍼티에 대응한다. className 프로퍼티를 통해 요소의 class 속성을 문자열 형태로 읽고 쓸 수 있다. 하지만 class 속성이라는 이름은 적합하지 않다. 이 값은 단일 CSS 클래스가 아니라 클래스 리스트이며, 클라이언트 사이드 자바스크립트 프로그래밍에서는 리스트를 문자열로 취급하지 않고 개별 클래스 이름을 추가하거나 제거할 때가 많다.

이 문제를 해결하기 위해 Element 객체에는 class 속성을 리스트로 취급하는 classList 프로퍼티가 있다. classList 프로퍼티의 값은 이터러블인 배열 비슷한 객체이다. 프로퍼티 이름이 classList이긴 하지만 이 프로퍼티는 클래스 세트에 더 가깝게 동작하며 , add(), remove(), contains(), toggle() 메서드가 있다.

```tsx
// 모래시계를 써서 사용자에게 현재 작업 중임을 알립니다.
// 이를 위해 hidden 클래스를 제거하고 animated 클래스를 추가합니다.
let spinner = document.querySelector("#spinner");
spinner.classList.remove("hidden");
spinner.classList.add("animated");
```

**데이터셋 속성**

```tsx
<h2 id="title" data-section-number="16.1">Attributes</h2>.
let number = document.querySelector("#title").dataset.sectionNumber;
```

## 요소 콘텐츠

**HTML인 요소 콘텐츠**

웹 브라우저는 HTML 분석에 최적화되어 있으며 innerHTML 설정은 보통 아주 효율적이다. 하지만 += 연산자로 innerHTML 프로퍼티 에 텍스트를 추가하면 요소 콘텐츠를 문자열로 변환하는 직렬화 단계 , 새로운 문자열을 요소 콘텐츠로 변환하는 분석 단계를 모두 거쳐야 하므로 효율적이지 않다.

**일반 텍스트인 요소 콘텐츠**

## CSS 스크립트

자바스크립트는 CSS 스크립트를 통해 문서의 외관과 레이아웃도 수정할 수 있다.

- display 스타일을 none으로 설정하면 요소를 감춘다. display를 다른 값으로 설정하면 다시 보이게 할 수 있다.
- 요소의 position을 absolute, relative, fixed로 설정하고 top, left에 원하는 좌표를 써서 요소의 위치를 동적으로 바꿀 수 있다. 자바스크립트로 모달 대화 상자나 툴팁 같은 동적 콘텐츠를 표시할 때 중요하다.
- transform 스타일을 써서 요소를 이동, 확대/축소, 회전할 수 있습니다.
- transition 스타일을 써서 CSS 스타일에 애니메이션을 적용할 수 있다. 애니메이션 자체는 웹 브라우저에서 자동으로 처리하므로 자바스크립트가 필요하지 않지만, 자바스크립트를 가지고 애니메이션을 시작할 수도 있다.

### css 클래스

자바스크립트로 문서 콘텐츠의 스타일을 바꾸는 가장 단순한 방법은 HTML 태그의 class 속성에 CSS 클래스를 추가하거나 제거하는 것이다.

```jsx
.hidden {
	display:none;
}

// HTML 파일 내 이 tooltip 요소에 class="hidden"이 있다고 가정합니다.
// 다음과 같이 요소를 보이게 할 수 있습니다.
document.querySelector("#tooltip").classList.remove("hidden");

// 다음과 같이 다시 숨길 수 있습니다.
document.querySelector("#tooltip").classList.add("hidden");
```

### 인라인 스타일

모든 Element 객체에는 style 속성에 대응하는 style 프로퍼티가 있다. 하지만 style 프로퍼티는 문자열이 아니라 CSSStyleDeclaration 객체다. CSSStyle-Declaration 객체는 style 속성에 텍스트 형태로 존재하는 CSS 스타일을 파싱한 결과다.

```jsx
function displayAt(tooltip, x, y) {
	tooltip.style.display = "block";
	tooltip.style.position = "absolute";
	tooltip.style.left = `${x}px`;
	tooltip.style.top = `${y}px`;
}
```

<aside>
💡 CSS 스타일 프로퍼티는 대부분 font-size처럼 이름에 하이픈이 포함된다. 자바스크립트는 하이픈을 마이너스 기호로 해석하며 프로퍼티 이름이나 식별자에 쓰는 것을 허용하지 않습니다. CSS 프로퍼티 이름에 하나 이상의 하이픈이 포함되어 있다면 CSSStyleDeclaration 프로퍼티 이름은 하이픈을 제거하고 그 하이픈 바로 다음에 있는 글자를 대문자로 바꾼다.

</aside>

```jsx
e.style.display = "block";
e.style.fontFamily = "sans-serif";
e.style.backgroundColor = "#ffffff";

e.style.marginLeft = 300; // 문자열이 아니라 숫자를 썼으므로 잘못된 값입니다.
e.style.marginLeft = "300"; // 단위가 빠졌으므로 잘못된 값입니다.
e.style.marginLeft = "300px";

e.style.left = `${x0 + left_border + left_padding}px`;

e.style.margin = `${top}px ${right}px ${bottom}px ${left}px`;

// 요소 e의 인라인 스타일을 요소 f에 복사합니다.
f.setAttribute("style", e.getAttribute("style"));

// 이렇게 해도 됩니다.
f.style.cssText = e.style.cssText;
```

요소의 style 프로퍼티를 가져올 때는 인라인 스타일만 가져올 수 있지만 스타일은 대부분 스타일시트로 지정된다는 점을 염두에 둬야 한다. 또한 style 프로퍼티 에서 가져오는 값은 단위나 단축 프로퍼티 형식을 HTML 속성에 있는 그대로 가져 오므로 복잡한 파싱 이 필요할 수도 있다. 일반적으로 요소의 스타일을 가져올 때는 다음 절에서 설명할 계산된 스타일이 아마 적합하다.

### 계산된 스타일

요소의 계산된 스타일은 브라우저가 요소의 인라인 스타일과 모든 스타일시트에서 가져온 적용 가능한 스타일 규칙 전체를 합해 계산한 프로퍼티 값 집합이다.

요소를 표시할 때 실제로 사용되는 프로퍼티 집합이다. 인라인 스타일과 마찬가지로 계산된 스타일 역시 CSSStyleDeclaration 객체로 표현된다.

인라인 스타일과 달리 계산된 스타일은 읽기 전용이다. 이 객체를 통해 스타일을 지정할 수는 없지만, 브라우저가 해당 요소를 렌더링할 때 어떤 스타일 프로퍼티 값을 사용하는지는 알 수 있다.

```jsx
let title = document.querySelector("#sectionltitle");
let styles = window.getComputedStyle(title);
let beforeStyles = window.getComputedStyle(title, "::before");
```

인라인 스타일을 나타내는 CSSStyleDeclaration 객체와 계산된 스타일을 나타내는 CSSStyleDeclaration 객체 사이 에는 몇 가지 중요한 차이가 있다.

- 계산된 스타일 프로퍼티는 읽기 전용이다.
- 계산된 스타일 프로퍼티는 절댓값이다. 퍼센트나 포인트 같은 상대 단위는 절댓값으로 변환된다. 마진 크기나 폰트 크기처럼 크기를 나타내는 프로퍼티는 모두 픽셀 값으로 바뀐다. 이 값은 px 접미사가 붙은 문자열이므로 여전히 파싱해야 하지만, 다른 단위가 붙는 경우는 없다. 색깔 값 프로퍼티는 rgb()나 rgba() 형식으로 반환된다.
- 단축 프로퍼티는 계산되지 않으며 베이스인 기본 프로퍼티만 계산된다. 예를 들어 margin 프로퍼티는 존재하지 않고 marginLeft, marginTop 같은 프로퍼티만 존재한다. 마찬가지로, border나 borderwidth는 존재하지 않으며 borderLeft Width, borderTopWidth 같은 프로퍼티를 사용해야 한다.
- 계산된 스타일에는 cssText 프로퍼티가 존재하지 않는다.

getComputedStyle()이 반환하는 CSSStyleDeclaration 객체는 일반적으로 요소의 인라인 style 프로퍼티에서 가져온 CSSStyleDeclaration 객체보다 더 많은 정보를 포함한다.

하지만 계산된 스타일은 까다로울 수 있고 여기서 원하는 정보를 항상 얻을 수 있다는 보장도 없다. font-family 속성은 호환성을 고려해 콤마로 구분한 폰트 패밀리 리스트다. 계산된 스타일에서 fontFamily 프로퍼티를 검색하면 요소에 적용되는 font-family 스타일을 반환할 뿐이다. 이 값은 “arial, Helvetica, sans-serif” 같은 값이며 실제로 어떤 폰트가 사용됐는지는 알 수 없다. 마찬가지로, 요소에 absolute 포지션이 지정되지 않았다면 top, left 프로퍼티로 계산된 스타일의 위치를 검색하려 해도 보통 auto 같은 값이 반환된다.

CSS로 요소의 위치와 크기를 정확히 지정할 수 있지만 계산된 스타일을 통해 요소의 위치와 크기를 가져오는 건 권하지 않는다.

### 스타일시트 스크립트

자바스크립트는 스타일시트 자체도 조작할 수 있다. 스타일시트는 <style> 태그 또는 <Unk rel="stylesheet”> 태그로 HTML 문서에 연결된다. 둘 다 정상적인 HTML 태그이므로 id 속성을 쓸 수 있고 document.querySelector()로 검색할 수 있다.
<style>, <link> 태그의 Element 객체 에는 disabled 프로퍼티가 있으며 이를 통해 스타일시트 전체를 비활성화할 수 있다.

```jsx
// 이 함수는 light와 dark 테마를 번갈아 적용합니다.
function toggleTheme() {
	let lightTheme = document.querySelector("#light-theme");
	let darkTheme = document.querySelector("#dark-theme");
	if (darkTheme.disabled) { // 현재 light 테마이며 dark 테마로 전환합니다.
		lightTheme.disabled = true;
		darkTheme.disabled = false;
	} else {
		lightTheme.disabled = false;
		darkTheme.disabled = true;
	}
}
```

```jsx
function setTheme(name) {
	// <link rel="stylesheet">를 새로 만들어 스타일시트를 불러옵니다.
	let link = document.createElement("link");
	link.id = "theme1";
	link.ret = "stylesheet";
	link.href = 'themes/${name}.css';

	// id가 theme인 기존 링크를 찾습니다.
	let currentTheme = document.querySelector("#theme");
	if (currentTheme) {
		// 기존 테마가 있으면 새 테마로 교체합니다.
		currentTheme.replaceWith(link);
	} else {
		// 없다면 테마 스타일시트 링크를 삽입합니다.
		document.head.append(link);
	}
}
```

```jsx
document.head.insertAdjacentHTML(
	"beforeend",
	"<style>body{transfom:rotate(180deg)}</style>"
);
```

### css 애니메이션과 이벤트

```jsx
.transparent { opacity: 0; }
.fadeable { transition: opacity .5s ease-in }

<div id="subscribe" class="fadeable notification">...</div>

document.querySelector("#subscribe").classList.add("transparent");
```

웹 브라우저는 트랜지션(transition)의 시작과 끝에서 이벤트를 일으키므로 자바스크립트를 써서 CSS 트랜지션의 진행을 모니터링 할 수 있다.

transitionstart 이벤트가 일어나고, 애니메이션 이 완료되면 transitionend 이벤트가 일어난다.

이 이벤트의 핸들러에 전달되는 이벤트 객체는 트랜 지션이벤트(TransitionEvent) 객체다. 이 객체의 propertyName 프로퍼티는 애니메이션을 적용받는 CSS 프로퍼티 이름이며 elapsedTime 프로퍼티는 transitionstart 이벤트로부터 경과된 시간을 나타낸다.

CSS는 더 복잡한 애니메이션인 ‘CSS 애니메이션’도 지원한다. CSS 애니메이션은 animation-name, animation-duration CSS 프로퍼티와 특별한 @keyframes 규칙을 사용해 애니메이션의 세부 사항을 정의한다.

CSS 트랜지션과 마찬가지로 CSS 애니메이션 역시 자바스크립트 코드에서 주시(listen)할 수 있는 이벤트를 일으킨다. animationstart는 애니메이션이 시작할 때, animationend는 애니메이션이 끝날 때 일어난다. 애니메이션이 두 번 이상 반복된다면 마지막을 제외하고 반복마다 animationiteration 이벤트가 일어난다.

이벤트 대상은 애니메이션이 일어나는 요소이며 핸들러 함수에 전달되는 이벤트 객체는 애니메이션이벤트(AniimtionEvent) 객체다. 이들 이벤트에는 애니메이션을 정의하는 CSS animation-name 프로퍼티에 대응하는 animationName 프로퍼티가 있고, 애니메이션이 시작된 후 경과한 시간을 나타내는 elapsedTime 프로퍼티가 있다.

## 문서 지오메트리와 스크롤

브라우저는 문서를 창에 렌더링할 때 각 요소의 위치와 크기를 지정 해 시각적으로 표현한다. 웹 애플리케이션에서는 문서를 트리로 취급하여 요소가 화면에 어떻게 렌더링되는지는 신경 쓰지 않아도 될 때가 많다. 하지만 때때로 요소의 위치를 정확히 파악해야 할 때도 있다. 예를 들어 툴팁 같은 요소의 위 치를 동적으로 지정하려면 기준이 되는 요소의 위치를 파악할 수 있어야 한다.

### 문서 좌표와 뷰포트 좌표

최상위 창과 탭에서 ‘뷰 포트’는 문서 콘텐츠를 실제로 표시하는 부분, 즉 메뉴와 툴바, 탭 등을 제거한 부분이다.

일반적으로 웹에서 문서 좌표는 큰 의미가 없다. CSS overflow 프로퍼티를 쓰면 요소에 그 요소가 표시할 수 있는 것 이상의 콘텐츠를 담을 수 있기 때문이다.

문서 좌표에 큰 의미가 없으므로 클라이언트 사이드 자바스크립트에서는 뷰포트 좌표를 쓰는 경우가 많다.

position:fixed를 써서 요소의 위치를 직접 지정한다면 top, left 프로퍼티는 뷰 포트 좌표를 기준으로 해석된다.

position:relative를 사용해 지정한다면 요소 는 position 프로퍼티를 아예 사용하지 않은 경우에 위치했을 곳을 기준으로 새 위치가 지정된다.

position:absolute를 사용한다면 top, left 프로퍼티는 포지션이 지정된 요소 중 가장 가까운 요소, 그런 것이 없다면 문서를 기준으로 해석된다.

<aside>
💡 1024X768 해상도의 컴퓨터 모니터, 320 X 480해상도의 터치스크린 폰을 기억할 정도로 나이가 좀 있는 독자라면 ‘픽셀’이라는 단어를 여전히 하드웨어상의 한 점으로 생각할 수도 있다. 최근의 4K 모니터와 ‘레티나’ 디스플레이는 해상도가 대단히 높아서 소프트웨어 픽셀과 하드웨어 픽셀을 따로 생각해야 한다. 따라서 CSS 픽셀, 즉 클라이언트 사이드 자바스크립트 픽셀 하나는 사실 여러 개의 하드웨어 픽셀로 구성될 수 있다. Window 객체의 devicePixelRatio 프로퍼티는 소프트웨어 픽셀 하나에 하드웨어 픽셀 몇 개가 사용되는지 나타낸다. 이 값이 2라면 각 소프트웨어 픽셀은 하드웨어 픽셀 2 X 2로 구성된다는 뜻이다. devicePixelRatio 값은 하드웨어의 물리적 해상도, 운영 체제 설정, 브라우저의 확대/축소 정도에 따라 다릅니다.
devicePixelRatio 값이 꼭 정수일 필요는 없다. CSS에서 폰트 크기를 12픽셀로 지정했 고 devicePixelRatio가 2.5라면 실제 폰트 크기는 하드웨어 픽셀로 30픽셀이다. CSS의 픽셀 값은 이제 화면의 개별 픽셀과 1:1로 대응하지 않으므로 픽셀 좌표 역시 정수가 아니어도 된다. devicePixelRatio가 3이己서면 3.33 같은 좌표를 쓸 수 있다. devicePixelRatio가 2라면 3.33인 좌표는 3.5로 반올림된다.

</aside>

### 요소의 위치 검색

getBoundingClientRect() 메서드를 호출해 요소의 크기(CSS 보더와 패딩은 포함, 마진은 제외)와 위치(뷰포트 좌표)를 파악할 수 있다. 이 메서드는 인자를 받지 않으며 left, right, top, bottom, width, height 프로퍼티가 있는 객체를 반환한다. left, top 프로퍼티는 좌측 상단 모서리의 x, y좌표이고 right, bottom 프로퍼티는 우측 하단 모서리의 좌표다. width, height 프로퍼티는 이 값들의 차이이다.
이미지, 문단, <div> 요소 같은 블록 요소는 항상 사각형으로 만들어진다. 반면 <span>, <code>, <b> 같은 인라인 요소는 여러 줄로 확장될 수 있으므로 사각형 여러 개로 만들어질 수 있다. 예를 들어 <em>. </em> 태그 사이에 텍스트가 있고 이 안에서 줄바꿈이 일어난다고 하자. 그러면 요소의 사각형은 첫 번째 행의 마지막, 두 번째 행의 처음으로 구성됩니다. 이 em 요소에서 getBoundingClientRect()를 호출하면 반환되는 객체의 width는 행 전체의 너비와 같다. getClientRects() 메서드는 인라인 요소의 개별 사각형에서 각각 getBoundingClientRect()를 호출한 것처럼 읽기 전용의 배열 비슷한 객체를 반환한다.

### 지정된 위치에 있는 요소 파악

getBoundingClientRect() 메서드로 요소의 현재 위치를 알 수 있다. 때로는 반대로 뷰포트에서 특정 좌표에 있는 요소가 무엇인지 알아야 할 때도 있다. Document 객체의 elementFromPoint() 메서드를 사용하면 된다. 원하는 x, y좌표 (예를 들어 마우스 이벤트의 clientX, clientY)로 이 메서드를 호출하면 지정된 위치에 있는 Element 객체가 반환된다. 요소를 선택하는 충돌 감지(hit detection) 알고리즘은 정확히 명시되지 않았지만, 이 메서드의 의도는 해당 지점에서 가장 안쪽의(가장 깊이 중첩된) 요소와 가장 위쪽의(z-index 속성이 가장 큰) 요소를 반환 하는 것이다.

### 스크롤

```jsx
// 문서와 뷰포트의 높이를 구합니다.
let documentHeight = document.documentElement.offsetHeight;
let viewportHeight = window.innerHeight;
// 마지막 '페이지’가 보이게 스크롤합니다.
window.scrollTo(0, documentHeight - viewportHeight);
```

```jsx
// 500밀리초마다 50픽셀씩 아래로 무한히 스크롤합니다.
setlnterval(() => { scrollBy(0,50)}, 500);
```

```jsx
window.scrollTo({
	left: 0,
	top: documentHeight - viewportHeight,
	behavior: "smooth"
});
```

일정 픽셀만큼 스크롤하기보다는 원하는 요소가 보일 때까지 스크롤하는 경우가 더 많다. 원하는 HTML 요소에서 scrollIntoView() 메서드를 사용하면 된다. 이 메서드는 호출된 요소가 뷰포트에 나타날 때까지 스크롤한다. 기본적으로 요소의 위쪽 경계를 뷰포트 위쪽 경계에 맞추려 하지만, 인자로 false 하나만 전달하면 반대로 요소의 아래쪽 경계를 뷰포트의 아래쪽 경계에 맞춘다. 브라우저는 필 요에 따라 뷰포트를 가로로도 스크롤한다.

scrollIntoView()에 behavior:”smooth" 프로퍼티가 있는 객체를 전달해 부드러운 스크롤을 만들 수 있다. block 프로퍼티를 써서 세로 위치를 정할 수 있고, 가로 스크롤이 필요하다면 inline 프로퍼티로 지정할 수 있다. 두 프로퍼티의 유효한 값은 start, end, nearest, center이다.

### 뷰포트 크기, 콘텐츠 크기, 스크롤 위치

브라우저 창의 뷰포트 크기는 window.innerWidth, window.innerHeight 프로퍼티로 알 수 있다. 모바일 장치에 최적화된 웹 페이지는 <head>에 <meta name =“viewport"> 태그를 써서 원하는 뷰포트 너비를 설정할 때가 많다.

문서의 전체 크기는 document.documentElement, 즉 <html> 요소의 크기와 같다. document .documentElement의 getBoundingClientRect()를 호출하거나 document.document Element의 offsetwidth, offsetHeight 프로퍼티에서 문서의 너비와 높이를 알 수 있다. 문서 의 스크롤 오프셋은 window.scrollX, window.scrollY으로 알 수 있다. 이들은 읽기 전용 프로퍼티이므로 문서 스크롤에는 사용할 수 없다. 대신 window.scrollTo()를 사용해야한다.

요소의 offsetwidth, offsetHeight 프로퍼티는 화면에 표시된 크기를 CSS 픽셀로 반환한다. 반환된 크기에는 요소의 보더와 패딩이 포함되지만 마진은 포함되지 않는다. offsetLeft, offsetTop 프로퍼티는 요소의 x, y좌표이다. 대부분의 요소에서 이 값은 문서 좌표다. 하지만 포지션이 지정된 요소의 자손, 기타 테이 블 셀 등의 요소에서 이 프로퍼티는 문서 자체가 아니라 컨테이너에 상대적인 좌표 이다.offsetparent 프로퍼티는 좌표의 기준이 되는 요소이다. 오프셋 프로퍼티는 모두 읽기 전용이다.

clientwidth, clientHeight는 offsetwidth, offsetHeight와 비슷하지만 보디가 포함되지 않으며 콘텐츠 영역과 패딩만 포함한다. clientLeft, clientTop 프로퍼티는 그리 유용하지는 않다. 이들은 요소의 패딩 바깥쪽과 보더 바깥쪽 사이의 거리이다. 보통 이 값은 왼쪽, 위쪽 보더의 너비와 일치하다. 이 클라이언트 프로퍼티는 읽기 전용이며 <i>, <code>, <span> 같은 인라인 요소에서는 0이다.

scrollwidth, scrollHeight는 요소의 콘텐츠 영역과 패딩, 넘치는 콘텐츠를 합한 크기이다. 콘텐츠가 오버플로 없이 콘텐츠 영역에 전부 들어간다면 이들 프로퍼티의 값은 clientwidth, clientHeight와 일치한다. 오버플로되어 콘텐츠가 넘친다면 그 크기가 포함되며 clentWidth, clientHeight보다 큰 값을 반환한다. scrollLeft, scrollTop은 요소의 뷰포트 안에 있는 요소 콘텐츠의 스크롤 오프셋
이다. Element 객체의 다른 프로퍼티와 달리 scrollLeft, scrollTop은 쓰기 가능 한 프로퍼티이며 이 값을 설정해 요소 안에서 콘텐츠를 스크롤할 수 있다. 대부분의 브라우저에서 Window 객체와 마찬가지로 Element 객체에도 scrollTo(), scrollBy() 메서드가 있지만 모든 브라우저에서 지원하지는 않는다.

## 웹 컴포넌트

HTML은 30년의 세월을 거치며 웹 애플리케이션의 사용자 인터페이스를 책임지는 언어로 발전했지만 <input>, <button> 같은 기본 HTML 태그는 최신 UI 디자인에 적합하지 않다.

웹 컴포넌트는 이런 프레임워크의 대안으로 브라우저에 네이티브로 추가된 기능이다. 비교적 최근에 웹 표준에 추가된 세 가지 기술을 활용해, 프레임 워크에 의존하지 않고 자바스크립트와 새로운 태그만 써서 재사용하기 쉬운 UI 컴포넌트를 만든다

### 웹 컴포넌트 사용

```jsx
<script type="module" src= "components/search-box.js">

<search-box placeholder="Search..."></search-box>
```

웹 컴포넌트는 HTML 태그 이름을 직접 정의하는데, 중요한 것은 이 태그 이름에 반드시 하이픈이 들어가야 한다는 것이다. 따라서 HTML의 미래 버전에서 하이픈 이 없는 새로운 태그를 도입하더라도 웹 컴포넌트와 충돌할 일은 없다. 웹 컴포넌트를 사용할 때는 HTML 파일에서 태그를 사용하기만 하면 된다.

```jsx
<search-box>
	<img src="images/search-icon.png" slot="left"/>
	<img src="images/cancel-icon.png" slot="right"/>
</search-box>
```

slot 속성은 자식 요소를 어디에 표시할지 정하는 속성이다. 슬롯 이름(left, right)은 웹 컴포넌트에서 정의한다. 선택한 컴포넌트에서 슬롯을 지원한다면 해당 내용 역시 문서에 포함되어 있을 것이다.

브라우저는 컴포넌트가 정의되기 전에 웹 컴포넌트 태그를 만날 경우 범용 HTMLElement를 DOM 트리에 추가한다. 그리고 나중에 커스텀 요소가 정의되면 그 범용 요소를 알맞게 ‘업그레이드’한다.

웹 컴포넌트에 자식 요소가 있으면 자식 요소는 컴포넌트가 정의되기 전에는 부정확하게 표시된다. 다음과 같이 CSS를 써서 웹 컴포넌트가 정의되기 전까지는 숨길 수 있다.

```jsx
/*
 * <search-box> 컴포넌트가 정의되기 전에는 숨깁니다.
 * 또한 최종 레이아웃과 크기를 미리 확보해 두면 요소가 생성되면서
 * 주변 컨텐츠를 다시 렌더링해 성능이 떨어지는 일(리플로)을 막을 수 있습니다.
 */
search-box:not(:defined) {
	opacity:0;
	display: inline-block;
	width: 300px;
	height: 50px;
}
```

웹 컴포넌트도 일반적인 HTML 요소와 마찬가지로 자바스크립트에서 사용할 수 있다. 웹 페이지에 <search-box> 태그를 사용하면 querySelector()와 적절한 CSS 선택자로 컴포넌트를 참조할 수 있다. 하지만 컴포넌트가 정의되기 전에는 참 조하는 것이 별 의미가 없으므로 너무 일찍 시도하지는 않는게 좋다. 일반적으로 자바스크립트 실행 환경은 웹 컴포넌트가 지원하는 HTML 속성을 자바스크립트 프로퍼티로 만들지만 반드시 그래야 한다는 규정은 없다. 또한 HTML 요소와 마찬가지로 웹 컴포넌트에도 메서드를 정의할 수 있다. 사용할 수 있는 프로퍼티와 메서드는 선택한 웹 컴포넌트의 문서에 나와있다.

### HTML 템플릿

웹 브라우저는 <template> 태그와 그 자식 요소를 절대 렌더링하지 않으므로 <template> 태그는 자바스크립트에서만 사용할 수 있다. 이 태그의 목적은 테이블 행 또는 웹 컴포넌트의 내부 구성 요소 같은 기본적인 HTML 구조가 웹 페이지에 여러 번 반복해야 할 때 <template>을 써서 한 번만 정의하고, 필요한 만큼 자바스크립트로 복사해서 쓰는 것이다.

자바스크립트에서 <template> 태그는 HTMLTemplateElement 객체로 나타낸다. 이 객체에는 content 프로퍼티 단 하나만 존재하며, 프로퍼티 값은 <template> 의 자식 노드로 이루어진 DocumentFragment이다. 이 DocumentFragment를 복사해서 필요한 만큼 문서에 삽입하면 된다. 프래그먼트 자체가 삽입되는 게 아니라 그 자식 요소가 삽입된다.

```jsx
let tableBody = document.querySelector('tbody');
let template = document.querySelector('#row');
let clone = template.content.cloneNode(true); // 깊은 복사
// ... 사본의 <td> 요소에 콘텐츠를 삽입하는 코드
// ... 복제되고 초기화된 행을 테이블에 삽입하는 코드
tableBody.append(clone);
```

템플릿 요소를 꼭 HTML 문서 안에 작성할 필요는 없다. 자바스크립트 코드에서 템플릿을 생성하고 innerHTML로 자식 요소를 생성하면 innerHTML을 파싱하는 부담이 줄어든다. 웹 컴포넌트는 일반적으로 이런 방식을 사용해 HTML 템플릿을 만든다.

### 커스텀 요소

웹 컴포넌트와 관련된 두 번째 웹 브라우저 기능은 ‘커스텀 요소’이다. 커스텀 요소는 자바스크립트 클래스와 HTML 태그 이름을 묶어서 해당 태그가 자동으로 클래스의 인스턴스가 되게 한다.

해당 태그 이름을 가진 기존 요소는 모두 새로 생성된 클래스 인스턴스로 ‘업그레이드’된다. 브라우저는 나중에 HTML을 파싱할 때 해당 태그 이름을 만날 때마다 자동으로 인스턴스를 만든다.

customElements.define()에 전달하는 클래스는 HTMLElement를 상속해야 하며 HTMLButtonElement 같은 구체적인 타입을 상속해서는 안 된다.

브라우저는 커스텀 요소 클래스에서 ‘수명 주기 메서드(lifecycle method)’를 자동으로 호출한다. 커스텀 요소 인스턴스를 문서에 삽입할 때 connectedCallback() 메서드가 호출되며 많은 요소에서 이 메서드를 초기화에 사용한다. 요소가 문서에서 제거될 때 호출되는 disconnectedCallback() 메서드도 있지만 이 메서드는 자주 사용되지 않는다.
속성 이름으로 이루어진 배열이 값인 정적 프로퍼티 observedAttributes가 있는 커스텀 요소 클래스에서 속성을 설정하거나 변경하면 브라우저는 attributeChangedCallback() 메서드를 호출하면서 속성 이름, 원래 값, 새로운 값을 인자로 전달한다. 속성 값에 따라 컴포넌트를 업데이트할 때 이 콜백을 사용할 수 있다.
커스텀 요소 클래스에는 다른 프로퍼티와 메서드도 필요한 만큼 정의할 수 있다. 요소 속성을 자바스크립트 프로퍼티로 사용할 수 있도록 게터와 세터 메서드는 보통 정의하는 편이다.

```jsx
customElements.define(
  'inline-circle',
  class InlineCircle extends HTMLElement {
    // 브라우저는 <inline-circle그 요소가 문서에 삽입될 때 이 메서드를
		// 호출합니다. disconnectedCallback() 메서드도 있지만 이 예제에서는
		// 사용하지 않습니다.
    connectedCallback() {
      // 원에 필요한 스타일
      this.style.display = 'inline-block';
      this.style.borderRadius = '50%';
      this.style.border = 'solid black 1px';
      this.style.transform = 'translateY(10%)';

      // 이미 정의된 크기가 없다면 현재 폰트 크기에 맞춰 기본 크기를 설정합니다.
      if (!this.style.width) {
        this.style.width = '0.8em';
        this.style.height = '0.8em';
      }
    }

    // 정적 프로퍼티 observedAttributes에 '이벤트'로 등록할 속성을 지정합니다.
    static get observedAttributes() {
      return ['diameter', 'color'];
    }

    // 이 콜백은 위에 나열한 속성이 바뀔 때 호출됩니다.
		// 커스텀 요소가 처음 파싱될 때도 호출됩니다.
    attributeChangedCallback(name, oldValue, newValue) {
      switch (name) {
        case 'diameter':
          // If the diameter attribute changes, update the size styles
          this.style.width = newValue;
          this.style.height = newValue;
          break;
        case 'color':
          // If the color attribute changes, update the color styles
          this.style.backgroundColor = newValue;
          break;
      }
    }

    // 요소 속성에 대응하는 자바스크립트 프로퍼티를 정의합니다.
		// 이들 게터와 세터는 단순히 대응하는 속성을 가져오고 설정하기만 합니다.
		// 자바스크립트 프로퍼티가 설정되면 해당 프로퍼티는 attributeChangedCallback()을
		// 호출해 요소 스타일을 업데이트합니다.
    get diameter() {
      return this.getAttribute('diameter');
    }
    set diameter(diameter) {
      this.setAttribute('diameter', diameter);
    }
    get color() {
      return this.getAttribute('color');
    }
    set color(color) {
      this.setAttribute('color', color);
    }
  }
);
```

### 섀도우 DOM

커스텀 요소를 진정한 웹 컴포넌트로 만들기 위해서는 섀도우 DOM이라고 불리는 강력한 캡슐화 메커니즘을 사용해야 한다.

섀도우 DOM은 커스텀 요소와 <div>, <span>, <body>, <article>, <main>, <nav>, <header>, <footer>, <section>, <p>, <blockquote>, <aside>, <hl> ~ <h6> 요소에 ‘섀도우 호스트’(shadow host)라 부르는 ‘섀도우 루트’(shadow root)를 붙일 수 있게 허용한다. 섀도우 호스트 요소는 모든 HTML 요소와 마찬가지로 자손 요소와 Text 노드로 구성된 일반적인 DOM 트리의 루트이다. 섀도우 루트는 섀도우 호스트에서 뻗어 나오는 자손 요소의 또 다른 루트이며, 그 자체로 별개의 미니 문서 라고 볼 수 있다.

섀도우 DOM의 ‘섀도우’는 섀도우 루트의 자손인 요소가 ‘그림자 속에 숨어 있는’ 성질을 갖는 데서 나온 용어이다. 섀도우 루트의 자손은 일반적인 DOM 트리에 속하지 않고, 호스트 요소의 children 배열에도 포함되지 않으며, querySelector() 같은 일반적인 DOM 순회 메서드에서 열거되지도 않는다. 이와 대비해서 섀도우 호스트의 일반적인 DOM 자식 요소를 ‘라이트(light) DOM’이라고 부르기도 한다.

HTML <audio>, <video> 요소를 생각해 보면 섀도우 DOM의 목적을 이해하기 쉽다. 이들 요소에는 미디어 제어에 필요한 사용자 인터페이스가 포함되어 있지만, 재생과 일시 정지 버튼을 비롯한 다른 UI 요소들은 DOM 트리에 노출되지 않으며 자바스크립트로 조작할 수도 없다. 웹 브라우저가 HTML을 표시하기 위해 만들어졌다는 점을 생각해 보면, 브라우저 제조사들이 이런 내부 UI까지 HTML로 만드는 것이 전혀 이상하지 않다. 사실 대부분의 브라우저는 이미 오랫동안 이와 비슷한 일을 해 왔고, 섀도우 DOM은 이를 웹 플랫폼의 표준으로 받아들인 것 뿐이다.

**섀도우 DOM 캡슐화**

섀도우 DOM의 핵심 특징은 캡슐화이다. 섀도우 루트의 자손 요소는 일반적인 DOM 트리에 독립적입니다. 아예 다른 문서 에 존재한다고 해도 과언이 아닐 정도로 독립적입니다. 섀도우 DOM은 매우 중요한 세 가지 종류의 캡슐화를 제공한다.

이미 언급했듯 섀도우 DOM에 들어 있는 요소는 querySelectorAll() 같은 일반 적인 DOM 메서드에 노출되지 않는다. 섀도우 루트를 생성할 때 ‘열린’ 모드와 ‘닫힌’ 모드를 선택할 수 있다. 닫힌 섀도우 루트는 완전히 밀봉되며 접근도 불가능하다. 하지만 섀도우 루트는 대부분 ‘열린’ 모드로 생성되며 섀도우 호스트에 shadowRoot 프로퍼티가 생기므로 필요하다면 자바스크립트로 섀도우 루트의 요소에 접근할 수 있다.

섀도우 루트 아래에서 정의한 스타일은 해당 트리에 종속되며 외부에 있는 라이트 DOM 요소에는 절대 영향을 끼치지 않는다. 섀도우 루트에서 호스트 요소의 기본 스타일을 정의할 수 있긴 하지만 라이트 DOM 스타일이 이를 덮어 쓴다. 마찬가지로, 섀도우 호스트 요소에 적용되는 라이트 DOM 스타일은 섀도우 루트의 자손 요소에는 아무 효과도 미치지 않는다. 섀도우 DOM의 요소는 라이트 DOM에서 폰트 크기나 배경색 등을 상속하고, 라이트 DOM에서 정의한 CSS 변수를 섀도우 DOM의 스타일에서도 사용할 수 있긴 하지만, 라이트 DOM 의 스타일과 섀도우 DOM의 스타일은 거의 대부분 완전히 독립적이다. 웹 컴포넌트 제작자와 사용자가 스타일시트 충돌을 걱정할 필요는 없다. 이렇게 CSS 범위를 지정하는 것이 아마 섀도우 DOM에서 가장 중요한 특징일 것이다.

섀도우 DOM 안에서 일어나는 load 같은 일부 이벤트는 섀도우 DOM으로 제한 된다. 반면, 포커스, 마우스, 키보드 이벤트 같은 이벤트에는 버블링이 적용된다. 섀도우 DOM에서 일어난 이벤트가 경계를 넘어 라이트 DOM으로 전달되기 시작하면 target 프로퍼티가 섀도우 호스트 요소로 변경되므로 그 요소에서 직접 발생한 것처럼 보인다.

**섀도우 DOM 슬롯과 라이트 DOM 자식 요소**

섀도우 호스트인 HTML 요소는 두 개의 트리를 가진다. 하나는 호스트 요소의 라이트 DOM 자손 요소인 children 배열이고, 다른 하나는 섀도우 루트와 그 자손 요소이다.

섀도우 루트의 자손 요소는 항상 섀도우 호스트 안에 표시된다.

섀도우 루트의 자손 요소에 <slot> 요소가 있다면 호스트 요소의 라이트 DOM 자식 요소는 그 <slot>의 자식인 것처럼 해당 슬롯의 섀도우 DOM 콘텐츠 대신 표시된다. 섀도우 DOM에 <slot>이 없다면 라이트 DOM 콘텐츠는 절대 표시 되지 않는다. 섀도우 DOM에 <slot>이 있지만 섀도우 호스트에 라이트 DOM 자식 요소가 없다면 슬롯의 섀도우 DOM 콘텐츠가 표시된다.

라이트 DOM 콘텐츠가 섀도우 DOM 슬롯 안에 표시될 때 이들 요소가 ‘분산(dis- tribute)’됐다고 표현하지만, 요소가 실제로 섀도우 DOM의 일부가 된 건 아님을 이해해야 한다. 라이트 DOM 콘텐츠는 여전히 querySelector()에 노출되며 호스트 요소의 자손 또는 자식 요소로 라이트 DOM 안에 존재한다.

섀도우 DOM에 <slot>이 하나 이상 있고 name 속성으로 이들의 이름을 정의했다면 섀도우 호스트의 자식 요소를 어떤 슬롯에 표시할지 slot=Uslotname” 속성으로 지정할 수 있다.

**섀도우 DOM API**

섀도우 DOM은 아주 강력하지만 자바스크립트 API는 의외로 단순하다. 라이트 DOM 요소를 섀도우 호스트로 전환할 때는 {mode:”open"}만 인자로 전달하면서 attachShadow() 메서드를 호출하면 된다. 이 메서드는 섀도우 루트 객체를 반환 하는 동시에 이 객체를 호스트의 shadowRoot 프로퍼티 값으로 설정한다. 섀도우 루트 객체는 DocumentFragment이며 DOM 메서드를 쓰거나 innerHTML 프로퍼티 에 HTML 문자열을 할당하는 방식으로 콘텐츠를 추가할 수 있다.

웹 컴포넌트에서 섀도우 DOM <slot>의 라이트 DOM 콘텐츠가 언제 바뀌었는지 알고 싶다면 <slot> 요소에 slotchanged 이벤트를 등록하면 된다.

### 예제: <search-box> 웹 컴포넌트

```jsx
/**
 * <input> 텍스트와 두 개의 아이콘 또는 이모지를 표시하는
 * 커스텀 HTML <search-box> 요소를 정의하는 클래스.
 * 이 요소는 기본적으로 텍스트 필드 왼쪽에 검색을 뜻하는 돋보기 이모지,
 * 오른쪽에 취소를 뜻하는 x 이모지를 표시합니다.
 * 입력 필드의 보더는 숨기고 자신의 보더는 표시하므로 두 이모지가
 * 입력 필드 안에 있는 것처럼 보입니다.
 * 마찬가지로, 입력 필드가 포커스를 받으면 요소 주변에 포커스가 표시됩니다.
 *
 * <search-box>에 slot="left" 또는 slot="right" 속성과 함께
 * <span> 또는 <img> 자식 요소를 써서 기본 아이콘을 덮어 쓸 수 있습니다.
 *
 * <search-box>는 일반적인 HTML disabled, hidden, size, placeholder
 * 속성을 지원하므로 <input> 요소와 마찬가지로 행동합니다.
 *
 * 내부 <input> 요소의 input 이벤트는 <sea rch-box> 요소로 버블링됩니다.
 *
 * 사용자가 왼쪽 이모지(돋보기)를 클릭하면 search 이벤트가 일어나고
 * 이 이벤트의 detail 프로퍼티는 현재 입력된 문자열입니다.
 * 텍스트가 변경되거나 사용자가 엔터 또는 탭을 눌렀을 때 내부 텍스트 필드에서 change
 * 이벤트가 일어나는데, 이때 search 이벤트도 함께 일어납니다.
 *
 * 사용자가 오른쪽 이모지(X)를 클릭하면 clear 이벤트가 일어납니다.
 * preventDefault()를 호출하는 핸들러가 없다면 clear 이벤트의 이벤트 전달이
 * 완료되는 즉시 사용자가 입력한 내용이 삭제됩니다.
 *
 * onsearch나 onclear 프로퍼티 또는 속성은 사용할 수 없습니다.
 * search와 clear 이벤트는 addEventListener()로만 등록할 수 있습니다.
 */
class SearchBox extends HTMLElement {
  constructor() {
    super(); // 슈퍼클래스 생성자를 호출합니다. 반드시 맨 처음에 있어야 합니다.

    // 섀도우 D0M 트리를 생성해 요소와 연결하고 나iis.아ladowRoot 값을 설정합니다.
    this.attachShadow({ mode: 'open' });

    // 이 커스텀 컴포넌트의 자손 요소와 스타일시트를 정의하는 템플릿을 복제해서
    // 섀도우 루트에 추가(append)합니다.
    this.shadowRoot.append(SearchBox.template.content.cloneNode(true));

    // 섀도우 DOM에 있는 중요한 요소의 참조를 가져옵니다.
    this.input = this.shadowRoot.querySelector('#input');
    let leftSlot = this.shadowRoot.querySelector('slot[name="left"]');
    let rightSlot = this.shadowRoot.querySelector('slot[name="right"]');

    // 내부 입력 필드가 포커스를 받거나 잃을 때 focused 속성을 추가/제거합니다.
    // When the internal input field gets or loses focus, set or remove
    // the "focused" attribute which will cause our internal stylesheet
    // to display or hide a fake focus ring on the entire component. Note
    // that the "blur" and "focus" events bubble and appear to originate
    // from the <search-box>.
    this.input.onfocus = () => {
      this.setAttribute('focused', '');
    };
    this.input.onblur = () => {
      this.removeAttribute('focused');
    };

    // 사용자가 돋보기를 클릭하면 search 이벤트를 일으킵니다.
    // 입력 필드에서 change 이벤트가 일어나도 search 이벤트가 함께 일어납니다.
    // (change 이벤트는 섀도우 D0M 바깥으로 버블링되지 않습니다.)
    leftSlot.onclick = this.input.onchange = (event) => {
      event.stopPropagation(); // Prevent click events from bubbling
      if (this.disabled) return; // Do nothing when disabled
      this.dispatchEvent(
        new CustomEvent('search', {
          detail: this.input.value,
        })
      );
    };

    // 사용자가 X를 클릭하면 clear 이벤트를 일으킵니다.
    // preventDefault()가 호출되지 않았으면 입력을 전부 지웁니다.
    rightSlot.onclick = (event) => {
      event.stopPropagation(); // click 이벤트의 버블링을 막습니다.
      if (this.disabled) return; // 비활성화 상태라면 아무 일도 하지 않습니다.
      let e = new CustomEvent('clear', { cancelable: true });
      this.dispatchEvent(e);
      if (!e.defaultPrevented) {
        // 이벤트가 취소되지 않았다면
        this.input.value = ''; // 입력 필드를 비웁니다.
      }
    };
  }

  // 속성이 변경되면 <input> 요소에 대응하는 값도 바꿔야 합니다.
  // 아래 수명 주기 메서드와 정적 프로퍼티 observedAttributes가 그 일을 담당합니다.
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'disabled') {
      this.input.disabled = newValue !== null;
    } else if (name === 'placeholder') {
      this.input.placeholder = newValue;
    } else if (name === 'size') {
      this.input.size = newValue;
    } else if (name === 'value') {
      this.input.value = newValue;
    }
  }

	// 마지막으로, 지원하는 HTML 속성에 대응하는 프로퍼티 게터와 세터를 정의합니다.
	// 게터는 속성의 값 또는 존재 여부만 반환하고, 세터는 값을 설정하기만 합니다.
  // Finally, we define property getters and setters for properties that
  // correspond to the HTML attributes we support. The getters simply return
  // the value (or the presence) of the attribute. And the setters just set
  // the value (or the presence) of the attribute. When a setter method
  // changes an attribute, the browser will automatically invoke the
  // attributeChangedCallback above.

  get placeholder() {
    return this.getAttribute('placeholder');
  }
  get size() {
    return this.getAttribute('size');
  }
  get value() {
    return this.getAttribute('value');
  }
  get disabled() {
    return this.hasAttribute('disabled');
  }
  get hidden() {
    return this.hasAttribute('hidden');
  }

  set placeholder(value) {
    this.setAttribute('placeholder', value);
  }
  set size(value) {
    this.setAttribute('size', value);
  }
  set value(text) {
    this.setAttribute('value', text);
  }
  set disabled(value) {
    if (value) this.setAttribute('disabled', '');
    else this.removeAttribute('disabled');
  }
  set hidden(value) {
    if (value) this.setAttribute('hidden', '');
    else this.removeAttribute('hidden');
  }
}

// 이 정적 필드는 attributeChangedCallback 메서드에 필요합느|디’.
// 이 배열에 포함되지 않은 속성은 att ributeChangedCallback 메서드를 호출하지 않습니다.
SearchBox.observedAttributes = ['disabled', 'placeholder', 'size', 'value'];

// <search-box> 요소의 인스턴스마다 사용할 요소의 트리와 스타일시트를
// 보관할 <template> 요소를 만듭니다.
SearchBox.template = document.createElement('template');

// HTML 문자열을 파싱해 템플릿을 초기화합니다. SearchBox의 인스턴스를 만들 때는
// 템플릿의 노드를 복제하기만 하면 되고 HTML을 다시 파싱할 필요는 없습니다.
SearchBox.template.innerHTML = `
<style>
/*
 * :host 선택자는 라이트 DOM의 <search-box> 요소를 참조합니다.
 * 이 스타일은 기본 값이며 라이트 D0M의 <search-box> 스타일로 덮어 쓸 수 있습니다.
 */
:host {
  display: inline-block;   /* The default is inline display */
  border: solid black 1px; /* A rounded border around the <input> and <slots> */
  border-radius: 5px;
  padding: 4px 6px;        /* And some space inside the border */
}
:host([hidden]) {          /* Note the parentheses: when host has hidden... */
  display:none;            /* ...attribute set don't display it */
}
:host([disabled]) {        /* When host has the disabled attribute... */
  opacity: 0.5;            /* ...gray it out */
}
:host([focused]) {         /* When host has the focused attribute... */
  box-shadow: 0 0 2px 2px #6AE;  /* display this fake focus ring. */
}

/* The rest of the stylesheet only applies to elements in the Shadow DOM. */
input {
  border-width: 0;         /* Hide the border of the internal input field. */
  outline: none;           /* Hide the focus ring, too. */
  font: inherit;           /* <input> elements don't inherit font by default */
  background: inherit;     /* Same for background color. */
}
slot {
  cursor: default;         /* An arrow pointer cursor over the buttons */
  user-select: none;       /* Don't let the user select the emoji text */
}
</style>
<div>
  <slot name="left">\u{1f50d}</slot>  <!-- U+1F50D is a magnifying glass -->
  <input type="text" id="input" />    <!-- The actual input element -->
  <slot name="right">\u{2573}</slot>  <!-- U+2573 is an X -->
</div>
`;

// 마지막으로, customElement.define()을 호출해 SearchBox 요소를 등록합니다.
customElements.define('search-box', SearchBox);
```

```jsx
<style>
  .search {
  /*  background: bisque;*/
    font-family: sans-serif;
  }
  #foo { user-select:none; }
</style>

<script src="search-box.js"></script>

<p id="foo">Testing, testing</p>

<search-box class="search" value="foobar" size="20" placeholder="Search...">
</search-box>
<p>Testing, testing</p>

<button onclick="changeSize()">Change size</button>
<button onclick="changePlaceholder()">Change placeholder</button>
<button onclick="changeValue()">Change value</button>
<button onclick="hide()">Disable</button>
<button onclick="show()">
  Enable<button>
    <script>
      let sb = document.querySelector('search-box');
      console.log('sb', sb);
      sb.addEventListener('clear', (e) => {
        console.log('clear event');
      });
      sb.addEventListener('search', (e) => {
        console.log('search event', e.detail);
      });

      sb.addEventListener('input', (e) => {
        console.log('input event targeted at', e.target);
        console.log(e);
      });

      sb.addEventListener('focus', console.log);
      sb.addEventListener('blur', console.log);
      sb.addEventListener('click', console.log);

      function changeSize() {
        sb.size = 30;
      }
      function changePlaceholder() {
        sb.placeholder = '?????????';
      }
      function changeValue() {
        sb.value = 'testing';
      }
      function hide() {
        sb.disabled = true;
      }
      function show() {
        sb.disabled = false;
      }
    </script>
  </button>
</button>
```

## SVG

SVG (Scalable Vector Graphics, 확장성 있는 벡터 그래픽)는 이미지 형식이다. 이름에 들어 있는 ‘벡터’라는 단어는 이 이미지가 픽셀 값 행렬로 이뤄진 GIF, JPEG, PNG 같은 비트맵 이미지와는 다름을 암시한다. SVG ‘이미지’는 원하는 그래픽 을 표현하는 데 필요한 단계들을 해상도와 상관없이 (따라서 확대/축소가 자유롭다) 정밀하게 표현하는 일종의 언어이다. SVG 이미지는 HTML과 아주 비슷한 XML 마크업 언어를 사용해 텍스트 파일로 작성한다.

웹 브라우저 에서 SVG를 사용하는 방법은 세 가지 이다.

1. .png나 .jpeg 이미지와 마찬가지로 <img> 태그 안에 .svg 이미지 파일을 사용할 수 있다.
2. SVG는 XML 기반이며 HTML과 비슷한 형 식이므로 HTML 문서 에 SVG 태그를 직접 사용할 수 있다. 이렇게 하면 XML 네 임스페이스를 생략하더라도 브 라우저의 HTML 파서가 SVG 태그를 HTML 태그처럼 취급한다.
3. 필요에 따라 DOM API를 사용해 동적으로 SVG 요소를 생성해 이미지를 만들 수 있다.

### HTML 속 SVG

### SVG 스크립트

### 자바스크립트로 SVG 이미지 생성

## <canvas>의 그래픽

<canvas> 요소는 그 자체로는 아무것도 표현하지 않지만 일종의 도화지를 만들고 클라이언트 사이드 자바스크립트에서 사용할 수 있는 강력한 API를 제공한다.

캔버스 API와 SVG의 가장 큰 차이는 캔버스는 메서드를 호출하는 방식으로 그림을 그리는 반면, SVG는 XML 요소의 트리를 만드는 방식으로 그림을 그린다는 것이다. 두 방법은 모두 강력하며 기능에는 큰 차이가 없다. 하지만 표면적으로 볼 땐 상당히 다르며 각 방법에 장점과 약점이 존재한다. 예를 들어 SVG 그래픽은 요소를 삭제하는 방식으로 쉽게 수정할 수 있다. 반면 <canvas>에서 같은 그래픽의 요소 하나를 제거하더라도 처음부터 다시 그려야 할 때가 많다.

### 패스와 다각형

### 캔버스 크기와 좌표

### 그래픽 속성

### 캔버스 그리기 동작

### 좌표계 변환

### 자르기

### 픽셀 조작

## 오디오 API

HTML <audio>, <video> 태그를 통해 웹 페이지에 사운드와 비디오를 넣을 수 있다. 이들의 API는 상당히 복잡하며 사용자 인터페이스도 결코 간단하지 않다. play(), pause() 메서드로 미디어 재생을 제어할 수 있다. volume, playbackRate 프로퍼티로 오디오 볼륨과 재생 속도를 제어할 수 있다. 또한 currentTime 프로퍼티로 원하는 재생 위치까지 넘길 수도 있다.

### Audio() 생성자

HTML 문서에 <audio> 태그를 삽입하지 않아도 웹 페이지에서 사운드 효과를 이용 할 수 있다. DOM의 document.createElement() 메서드로 <audio> 요소를 동적으로 생성하거나 그냥 Audio() 생성자를 써도 된다. 생성한 요소를 문서에 추가 할 필요도 없다. 그냥 play() 메서드를 호출하기만 해도 된다.

```jsx

// 사용할 사운드 효과를 미리 불러옵니다.
let soundeffect = new Audio("soundeffect.mp3");

// 사용자가 마우스 버튼을 클릭할 때마다 사운드를 재생합니다.
document.addEventListener("click", () => {
	soundeffect.cloneNode ().play(); // 사운드를 불러와서 재생합니다.
})；
```

위 예제에서는 cloneNode()를 사용했습니다. 사용자가 마우스를 빠르게 클릭한다면 각각의 클릭에 대응할 audio 요소가 여러 개 필요할 수 있기 때문이다. 복사한 audio 요소는 문서에 추가하지 않았으므로 재생을 마친 후 가비지 컬렉션 대상이 된다.

### WebAudio API

웹 브라우저는 audio 요소를 통해 녹음된 사운드를 재생하기도 하지만, WebAudio API를 통해 사운드를 직접 생성해서 재생할 수도 있다. WebAudio API를 통해 파형 (waveform)의 소스, 변환, 대상을 나타내는 AudioNode 객체를 만들고 이 노드를 한데 묶어서 사운드를 만들 수 있다.

```jsx
// audioContext 객체를 만듭니다. 사파리에서는 아직 webkitAudioContext를 사용해야 합니다.
let audioContext = new (this.AudioContext || this.webkitAudioContext)();

// 순수한 사인(sine)파 세 개를 조합해 베이스 사운드를 정의합니다.
let notes = [293.7, 370.0, 440.0]; // D major chord: D, F# and A

// 재생할 음표(note)마다 오실레이터(oscillator) 노드를 만듭니다.
let oscillators = notes.map((note) => {
  let o = audioContext.createOscillator();
  o.frequency.value = note;
  return o;
});

// 시간에 따라 볼륨을 조절해 사운드를 다듬습니다.
// 시작하는 즉시 풀 볼륨으로 올리고, 0.1 초가 지나면 서서히 0으로 내립니다.
let volumeControl = audioContext.createGain();
volumeControl.gain.setTargetAtTime(1, 0.0, 0.02);
volumeControl.gain.setTargetAtTime(0, 0.1, 0.2);

// 사운드를 기본 대상인 사용자의 스피커에 전달합니다.
let speakers = audioContext.destination;

// 음표와 볼륨 컨트롤을 연결합니다.
oscillators.forEach((o) => o.connect(volumeControl));

// 볼륨 컨트롤 출력을 사용자 스피커와 연결합니다.
volumeControl.connect(speakers);

// 사운드 재생을 시작하고 1.25초 동안 재생합니다.
let startTime = audioContext.currentTime;
let stopTime = startTime + 1.25;
oscillators.forEach((o) => {
  o.start(startTime);
  o.stop(stopTime);
});

// 사운드를 연속으로 재생하고 싶다면 이벤트 핸들러를 쓸 수 있습니다.
oscillators[0].addEventListener('ended', () => {
  // 이 이벤트 핸들러는 사운드 재생이 끝날 때 호출됩니다.
});
```