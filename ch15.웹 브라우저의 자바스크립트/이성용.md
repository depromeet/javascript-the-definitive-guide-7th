# 15장 웹 브라우저의 자바스크립트

이 장에서 웹 API를 모두 설명하는 것은 불가능하지만, 가장 중요한 API는 모두 소개하고 즉시 사용할 수 있도록 자세히 설명한다.

## 웹 프로그래밍 기본

### HTML <script> 태그 속의 자바스크립트

```tsx
<!DOCTYPE html>
<!-- This is an HTML5 file -->
<html>
  <!-- The root element -->
  <head>
    <!-- Title, scripts & styles can go here -->
    <title>Digital Clock</title>
    <style>
                               /* A CSS stylesheet for the clock */
      #clock {                        /* Styles apply to element with id="clock" */
        font: bold 24px sans-serif;   /* Use a big bold font */
        background: #ddf;             /* on a light bluish-gray background. */
        padding: 15px;                /* Surround it with some space */
        border: solid black 2px;      /* and a solid black border */
        border-radius: 10px;          /* with rounded corners. */
      }
    </style>
  </head>
  <body>
    <!-- The body holds the content of the document. -->
    <h1>Digital Clock</h1>
    <!-- Display a title. -->
    <span id="clock"></span>
    <!-- We will insert the time into this element. -->
    <script>
      // Define a function to display the current time
      function displayTime() {
        let clock = document.querySelector('#clock'); // Get element with id="clock"
        let now = new Date(); // Get current time
        clock.textContent = now.toLocaleTimeString(); // Display time in the clock
      }
      displayTime(); // Display the time right away
      setInterval(displayTime, 1000); // And then update it every second.
    </script>
  </body>
</html>
```

js 파일에 저장했다면 다음과 같이 <script> 태그에서 파일을 참조할 수 있다.

`<script src="scripts/digital_clock.js"></script>`

방대한 자바스크립트 코드를 HTML 파일에서 제거해 단순화합니다. 즉, ‘내용’과 ‘동작’을 분리한다.

여러 개의 웹 페이지에서 같은 자바스크립트 코드를 공유할 때 src 속성을 쓰면 코드 하나만 관리해도 된다.

자바스크립트 코드를 여러 페이지에서 공유한다면 한 번만 내려받으면 된다. 첫 번째 페이지에서 코드를 내려받으면 다른 페이지는 브라우저 캐시에서 가져 올 수 있다.

src 속성은 임의의 URL을 값으로 받으므로 한 서버에 있는 자바스크립트 프로 그램이나 웹 페이지가 다른 웹 서버에 있는 코드를 가져올 수 있다. 인터넷 광고는 대부분 이를 바탕으로 만들어진다.

**모듈**

자바스크립트 프로그램을 모듈로 작성했다면 (그리고 코드 번들링 도구를 써서 모듈을 하나의 자바스크립트 파일로 조합하지 않았다면) 반드시 최상위 모듈을 <script type="module”> 태그로 불러와야 한다.

**스크립트 타입 지정**

웹 초기에는 언젠가 브라우저에서 자바스크립트가 아닌 다른 언어가 쓰일 것을 염두에 두고 <script> 태그에 language="javascript", type="application/java script" 같은 속성을 추가했다. 하지만 이는 완전히 불필요하다. 자바스 크립트는 웹의 기본 언어이자 유일한 언어이다. language 속성은 폐기됐으며 <script> 태그에 type 속성을 사용하는 경우는 단 두 가지뿐이다.

- 스크립트가 모듈일 때
- 웹 페이지에 데이터를 가져오지만 표시하지는 않을 때(15.3.4절 참고)

**스크립트 실행 시점: async와 defer**

<script> 태그에 defer, async 속성을 써서 스크립트 실행 방식을 바꿀 수 있다.

defer, async 속성은 모두 연결된 스크립트에 HTML을 만드는 document.write()가 없으므로 브라우저가 스크립트를 다 내려받을 때까지 기다리지 않고 문서 분석과 렌더링을 계속해도 된다.

defer 속성은 문서를 완전히 내려받고 분석해서 조작 할 준비가 끝날 때까지 스크립트 실행을 지연(defer)하라는 의미입니다.

async 속성은 브라우저가 스크립드를 가능한 빨리 실행하되 스크립트를 내려받는 동안 문 서 분석을 계속해도 된다는 뜻입니다.

<script> 태그에 두 속성이 모두 존재한다면 async 속성이 우선순위를 갖습니다.

지연된 스크립트는 문서 출처 순서대로 실행된다. 비동기 스크립트는 불러오는 즉시 실행되므로 문서 출처대로 실행되지 않을 수도 있다.

type="module" 속성이 있는 스크립트는 기본적으로 defer 속성이 있는 것처럼 문서 로딩이 끝난 후 실행된다. async 속성을 쓰면 문서 로딩이 끝날 때까지 대기하지 않고 가져온 모듈 전부를 불러오는 즉시 실행을 시작한다.

async, defer 속성을 쓰지 않고 스크립트를 HTML 파일의 마지막에 불러오기만 해도 같은 효과를 볼 수 있다. 이렇게 하면 브라우저가 문서 로드와 분석을 이미 끝낸 상태이므로 스크립트에서 문서 콘텐츠를 조작해도 안전하다.

**필요에 따른 스크립트 로드**

문서를 처음 불러올 때는 필요가 없지만 사용자가 버튼을 클릭하거나 메뉴를 여는 등 어떤 행동을 했을 때만 필요한 자바스크립트 코드도 있다.

모듈을 사용해 코드를 개발했다면 import()를 써서 필요한 모듈만 불러 올 수 있다.
모듈을 사용하지 않는다면 스크립트를 불러올 때 문서에 <script> 태그를 추가 해서 자바스크립트 파일을 불러올 수 있다.

```tsx
// 지정된 URL에서 비동기적으로 스크립트를 불러와서 실행합니다.
// 스크립트를 불러오면 해석되는 프라미스를 반환합니다
function importScript(url) {
  return new Promise((resolve, reject) => {
    let s = document.createElement('script'); // <script> 요소 생성
    s.onload = () => {
      resolve();
    }; // 프라미스 해석
    s.onerror = (e) => {
      reject(e);
    }; // 실패 시 거부
    s.src = url; // 스크립트 URL 설정
    document.head.append(s); // 문서에 <script> 추刀F
  });
}
```

### 문서 객체 모델

Document 객체는 브라우저 창이나 탭에 표시되는 HTML 문서를 나타내는 객체이며 클라이언트 사이드 자바스크립트 프로그래밍에서 가장 중요한 객체 중 하나다.

DOM API는 HTML 문서의 트리 구조를 반영한다. 문서에 존재하는 HTML 태그마다 그에 대응하는 자바스크립트 Element 객체가 있고, 문서에 존재하는 텍스트마다 그에 대응하는 Text 객체가 있다. Element, Text, Document 클래스는 모두 Node 클래스의 서브클래스이며 Node 객체는 트리 구조로 되어 있어, 자바스크립트에서 DOM API를 사용해 검색하고 이동할 수 있다.

노드의 바로 위에 있는 노드는 그 노드의 부모 (parent)

한 노드의 바로 아래 있는 노드는 자식(children)

같은 레벨에 있는 노드이고, 서로 부모도 같다면 그들은 형제 (sibling)

어떤 노드의 아래에 있는 노드는 몇 단계에 걸쳐 있든 그 노드의 자손(descendant)

부모, 조부모 등 어떤 노드의 위에 있는 노드는 몇 단계 에 걸쳐 있든 그 노드의 조상(an- cestor)이다.

DOM API에는 새로운 Element, Text 노드를 생성하고 이들을 다른 Element 객체의 자식으로 문서에 삽입하는 메서드가 있다. 문서 안에서 요소를 이동하거나 완전히 제거하는 메서드도 있다.

각 HTML 태그 타입에 대응하는 자바스크립트 클래스가 있고 문서에 존재하는 각 태그는 클래스의 인스턴스로 표현된다.

### 웹 브라우저의 전역 객체

브라우저 창이나 탭마다 이에 대응하는 전역 객체가 하나씩 있다. 워커 스레드를 제외한 모든 자바스크립트 코드는 전역 객체를 공유한다. 문서에 스크립트나 모듈이 얼마나 많든 관계없습니다. 스크립트에서 전역 객체에 프로퍼티를 정의하면 그 프로퍼티는 다른 스크립트 전체에서 볼 수 있다.

자바스크립트의 표준 라이브러리는 전역 객체에 정의된다.

웹 브라우저에서 전역 객체는 두 가지 임무를 수행한다. 전역 객체는 내장 타입과 함수를 정의하기도 하지만 현재 웹 브라우저 창을 나타내기도 하며 그 창의 브라우징 히스토리를 나타내는 history, 창의 너비를 픽셀로 나타내는 inner Width 같은 프로퍼티를 정의하기도 한다. 이 전역 객체에는 window 프로퍼티가 있으며 그 값은 전역 객체 자체이다. 따라서 클라이언트 사이드 코드에서 window를 입력해 전역 객체를 참조할 수 있다. 전역 객체와 관련된 기능을 사용할 때는 앞에 window.를 붙이는 편이 좋다. 예를 들어 innerWidth보다는 window, inner Width가 더 명확하다.

### 네임스페이스를 공유하는 스크립트

모듈의 최상위 레벨, 즉 다른 함수나 클래스 정의 바깥에서 정의한 상수, 변수, 함 수, 클래스는 명시적으로 내보내지 않는 한 그 모듈에서만 사용하는 비공개 변수이다.

모듈이 아닌 스크립트에서는 완전히 다르다. 스크립트의 최상위 코가 상수, 변수, 함수, 클래스를 정의하면 그 선언은 같은 문서에서 실행된 모든 스 크립트에서 볼 수 있다. 어떤 스크립트에서 함수 f()를 정의하고 다른 스크립트에서 클래스 e를 정의한다면 세 번째 스크립트에서는 그들을 가져오지 않고도 함수를 호출하고 클래스의 인스턴스를 만들 수 니다. 따라서 모듈을 사용하지 않는다면 문서에 존재하는 독립적인 스크립트들이 네임스페이스를 공유하며 거대한 스크립트의 일부인 것처럼 행동한다. 작은 프로그램에서는 편리할 수도 있지만 큰 프로그램에서는 겹치는 이름을 피하는 일도 고역이 될 수 있으벼 서드 파티 라이브러리를 사용한다면 이 문제가 더 커질 수 있다.

반면 ES6의 const, let, class는 최상위 레벨에서 사용하더라도 전역 객체가 아니라 공유된 네임스페이스 안에 생성된다. 스크립트에서 클래스 e를 정의하면 다른 스크립트에서는 new window.C()가 아니라 new C()로 그 클래스의 인스턴스를 만든다.

### 자바스크립트 프로그램 실행

웹 페이지에 <iframe> 요소로 임베드된 프레임이 있다면, 그 임베드된 문서의 자바스크립트 코드는 임베드한 문서와는 다른 전역 객체와 Document 객체를 가지므로 별도의 자바스크립트 프로그램이라고 볼 수 있다. 하지만 앞서 말했듯 자바스크립트 프로그램의 경계를 정하는 공식 정의는 없다. 포함하는 문서와 포함된 문서를 같은 서버에서 불러왔다면 각 문서의 코드가 상호작용할 수 있으며 이들을 프로그램 하나를 이루는 각 부분으로 생각할 수도 있다.

자바스크립트 프로그램은 두 단계(phase)로 실행된다고 생각해도 무방하다.

첫 번째 단계에서는 문서 콘텐츠를 불러오고 <script> 요소의 코드를 실행한다. 스크립트는 일반적으로 문서 순서대로 실행되지만 async, defer 속성에 의해 순서가 바뀔 수 있다. 스크립트에 포함된 자바스크립트 코드는 위쪽에서 아래쪽으로 실행되지만, 자바스크립트의 조건문, 루프, 기타 제어문에 의해 순서가 바뀔 수 있다. 일부 스크립트는 첫 번째 단계에서는 거의 아무 일도 하지 않고 두 번째 단계에 사용할 함수와 클래스를 정의하기만 한다. 어떤 스크립트는 첫 번째 단계 에서만 동작하고 두 번째 단계에서는 아무것도 하지 않는다. 문서의 마지막에 있는 스크립트가 <hl>, <h2> 태그를 모두 찾아서 차례를 만들어 문서 처음에 삽입한다고 하자. 이 작업은 첫 번째 단계에서 완전히 끝날 수 있다.

문서 로딩이 끝나고 스크립트를 전부 실행하면 자바스크립트는 두 번째 단계에 들어간다. 이 단계는 비동기적이며 이벤트 주도적이다. 스크립트가 두 번째 단계에서 동작하려면 반드시 첫 번째 단계에서 하나 이상의  벤트 핸들러나 다른 콜백 함수를 등록해야 한다. 이벤트 주도적인 두 번째 단계에서 웹 브라우저는 비동기적으로 일어나는 이벤트에 응답해 이벤트 핸들러나 기타 콜백을 호출한다. 이벤트 핸들러는 대부분 마우스 클릭이나 키 입력 등 사용자의 입력에 응답하지만 네트워크 활동, 문서나 자원 로딩, 경과한 시간, 자바스크립트 코드의 에러 등으로도 호출될 수 있다.

두 번째 단계에서 처음 일어나는 이벤트 중에는 DOMContentLoaded와 load 이벤트가 있다. DOMContentLoaded 이벤트는 HTML 문서의 로딩과 분석이 완전히 끝났을 때 일어난다. load 이벤트는 이미지 같은 문서의 외부 자원을 완전히 불러 왔을 때 일어난다. 자바스크립트 프로그램에서 이들 이벤트를 시작 신호로 사용 할 때가 많다. 스크립트에서 함수를 정의하고 load 이벤트가 발생했을 때 실행 되도록 이벤트 핸들러 함수로 등록하기만 하는 것입니다. 그리고 load 이벤트 핸 러에서 문서를 조작하고 기타 프로그램에서 의도한 작업을 수행한다. load 같은 이벤트 핸들러 에서 다른 이벤트 핸들러를 등록하는 경우도 많다.

자바스크립트 프로그램의 첫 번째 단계는 비교적 짧으며, 1초 안에 이루어지는 것이 이상적이다. 문서 로딩이 끝나면, 문서가 웹 브라우저에 표시되는 동안 이벤트 주도적인 두 번째 단계가 계속 이어진다.

**클라이언트 사이드 자바스크립트 스레드 모델**

자바스크립트는 싱글 스레드 언어이며, 싱글 스레드 실행 모델은 두 이벤트 핸들러 가 절대 동시에 실행되지 않으므로 프로그래밍이 훨씬 단순하다. 콘텐츠를 수정 할 때 다른 스레드가 같은 콘텐츠를 동시에 수정하게 될 일도 없고, 락(lock), 교착 상태(deadlock), 경합 조건(race condition)을 걱정할 필요도 없다.

싱글 스레드는 웹 브라우저가 스크립트와 이벤트 핸들러를 실행하는 동안 사용자 입력에 반응하지 않는다는 의미이다. 따라서 자바스크립트 프로그래머는 스크립트와 이벤트 핸들러가 너무 오래 실행되게 만들어서는 안 된다. 스크립트에서 과도한 계산을 수행하면 문서 로딩이 지연되고 사용자는 스크립트 실행이 완료 될 때까지 문서 콘텐츠를 볼 수 없다. 이벤트 핸들러에서 과도한 계산을 수행 하면 브라우저의 응답이 멈추고 사용자는 브라우저가 다운됐다고 생각할 수도 있다.

웹 플랫폼은 ‘웹 워커’를 통해 동시성을 구현한다. 웹 워커는 사용자 인터페이스를 멈추지 않으면서 실행되는 백그라운드 스레드이다. 웹 워커 스레드에서 실행되는 코드는 문서 콘텐츠에 접근할 수 없고, 메인 스레드나 다른 워커와는 상태를 공유하지 않으면서 오로지 비동기 메시지 이벤트를 통해서만 통신한다. 메인 스레드는 이런 동시성을 인지하지 못하므로 웹 워커는 자바스크립트 프로그램의 싱글 스레드 실행 모델을 망치지 않는다.

**클라이언트 사이드 자바스크립트 타임라인**

1. 웹 브라우저가 Document 객체를 생성하고 웹 페이지 분석을 시작한다. HTML 요소와 텍스트 콘텐츠를 분석할 때마다 Element 객체와 Text 노드를 문서 에 추가한다. 이 단계에서 document.readyState 프로퍼티의 값은 loading이다.
2. HTML 파서가 async, defer, type="module" 속성이 없는 <script> 태그를 만 면 스크립트 태그를 문서에 추가하고 스크립트를 실행한다. 스크립트는 동기적으로 실행되고 HTML 파서는 스크립트를 내려받아 실행하는 동안 일시 중지한다. 이런 스크립트는 document.write()를 사용해 입력 스트림에 텍스트를 삽입할 수 있으며 그 텍스트는 파서가 재개될 때 문서의 일부분이 된다. 이런 스크립트는 나중에 사용할 이벤트 핸들러를 등록하기만 하는 경우가 대부분이지만, 이 시점에는 자신이 존재하는 것처럼 문서 트리를 이동하고 조작 할 수 있다. 즉, async나 defer 속성이 없는 비모듈 스크립트는 자기 자신의 <script> 태그와 그 앞에 있는 문서 콘텐츠를 볼 수 있다.
3. 파서가 async 속성이 있는 <script> 요소를 만나면 스크립트 텍스트를 내려 받기 시작하며, 스크립트가 모듈이라면 가져오는 모듈 역시 재귀적으로 내려 받아 문서 분석을 계속한다. 스크립트는 내려받은 후 가능한 한 빨리 실행 되지만 파서는 내려받기가 끝나기를 기다리지 않는다. 비동기 스크립트는 document.write() 메서드를 사용해서는 안 된다. 비동기 스크립트는 자신의 <script> 태그와 그 앞에 있는 문서 콘텐츠를 볼 수 있고, 나머지 문서 콘텐츠 예는 접근할 수도 있고 접근하지 못할 수도 있다.
4. 문서 분석이 완전히 끝나면 document.readyState 프로퍼티가 interactive로 바뀐다.
5. defer 속성이 있는 스크립트, async 속성이 없는 모듈 스크립트는 문서 순서대로 실행된다. 비동기 스크립트도 이때 실행될 수 있다. 지연된 스크립트는 문서 전체에 접근할 수 있으며, document.write() 메서드를 사용해서는 안 된다.
6. 브라우저가 Document 객체에서 DOMContentLoaded 이벤트를 일으킵니다. 이 이벤트는 스크립트 단계를 두 번째 단계로 전환합니다. 이 시점에서 아직 실행 되지 않은 async 스크립트가 있을 수 있다.
7. 이 시점에서 문서 분석은 완전히 끝났지만 브라우저는 여전히 이미지 같은 콘텐츠를 기다리고 있을 수 있다. 콘텐츠 로딩이 끝나고 async 스크립트 로딩과 실행도 끝나면 document. readyState 프로퍼티는 complete로 바뀌고 웹 브라우저는 Window 객체에서 load 이벤트를 일으킨다.
8. 이제부터 사용자의 입력 이벤트, 네트워크 이벤트, 타이머 종료 등에 의해 이 벤트 핸들러가 비동기적으로 호출된다.

### 프로그램 입출력

다른 프로그램과 마찬가지로 클라이언트 사이드 자바스크립트 프로그램도 입력 데이터를 처리해 출력 데이터를 만든다.

- 자바스크립트 코드에서 DOM APK15.3절）를 통해 접근할 수 있는 문서 콘텐츠 자체
- 이벤트 형태인 사용자 입력. HTML <button> 요소를 마우스로 클릭하거나 터치 스크린을 탭하는 것, HTML <textarea> 요소에 텍스트 입력 등이 이에 해당한다.
- 문서 URL은 클라이언트 사이드 자바스크립트에서 document.URL로 접근할 수 있다. 이 문자열을 URL() 생성자에 전달하면 URL의 경로, 검색 , 프래그먼트 등에 쉽게 접근할 수 있습니다.
- HTTP ‘쿠키’ 요청 헤더 콘텐츠는 document.cookie로 사용할 수 있습니다. 쿠키는 보통 서버 사이드에서 사용자 세션을 관리할 때 사용하지만 클라이언트 사이드에서도 필요하다면 쿠키를 읽고 쓸 수 있다.
- 전역 navigator 프로퍼티를 통해 웹 브라우저, 운영 체제와 그 기능에 접근할 수 있습니다. 예를 들어 navigator.userAgent는 웹 브라우저를 식별하는 문자열이고 navigator.language는 사용자가 선호하는 언어이며 navigator.hardwareConcurrency는 웹 브라우저가 사용할 수 있는 논리적 CPU의 개수입니다. 마찬가지로 전역 screen 프로퍼티의 screen.width, screen.height 프로퍼티를 통해 사 자의 디스플레이 크기에 접근할 수 있다. 어떤 면에서는 웹 브라우저의 navigator, screen 객체를 노드 프로그램의 환경 변수라고 생각해도 된다.

클라이언트 사이드 자바스크립트는 DOM API 또는 리액트, 앵귤러 같은 프레임워크를 통해 HTML 문서를 조작한다. 클라이언트 사이드 코드는 console.log()나 관련 메서드를 통해 출력할 수도 있다. 하지만 콘솔을 통한 출력은 웹 개발자 콘솔에만 보이므로 디버깅에는 적합하지만 사용자에게 전달하기에는 적합 하지 않다.

### 프로그램 에러

자바스크립트 프로그램이 실행되는 동안 예외가 일어나고 그 예외를 처리할 catch 문이 없다면 개발자 콘솔에 에러 메시지가 표시되지만 등록된 이벤트 핸들러는 계속 실행되며 이벤트에 반응한다.

잡히지 않은 예외가 일어났을 때 최후의 수단으로 호출될 에러 핸들러가 필요하다면, Window 객체의 onerror 프로퍼티에 에러 핸들러 함수를 정의한다. 잡히지 않은 예외가 콜 스택을 따라 전달되고 개발자 콘솔에 에러 메시지가 표시된다.

프라미스가 거부되고 이를 처리할 .catch() 함수가 없다면 처리하지 않은 예외가 있는 것과 비슷하다. 프로그램에 예상치 못한 에러나 논리 에러가 있는 것이다. window.onunhandledrejection 함수를 정의하거나 window.addEventListener()를 써서 unhandledrejection 이벤트 핸들러를 등록해 이를 감지할 수 있다.

onerror와 onunhandledrejection 핸들러를 정의할 일은 많지 않지만 fetch() 함수 등을 사용해 사용자의 브라우저에서 일어난 예상하지 못한 에러를 서버에 보고 하는 메커 니즘을 준비할 때 꽤 유용하게 쓸 수 있다.

### 웹 보안 모델

웹 페이지에서 방문자 개인의 장치에 임의의 자바스크립트 코드를 실행할 수 있다는 것은 분명 보안에 영향을 준다. 브라우저 제조사들은 아래 두 가지 상반되는 목표 간의 균형을 맞추기 위해 노력해 왔다.

- 유용한 웹 애플리케이션을 사용할 수 있는 강력한 클라이언트 사이드 API를 정의하는 것
- 악의적인 코드에서 데이터를 읽기나 수정하지 못하게 하고, 개인 정보에 접근하지 못하게 방지하는 것

**자바스크립트에서 할 수 없는 일**

악의적인 코드에 대한 웹 브라우저의 첫 번째 방어선은 특정 기능을 지원하지 않는 것이다.

클라이언트 사이드 자바스크립트는 클라이언트 컴퓨터의 디렉터리를 읽을 수 없고 파일을 수정하거나 삭제할 수 없다. 따라서 자바스크립트 프로그램은 데이터를 삭제하거나 바이러스를 옮길 수 없다.

마찬가지로 클라이언트 사이드 자바스크립트에는 범용 네트워크 기능도 없다. 클라이언트 사이드 자바스크립트 프로그램은 HTTP 요청(15.11.1 절)을 보낼 수 있고, 특별한 서버와 통신하도록 소켓 비슷한 API를 정의한 웹소켓(15.11.3절)이라 는 표준도 있다. 하지만 어느 API도 방대한 네트워크에 제한 없이 접근하도록 허용하지는 않는다. 클라이언트 사이드 자바스크립트로 범용 인터넷 클라이언트와 서버를 만들 수는 없다.

**동일 출처 정책**

동일 출처 정책(same-origin policy)은 자바스크립트 코드에서 접근할 수 있는 웹 콘텐츠를 제어하는 보안 제한이다. 동일 출처 정책은 일반적으로 <iframe> 요소 를 통해 웹 페이지를 불러올 때 작용한다. 한 프레임에 있는 자바스크립트 코드와 다른 프레임의 콘텐츠 사이의 상호작용을 지배한다. 구체적으로 말해 스크립트는 자신을 포함한 문서와 같은 서버에서 가져온 창과 문서의 프로퍼티만 읽을 수 있다.

문서 출처는 그 문서를 불러온 URL의 프로토콜, 호스트, 포트로 정의됩니다.

다른 웹 서버에서 가져왔다면 출처가 다른 문서로 간주합니다.

호스트가 같더라도 다른 포트에서 가져온 문서는 출처가 다른 것으로 간주한다.

또한 서버가 같더라 도 http: 프로토콜로 가져온 문서는 https: 프로토콜로 가져온 문서와 출처가 다르 다고 간주한다.

브라우저는 일반적으로 file: URL을 별도의 출처로 취급하므로, 같은 서버 에서 하나 이상의 문서를 가져와 표시하는 프로그램을 만들고 있다면 로컬에서 file: URL로는 테스트할 수 없고 개발 과정에 정적 웹 서버를 사용해야 한다.

스크립트 자체의 출처는 동일 출처 정책과 관련이 없다. 문제가 되는 것은 스크립트를 포함한 문서의 출처이다.

동일 출처 정책은 스크립트를 사용한 HTTP 요청에도 적용된다. 자바스크립트 코드는 자신을 포함하는 문서를 가져온 웹 서버에 HTTP 요청을 제한 없이 보낼 수 있지만 다른 웹 서버와 통신할 수는 없다. (CORS로 허용된 웹 서버는 허용된다)

스크립트는 document.domain 을 도메인 접미사로 설정해, 이렇게 여러 개의 도메인을 사용하는 웹사이트를 지원할 수 있다. 즉 [https://orders.example.com에서](https://orders.example.xn--com-k94n91q/) 가져온 스크립트는 document.domain을 example.com으로 설정해 자신의 출처를 [https://example.com으로](https://example.xn--com-ky7m580d/) 바꿀 수 있다. 하지만 document.domain을 orders.example, [ample.com](http://ample.com/), com 등으로 바꿀 수는 없다.

동일 줄처 정책을 완화하는 두 번째 방법은 CORS(Cross-Origin Resource Sharing) (교차 출처 간 자원 공유)이다. CORS는 HTTP를 Origin: 요청 헤더와 Access-Control-Allow-Origin 응답 헤더로 확장한다. CORS를 써서 헤더에 파일을 요청할 수 있는 출처를 명시적으로 나열하거나 와일드카드를 써서 어떤 사이트에든 제한 없이 파일을 요청하게 할 수 있다. 브라우저는 CORS 헤더를 지원하며 이 헤더가 존재하지 않으면 동일 출처 제한을 완화하지 않는다.

**교차 사이트 스크립트**

교차 사이트 스크립트(Cross-site scripting)(XSS)는 공격자가 대상 웹사이트에 HTML 태그나 스크립트를 주입하는 보안 문제를 통틀어 가리키는 용어다. 클 라이언트 사이드 자바스크립트 프로그래머는 반드시 교차 사이트 스크립트를 염두에 두고 방어해야 한다.

```tsx
<script>
let name = new URL(document.URL).searchParams.get("name11);
document.queryselector('hl').innerHTML = "Hello " + name;
</script>

http://www.example.com/greet.html?name=%3Cimg%20src=%22x.png%22잉200nload=%22alert(%27hacked%27)%22/잉3E
```

교차 사이트 스크립트 공격이라는 이름은 하나 이상의 사이트가 연관됨을 의미한다. 사이트 B에 위 예제와 같이 조작된, 사이트 A를 가리키는 링크가 있다고 하자. 사이트 B에서 사용자가 그 링크를 클릭하도록 유도하면 사용자는 사이트 A로 이동하지만, 사이트 A는 이제 사이트 B의 코드를 실행한다. 그 코드가 사이트 A의 페이지를 훼손하거나 제대로 동작하지 않게 만들 수도 있다. 더 위험한 것은, 악의적인 코드가 사이트 A에 저장된 계좌 번호나 개인 식별 정보 같은 쿠키를 읽고 이를 사이트 B에 전송할 수 있다는 것이다. 주입된 코드로 사용자의 키 입력을 추적해 사이트 B에 전송할 수도 있다.

일반적으로 XSS 공격을 방지하는 방법은 신뢰할 수 없는 데이터로 문서 콘텐츠 를 동적으로 생성하기 전에 HTML 태그를 모두 제거하는 것이다. 예를 들어 다음과 같이 greet.html을 수정해 신뢰할 수 없는 입력 문자열의 HTML 특수 문자를 이와 동등한 HTML 엔티티로 교체하는 방법이다.

XSS 문제를 방지하는 또 다른 방법은 신뢰할 수 없는 콘텐츠는 항상 sandbox 속성 이 있는 <iframe>에 표시해서 스크립트나 기타 기능을 비활성화하는 것이다.

교차 사이트 스크립트는 웹의 구조에 깊이 뿌리박힌 유해한 취약점이다. 이 취약점을 자세히 이해하는 일은 그만한 가치가 있지만 더 깊이 설명하는 것은 이 책의 범위를 벗어난다. 교차 사이트 스크립트를 방어하는 방법을 다룬 온라인 자료는 많다.

## 이벤트

클라이언트 사이드 자바스크립트 프로그램은 비동기적인 이벤트 주도 프로그래밍 모델을 사용한다. 웹 브라우저는 문서, 브라우저, 요소, 객체에 뭔가 흥미로운 일 이 일어날 때마다 이벤트를 일으킨다.

자바스크립트 애플리케이션이 어떤 이벤트 타입에 관심이 있다면 그 타입의 이벤트가 일어날 때 호출되도록 하나 이상의 함수를 등록할 수 있다.

**이벤트 타입**

이벤트 종류를 지정하는 문자열 (mousemove, keydown, load)

이벤트 타입은 단순한 문자열이므로 이벤트 이름이라 부를 때도 있다.

**이벤트 대상**

이벤트가 일어난, 또는 이벤트와 연관된 객체이다. (Window, Document, Element)

**이벤트 핸들러 또는 이벤트 리스너**

이 함수는 이벤트를 처리하거나 이벤트에 반응한다. 애플리케이션은 이벤트 타입과 이벤트 대상을 지정해 웹 브라우저에 이벤트 핸들러 함수를 등록한다. 지정된 대상에서 지정된 타입의 이벤트가 일어나면 브라우저가 핸들러 함수를 호출한다. 객체에서 이벤트 핸들러가 호출되면 브라우저가 이벤트를 ‘일으켰 다’, ‘전달했다’라고 한다.

**이벤트 객체**

이벤트 객체는 특정 이벤트와 연관되어 있으며 해당 이벤트에 관한 세부 정보를 포함한다. 이벤트 객체는 이벤트 핸들러 함수에 인자로 전달된다.

**이벤트 전달**

브라우저는 이 프로세스를 통해 어떤 객체 에서 이벤트 핸들러를 호출할지 결정한다. Window 객체의 load 이벤트나 Worker 객체의 message 이벤트처럼 특 정 객체에 국한되는 이벤트는 전달(propagation)이 필요 없다. 반면 HTML 문서의 요소에서 일어나는 일부 이벤트는 문서 트리를 따라 전달된다.

일부 이벤트에는 연관된 기본 동작이 있다. 예를 들어 하이퍼링크에서 클릭 이벤트가 일어났을 때 기본 동작은 브라우저가 링크를 따라가서 새로운 페이지를 불 러오는 것이다. 이벤트 핸들러는 이벤트 객체의 메서드를 호출해 기본 동작을 방지할 수 있다.

### 이벤트 범주

**장치 의존적인 입력 이벤트**

이 이벤트는 마우스나 키보드 같은 특정 입력 장치에 직접적으로 묶여 있다.

mousedown, mousemove, mouseup, touchstart, touchmove, touchend, keydown, keyup

**장치 독립적인 입력 이벤트**

이런 입력 이벤트는 특정 입력 장치에 매여 있지 않다.

click, input, pointerdown, pointermove, pointerup

**사용자 인터페이스 이벤트**

UI 이벤트는 고수준 이벤트이며 웹 애플리케이션의 사용자 인터페이스로 동작 하는 HTML 폼 요소에서 자주 사용된다.

focus, change, submit

**상태 전환 이벤트**

일부 이벤트는 사용자의 활동이 아니라 네트워크와 브라우저 활동에 의해 일어나며 일종의 라이프 사이클이나 상태가 변경됐음을 알린다.

load, DOMContentLoaded, online, offline

**API 전용 이벤트**

HTML과 관련 명세에서 정의하는 다양한 웹 API도 자신만의 이벤트 타입을 갖는다.

<video>, <audio> → waiting, playing, seeking, volume change, 

IndexedDB API → success, error

### 이벤트 핸들러 등록

이벤트 핸들러를 등록하는 방법은 기본적으로 두 가지입니다.

웹 초기부터 사용되던 첫 번째 방법은 이벤트 대상인 요소나 객체에 프로퍼티를 설정하는 방법이다.

더 새롭고 일반적인 두 번째 방법은 객체나 요소의 addEventListener() 메서드에 핸들러를 전달하는 방법이다.

**이벤트 핸들러 프로퍼티 설정**

이벤트 핸들러를 등록하는 가장 단순한 방법은 이벤트 대상의 프로퍼티를 원하는 이벤트 핸들러 함수로 설정하는 방법이다. 관습적으로 이벤트 핸들러 프로퍼티 이름은 onclick, onchange, onload, onmouseover처럼 on 다음에 이벤트 이름을 붙인다. 이런 프로퍼티 이름은 대소문자를 구분하며 mousedown처럼 여러 단어로 구성 되어 있어도 전부 소문자로 쓴다.

<aside>
💡 리액트 프레임워크를 사용해 클라이언트 사이드 사용자 인터페이스를 만들어 본 경험만 있다면 생소하게 느껴질 수도 있다. 리액트는 클라이언트 사이드 이벤트 모델을 약간 바꾼 부분이 많은데 프로퍼티 이름을 onClick, onMouseOver처럼 카멜 케이스(camelCase)로 바꾼 것도 그 일환이다. 하지만 네이티브 웹 플랫폼에서는 이벤트 핸들러 프로퍼티를 모두 소문자로 쓴다.

</aside>

```tsx
// Window 객체의 onload 프로퍼티를 함수로 설정합니다.
// 이 함수가 이벤트 핸들러이며 문서를 불러올 때 호출됩니다.
window.onload = function () {
  // <form> 요소를 찾습니다.
  let form = document.querySelector('form#shipping');
  // 폼을 전송하기 전에 호출될 이벤트 핸들러 함수를 등록합니다.
  // isFomValidO는 다른 곳에서 정의했다고 가정합니다.
  form.onsubmit = function (event) {
    // 사용자가 폼을 전송할 때
    if (!isFormValid(this)) {
      // 폼 입력이 유효한지 체크합니다.
      event.preventDefault(); // 유효하지 않다면 폼 제출을 막습니다.
    }
  };
};
```

이벤트 핸들러 프로퍼티의 단점은 이벤트 대상이 이벤트 타입 하나당 최대 한 개의 핸들러만 받는다는 가정하에 설계됐다는 점이다. addEventListener()는 이전에 등록한 핸들러를 덮어 쓰지 않으므로 일반적으로 addEventListener()를 사용해 이 벤트 핸들러를 등록하는 게 더 좋다.

**이벤트 핸들러 속성 설정**

요소의 이벤트 핸들러 프로퍼티는 대응하는 HTML 태그의 속성으로 직접 정의할 수도 있다. 예를 들어 Window 요소에 등록할 핸들러를 HTML <body> 태그의 속성으로 정의할 수 있다. 이런 방식은 최신 웹 개발에서는 거의 사용하지 않지만 어쨌든 가능하긴 하며, 여전히 기존 코드에 남아 있는 경우도 있다.

이벤트 핸들러를 HTML 속성으로 정의할 때 속성 값은 자바스크립트 코드 문자열이어야 한다. 이 코드는 완료한 함수 선언이 아니라 이벤트 핸들러 함수의 바디여야 한다. 즉 HTML 이벤트 핸들러 코드를 중괄호로 둘러싸거나 앞에 func tion 키워드를 붙여서는 안 된다.

`<button onclick="console.log('Thank you');">Please Click</button>`

HTML 이벤트 핸들러 속성에 자바스크립트 문이 여러 개 포함됐다면 각 문을 세미콜론으로 구분하거나 속성 값을 여러 행으로 나눠 써야 한다.

자바스크립트 코드 문자열을 HTML 이벤트 핸들러 속성의 값으로 지정하면 브라우저는 함수 문자열을 다음과 같이 변환한다.

```tsx
function(event) {
	with(document) {
		with(this.form 11 {}) {
			with(this) { /* 코드 */ }
    } 
  }
}
```

event 인자는 핸들러 코드에서 현재 이벤트 객체를 event로 참조할 수 있다는 의미다. with 문은 핸들러 코드에서 대상 객체, 이를 포함하는 <form>, 포함하는 문서 객체를 마치 스코프에 존재하는 변수처럼 직접 참조할 수 있다는 뜻이다. 스트릭트 모드는 with 문을 금지하지만 HTML 속성의 자바스크립트 코드는 스트릭트 모드가 아니다. 이런 식으로 정의된 이벤트 핸들러는 예상하지 못 한 변수가 정의된 환경에서 실행된다. 이는 혼란스러운 버그를 유발할 수 있으며 HTML에 이벤트 핸들러를 작성하지 않는 이유이기도 하다.

**addEventListener()**

Window, Document, Element 객체는 모두 이벤트 대상이 될 수 있으며 이들의 addEventListener() 메서드를 통해 해당 객체에 이벤트 핸들러를 등록할 수 있다.

```tsx
<button id="mybutton">Click me</button>
<script>
let b = document.querySelector("#mybutton");
b.onclick = function() { console.log("Thanks for clicking me!"); };
b.addEventListener("click", () => { console.log("Thanks again!"); });
</script>
```

addEventListener()를 여러 번 호출해 같은 객체의 같은 이벤트 타입에 하나 이상의 핸들러 함수를 등록할 수 있다. 객체에서 이벤트가 일어나면 해당 타입의 이벤트에 등록된 핸들러가 등록 순서대로 호출된다. 같은 객체에서 같은 인자로 addEventListener()를 여러 번 호출해도 바뀌는 건 없다. 핸들러 함수는 한 번만 등록되며 핸들러 호출 순서도 바뀌지 않는다.

removeEventListener() 메서드는 addEventListener()의 반대이다. 같은 인자를(선택 사항으로는 세 번째 인자도) 받지만 이벤트 핸들러 함수를 추가하는게 아니라 제거한다.

addEventListener()가 선택 사항으로 받는 세 번째 인자는 불 값 또는 객체다. true를 전달하면 핸들러 함수는 캡처링 이벤트 핸들러로 등록되며 이벤트 전달의 다른 단계에서 호출된다. 이벤트 리스너를 등록할 때 세 번째 인자로 true를 전달했으면 핸들러를 제거할 때도 반드시 removeEventListener()에 세 번째 인자로 true를 전달해야 한다.

캡처링 이벤트 핸들러를 등록하는 건 addEventListener()가 지원하는 세 가지 옵 션 중 하나일 뿐이다. 다음과 같이 불 값 대신 객체를 전달해 원하는 옵션을 명시적으로 지정할 수 있다.

```tsx
document.addEventListener("click”, handleClick, {
	capture: true,
	once: true,
	passive: true
});
```

옵션 객체의 capture 프로퍼티가 true이면 이벤트 핸들러는 캡처링 핸들러로 등록된다. 이 프로퍼티가 false이거나 생략됐다면 핸들러는 캡처링을 사용하지 않는다.

옵션 객체의 once 프로퍼티가 true이면 이벤트 리스너는 한 번 호출된 뒤 자동으로 제거된다. 이 프로퍼티가 false이거나 생략됐다면 핸들러는 절대 자동으로 제거되지 않는다.

옵션 객체의 passive 프로퍼티가 true이면 이벤트 핸들러는 절대 preventDefault()를 호출해서 기본 동작을 취소하지 않는다. 이 옵션은 모바일 장치의 터치 이벤트에서 특히 중요합니다. 만약 touchmove 이벤트의 이벤트 핸들러가 브라우저의 기본 스크롤을 방해한다면 브라우저는 부드러운 스크롤 동작 을 구현할 수 없다. passive 프로퍼티는 이런 식으로 방해가 될 가능성이 있는 이벤트 핸들러를 등록할 때, 웹 브라우저에 이벤트 핸들러가 실행되는 동안 스크롤 같은 기본 동작을 수행해도 안전하다고 알려 주는 역할을 한다. 부드러운 스 크롤은 사용자 경험에 매우 중요하며 파이어폭스와 크롬은 touchmove, mousewheel 이벤트에 이 프로퍼티를 기본적으로 적용한다. 따라서 이런 이벤트에서 preventDefault()를 실제로 호출하려 한다면 passive 프로퍼티를 명시적으로 false로 설정해야 한다.

removeEventListener()에도 옵션 객체를 전달할 수 있긴 하지만 의미 있는 프로퍼티는 capture 프로퍼티 하나뿐이다. 이벤트 리스너를 제거할 때 once나 passive는 아무 의미 없으며 무시된다.

### 이벤트 핸들러 호출

이벤트 핸들러를 등록하면 웹 브라우저는 지정된 객체에 지정된 타입의 이벤트가 일어날 때마다 자동으로 이벤트 핸들러를 호출한다.

**이벤트 핸들러 인자**

이벤트 핸들러는 인자로 이벤트 객체 하나만 받는다. 이벤트 객체의 프로퍼티는 다음과 같이 이벤트에 관한 세부 사항을 제공한다.

type

일어난 이벤트 타입

target

이벤트가 일어난 객체

currentTarget

전달되는 이벤트라면 현재 이벤트 핸들러가 등록된 객체

timestamp

타임스탬프는 이벤트가 일어난 시간을 밀리초 단위로 나타내지만 절대적인 시간은 아니다. 두 번째 이벤트의 타임스탬프에서 첫 번째 이벤트의 타임스탬프를 빼는 방식으로 두 이벤트 사이에 경과한 시간을 알 수 있다.

isTrusted

웹 브라우저 자체에서 전달한 이벤트는 true, 자바스크립트 코드가 전달한 이벤트는 false다.

일부 이벤트에는 이외에도 다른 프로퍼티가 있다. 예를 들어 마우스와 포인터 이벤트의 clientX, clientY 프로퍼티는 이벤트가 일어난 좌표다.

**이벤트 핸들러 컨텍스트**

프로퍼티를 설정해 이벤트 핸들러를 등록하는 것은 마치 대상 객체에 새로운 메서드를 정의하는 것처럼 보인다.

`target.onclick = function() { /* 핸들러 코드 */ };`

따라서 이벤트 핸들러가 자신이 정의된 객체의 메서드처럼 호출되는 것도 놀라운 일이 아니다. 즉, 이벤트 핸들러의 바디 안에서 this 키워드는 이벤트 핸들러가 등록된 객체를 가리킨다.
핸들러는 대상을 this 값으로 해서 호출하며 , addEventListener()를 사용해 등록 한 핸들러도 마찬가지다. 하지만 화살표 함수로 정의된 핸들러는 그렇지 않다. 화살표 함수는 항상 자신이 정의된 스코프를 this 값으로 가진다.

**핸들러 반환 값**

최신 자바스크립트에서 이벤트 핸들러는 아무것도 반환해선 안 된다. 오래된 코드에는 이벤트 핸들러에 반환 값이 있고, 그 반환 값은 일반적으로 브라우저에 이벤트와 연관된 기본 동작을 수행하지 말라는 신호 구실을 한다.

예를 들어 폼의 전송 버튼에 있는 onclick 핸들러가 false를 반환한다면 (보통 이벤트 핸들러가 사용자 입력이 클라이언트 사이드 유효성 검사를 만족하지 못한다고 판단했을 때) 웹 브라우저는 폼을 전송하지 않는다.

브라우저의 기본 동작을 막는 표준 방법은 이벤트 객체에서 preventDefault() 메서드를 호출하는 것이다.

**호출 순서**

이벤트 대상의 이벤트 타입 하나에 이벤트 핸들러를 하나 이상 등록할 수 있다. 등록된 타입의 이벤트가 일어나면 브라우저는 핸들러를 등록된 순서대로 호출 한다. addEventListener()로 등록된 이벤트 핸들러와 객체 프로퍼티로 등록된 이벤트 핸들러가 섞여 있어도 마찬가지로 순서를 지킨다.

### 이벤트 전달

이벤트 대상이 Window 객체, 또는 기타 독립된 객체라면 브라우저는 이벤트에 반응해 그 객체에 적절한 핸들러를 호출하기만 한다. 반면 이벤트 대상이 Document 객체, 또는 그에 포함된 Element 객체라면 상황이 좀 복잡해진다.

대부분의 이벤트는 대상 요소에서 이벤트 핸들러를 호출한 뒤에도 DOM 트리를 따라 ‘버블링’하며 올라간다 . Document 객체를 지나 Window 객체까지 거슬러 올라간다. 이벤트 버블링은 개별 문서 요소 여러 개에 일일이 핸들러를 등록하는 일을 피하기 위해 만들어진 메커니즘이다.

대부분의 요소 이벤트는 버블링을 통해 거슬러 올라간다. focus, blur, scroll 이벤트는 예외다 load 이벤트는 버블링이 일어나지만 Document 객체에서 멈추며 Window 객체까지 전달되지는 않는다. (Window 객체의 load 이벤트 핸들 러는 문서 전체의 로딩이 끝났을 때만 호출된다.)

이벤트 버블링은 이벤트 전달의 세 번째 단계

대상 객제 자제에서 이벤트 핸들러를 호출하는 게 두 번째 단계

대상 핸들러를 호출하기 전에 일어 나는 첫 번째 단계를 ‘캡처링’ 단계라 부른다.

addEventListener()는 선택 사항인 세 번째 인자를 받는다고 했다. 그 인자가 true이거나 capture 프로퍼티가 true인 객체이면 이벤트 핸들러는 이벤트 전달의 첫 번째 단계 동안 캡처링 이벤트 핸들러로 등록된다. 이벤트 전달의 캡처링 단계는 버블링 단계를 거꾸로 한 것과 비슷하다. Window 객체의 캡처링 핸들러가 처음 호출되고, 다음은 Document 객체의 캡처링 핸들러, 다음은 body 요소의 캡처링 핸들러, 이런 식으로 DOM 트리 를 따라 내려오면서 이벤트 대상의 부모에서 캡처링 이벤트 핸들러를 호출할 때까지 계속한다. 이벤트 대상 자체에 등록된 캡처링 이벤트 핸들러는 호출되지 않는다.

이벤트 캡처링을 사용하면 대상에 도달하기 전에 이벤트를 먼저 살펴볼 기회가 있다. 캡처링 이벤트 핸들러는 디버깅에 사용하기도 하고 다음 절에서 설명할 이벤트 취소와 함께 대상 이벤트 핸들러가 실제로 호출되지 않게 이벤트를 거르는 용도로 사용하기도 한다. 이벤트 캡처링은 마우스 드래그 처리에 흔히 사용된다. 마우스 움직임에 관련된 이벤트는 드래그 대상인 문서 요소가 아니라 드래그되 는 객체에서 처리해야 한다.

### 이벤트 취소

이벤트 핸들러를 등록하면 이벤트 객체에서 preventDefault() 메서드를 호출해 브라우저의 기본 행동 을 막을 수 있다. (핸들러 등록 시 passive 옵션을 사용하면 preventDefault()는 무력화됩니다.)

이벤트 객체의 stopPropagation() 메서드를 호출해 이벤트의 전달을 취소할 수도 있다.

stopPropagation() 호출된 뒤 다른 객체의 이벤트 핸들러는 호출되지 않는다. stopPropagation()은 캡처링 단계에서, 이벤트 대상 자체에서, 버블링 단계에서 동작한다. stopImmediatePropagation()은 stopPropagatiorn()과 마찬가 지로 동작하지만 같은 객체에 후순위로 등록된 나머지 이벤트 핸들러의 호출도 방지한다.

### 커스텀 이벤트 전달

클라이언트 사이드 자바스크립트의 이벤트 API는 비교적 강력하며 이를 통해 직접 이벤트를 정의하고 전달할 수 있다.

자바스크립트 객체에 addEventListener() 메서드가 있다면 그 객체는 ‘이벤트 대상’이므로 dispatchEvent() 메서드 또한 가지고 있다. CustomEvent() 생성자로 이벤트 객체를 생성하고 dispatchEvent()에 전달할 수 있다.

CustomEvent()의 첫 번째 인자는 이벤트 타입을 나타내는 문자열이고 두 번째 인자는 이벤트 객체의 프로퍼티를 지정하는 객체입니다. 이 객체의 detail 프로퍼티에 문자열, 객체, 기타 이벤트 콘텐츠를 나타내는 값을 사용한다. 이벤트가 문서 트리를 버블링해 올라가길 원한다면 두 번째 인자에 bubbles:true를 추가한다.

```tsx
// 작업 중임을 UI에 알리는 커스텀 이벤트를 전달합니다.
document.dispatchEvent(new CustomEvent("busy", { detail: true }));

// 네트워크 동작
fetch(url)
	.then(handleNetworkResponse)
	.catch(handleNetworkError)
	.finally(() => {
		// 네트워크 요청이 성공하거나 실패하면 작업이 끝났으므로
		// 이제 바쁘지 않음을 알리는 또 다른 이벤트를 UI에 전달합니다.
		document.dispatchEvent(new CustomEvent("busy", { detail: false }));
	})；

// 프로그램의 다른 곳에서 busy 이벤트를 받아
// 모래시계를 표시하거나 숨겨서 사용자에게 알립니다.
document.addEventListener("busy", (e) => {
	if (e.detail) {
		showSpinner();
	} else 
		hideSpinner();
	}
});
```

## 문서 스크립트

클라이언트 사이드 자바스크립트의 목적은 정적인 HTML 문서를 대화형 웹 애플리 케이션으로 바꾸는 것이다. 따라서 웹 페이지의 콘텐츠를 변경하는 것이야말로 자바스크립트의 원래 목적이다.
Window 객체에는 항상 Document 객체를 참조하는 document 프로퍼티가 있다. 브라우저 창의 콘텐츠를 나타내는 Document 객체가 이 절의 주제다. 하지만 Document 객체는 단독으로 존재하지 않는다. Document 객체는 문서 콘텐츠를 표현하고 조작하는 DOM의 중심이다.

### 문서 요소 선택

전역 document 프로퍼티는 Document 객체를 참조하며 Document 객체에는 각각 <head>, <body> 태그에 대응하는 Element 객체를 참조하는 head, body 프로퍼티가 있다. 프로그램에서 문서의 더 깊은 곳에 존재하는 요소를 조작하기 위해서는 반드시 어떤 식으로든 그 요소를 참조하는 Element 객체를 선택해야 한다.

**css 선택자로 요소 선택**

DOM 메서드 querySelector(), querySelectorAll()은 지정된 CSS 선택자에 일치하는 요소를 찾는다.

```tsx
div // <div> 요소
#nav // id가 nav인 요소
.warning // 클래스 속성에 warning이 있는 요소
p[lang="fr"] // 프랑스어로 작성된 문단: <p lang="fr">
*[name="x"] // name 속성이 x인 요소 전체
span-fatal.error // 클래스에 fatal과 error가 있는 span 요소
span[lang="fr"].warning // warning 클래스가 있는 프랑스어 span 요소
#log span // id가 log인 요소의 자손인 span 요소
#log>span // id가 log인 요소의 자식인 span 요소
body>hl:first-child // body의 자식인 hl 중 첫 번째
img + p.caption // 이미지 바로 다음에 있고 클래스가 caption인 문단
h2 ~ p // h2 다음에 있는 형제인 문단
button, input[type="button"] // 버튼 전체, type이 button인 input 요소 전체

// id가 spinner인 요소를 찾습니다.
let spinner = document.queryselector("#spinner");

// hl, h2, h3 태그가 붙은 Element 객체를 모두 찾습니다.
let titles = document.querySelectorAH("hl, h2, h3");
```

querySelectorAll()의 반환 값은 Element 객체 배열이 아니라 배열 비슷한 객체인 노드리스트(NodeList)이다. 노드리스트 객체에는 length 프로퍼티가 있고 배열과 마찬가지로 인덱스할 수 있으므로 전통적인 for 루프로 순회할 수 있다. 노드리스트는 이터러블이기도 하므로 for/of 루프에서도 사용할 수 있다. 노드 리스트를 배열로 변환하려면 Array.from()에 전달하기만 하면 된다.

지정된 선택자에 일치하는 것이 없으면 querySelectorAll()이 반환하는 노드리스트의 length 프로퍼티 값은 0이다.

querySelector(), querySelectorAll()은 Document 클래스뿐만 아니라 Element 클래스에서도 지원한다. 이들 메서드를 요소에서 호출하면 해당 요소의 자손 중에서 일치하는 요소만 반환한다.

CSS에는 ::first-line, ::first-letter 가상 요소가 있다. 이들은 실제 요소가 아니라 Text 노드에 일치한다. querySelectorAll(), querySelector()에는 가상 요소를 사용할 수 없다. 또한 대부분의 브라우저가 :link, :visited 가상 클래스에 일치하는 것은 반환하지 않는다. 이들은 사용자의 브라우징 히스토리 정보를노출하기 때문이다.

closest() 역시 CSS에 기반한 요소 선택 메서드다. 이 메서드는 Element 클래스의 메서드이며 인자로 선택자를 받는다. 선택자가 요소 자체와 일치하면 해당 요소를 반환한다. 그렇지 않다면 선택자와 일치하는 가장 가까운 조상 요소를 반환하고, 조상 요소 중에 일치하는 것이 없으면 null을 반환한다.

어떤 면에선 closest()는 querySelector()의 반대이다. closest()는 요소에서 시작하고 트리를 올라가면서 일치하는 것을 찾는다. 반대로 querySelector()는 요소에서 시작해 트리를 내려가면서 일치하는 것을 찾는다. 문서 트리 상위에서 이벤트 핸들러를 등록했을 때 closest()를 유용하게 쓸 수 있다. 예를 들어 click 이벤트를 처리할 때 이벤트 대상이 하이퍼링크인지 확인하고 싶을 수 있다. 이벤트 객체는 대상이 무엇인지 알려 주지만, 대상이 하이퍼링크의 <a> 태그 자체가 아니라 그 안에 포함된 링크 텍스트일 수도 있다. 다음과 같이 이벤트 핸들러를 사용해 가장 가까운 하이퍼링크를 찾을 수 있다.

```tsx
// 가장 가까운, href 속성이 있는 a 태그를 찾습니다.
let hyperlink = event.target.closest("a[href]");

// 요소 e가 리스트 요소 안에 있다면 true를 반환합니다.
function insideList(e) {
	return e.closest("ul,ol,dl") !== null;
}

// e가 제목 요소이면 true를 반환합니다.
function isHeading(e) {
	return e.matches("hl,h2,h3,h4,h5,h6");
}
```

**다른 요소 선택 메서드**

DOM에는 querySelector(), querySelectorAll() 외에도 여러 가지 요소 선택 메서드가 있지만 이들은 이제 자주 쓰이지 않는다. 물론 이 메서드 중 일부는 여전히 웹에 존재하고, 특히 getElementByld()는 자주 보일 것이다.

```tsx
// id로 요소를 찾습니다. 인자는 id이며 CSS 선택자 전치사인 #은 쓰지 않습니다.
// document.querySelector("#sect1")와 비슷합니다.
let sectl = document.getElementByld("sectl");

// name 속성이 color인 요소를 모두 찾습니다.
// document.querySelectorAll('*[name="color"]');과 비슷합니다.
let colors = document.getElementsByNameCcolor");

// hl 요소를 모두 찾습니다. document.querySelectorAll("hl")과 비슷합니다.
let headings = document.getElementsByTagName("hl");

// getElementsByTagName()은 Element 객체에도 존재합니다.
// sectl 요소 안에 있는 h2 요소를 모두 찾습니다.
let subheads = sect1.getElementsByTagName("h2");

// 클래스가 tooltip인 요소를 모두 찾습니다.
// document.querySelectorAll(".tooltip")과 비슷합니다.
let tooltips = document.getElementsByClassName("tooltip");

// sectl의 자손 중 클래스가 sidebar인 요소를 모두 찾습니다.
// sectl.querySelectorAll(".sidebar")과 비슷합니다.
let sidebars = sect1.getElementsByClassName("sidebar");
```

querySelectorAll()과 마찬가지로 위 예제의 메서드는 모두 노드리스트를 반환하며, getElementByld()만 예외로 Element 객체 하나를 반환한다. 하지만 querySelectorAll()과 달리 이 오래된 선택 메서드들은 ‘살아 있는’ 노드리스트를 반환한다. 즉, 문서 콘텐츠나 구조가 변하면 이들이 반환하는 노드리스트의 콘텐츠나 길이도 그에 따라 바뀐다.

**미리 선택된 요소**

역사적인 이유로 Document 클래스에는 특정 노드에 접근하는 단축 프로퍼티가 있다. 예를 들어 images, forms, links 프로퍼티로 문서에 존재하는 <img>, <form>, <a> 요소에 쉽게 접근할 수 있다. 단, <a> 태그에 href 속성이 있어야 한다. 이 프로퍼티들은 노드리스트 객체와 아주 비슷한 HTMLCollection 객체를 참조하는데, HTMLCollection 객체는 요소 ID나 이름으로도 인덱스된다는 점이 다르다. 예를 들어 document.forms 프로퍼티를 쓰면 <form id=Uaddressn> 태그에 다음과 같이 접근할 수 있다.

`document.forms.address;`

더 오래된 API 중에는 document.all 프로퍼티도 있습니다. 이 프로퍼티는 HTML Collection과 마찬가지로 문서의 요소를 모두 찾습니다. 하지만 document.all은 폐 기 됐으므로 사용하지 말아야 한다.

### 문서 구조와 순회

문서에서 요소를 선택한 뒤 그 요소와의 관계를 통해 부모, 형제, 자식 요소를 찾아야 할 때도 있다. 순회(traversal) API는 문서를 Element 객체의 트리로 취급하며 Text 노드는 무시한다. 순회 API에는 메서드가 없다. 이 API는 주어진 요소의 부모, 자식, 형제를 참조하는 Element 객체의 프로퍼티일 뿐이다.

parentNode
요소의 부모를 참조한다. 부모 역시 또 다른 Element 객체이거나 Document 객체다.

children
이 노드리스트는 요소의 자식 인 요소를 포함하지만, 요소가 아닌 자식 인 Text 노드와 Comment 노드는 제외한다.

childElementCount
자식 요소 개수이다. children.length와 같은 값을 반환한다.

firstElementChild, lastElementChild
요소의 자식 중 첫 번째와 마지막을 각각 참조한다. 자식인 요소가 없다면 null 이다.

nextElementSibling, previousElementSibling
요소의 바로 앞이나 바로 다음에 있는 형제 요소를 참조하며 그런 형제가 없다면 null이다.

document.children[0].children[1]
document.firstElementChild.firstElementChild.nextElementSibling
(표준 HTML 문서 에서 두 표현식은 모두 <body> 요소를 참조한다.)

```tsx
// 문서나 요소 e를 재귀적으로 이동하며 e와 그 자손에서 함수 f를 호출합니다.
function traverse(e, f) {
	f(e); // e에서 f()를 호출합니다.
	for(let child of e.children) { // 자식을 순회하면서
		traverse(child, f); // 재귀 호출합니다.
	}
}

function traverse2(ef f) {
	f(e); // e에서 f()를 호출합니다.
	let child = e.firstElementChild; // 연결 리스트 스타일로 자식을 순회합니다.
	while(child !== null) {
		traverse2(child, f); // 재귀 호출합니다.
		child = child.nextElementsibling;
	}
}
```

**노드 트리인 문서**

Text 노드를 포함하여 문서 전체나 일부를 순회할 때는 Node 객체의 다른 프로퍼티를 사용한다. 이 프로퍼티에는 Element 노드, Text 노드, Comment 노드도 포함된다.
모든 Node 객체 에는 다음 프로퍼티가 있다.

parentNode
현재 노드의 부모. Document 객체처럼 부모가 없는 경우에는 null입니다.

childNodes
현재 노드의 자식 전체(자식 요소뿐만이 아닙니다)를 포함하는 읽기 전용 노드 리스트

firstChild, lastChild
현재 노드의 첫 번째와 마지막 자식 노드. 현재 노드에 자식이 없으면 null입니다.

nextSibling, previousSibling
현재 노드의 다음, 이전 형제 노드. 이 프로퍼티는 노드를 이중으로 연결된 리스트로 연결합니다.

nodeType
노드의 종류를 나타내는 숫자이다. Document 노드는 9, Element 노드는 1, Text 노드는 3, Comment 노드는 8이다.

nodeValue
Text나 Comment 노드의 텍스트 콘텐츠이다.

nodeName
요소의 HTML 태그 이름을 대문자로 변환한 문자열이다.

문서의 첫 번째 자식의 두 번째 자식 노드를 선택하는 표현식은 다음과 같이 만듭니다.

document.childNodes[0].childNodes[1]
document.firstChild.firstChild.nextSibling

```tsx
<html>
<head>
	<title>Test</title>
</head>
	<body>hello World!</body>
</html>
```

```tsx
// 요소 e의 일반 텍스트 콘텐츠를 반환하고 자식 요소로 재귀합니다.
// 이 메서드는 textcontent 프로퍼티와 비슷하게 동작합니다.
function textcontent(e) {
	let s = HH; // 텍스트를 여기 합칩니다.
	for(let child = e.firstChild; child !== null; child = child.nextSibling) {
		let type = child.nodeType;
		if (type === 3) { // Text 노드
			s += child.nodeValue; // 텍스트 콘텐츠를 문자열에 합칩니다.
		} else if (type === 1) { // Element 노드
			s += textContent(child); // 재귀 호출
		}
	}
	return s; 
}
```

### 속성

HTML 요소는 태그 이름, 속성이라 불리는 이름-값 쌍 세트로 구성된다. 예를 들어 하이퍼링크를 정의하는 <a> 요소의 href 속성 값은 링크의 대상이다.

Element 클래스에는 속성을 검색, 설정, 확인, 제거하는 getAttribute(), setAttribute(), hasAttribute(), removeAttribute() 메서드가 있다. 하지만 표준 HTML 요소의 표준 속성은 모두 그 요소를 나타내는 HTMLElement 객체의 프로퍼티로 존재하며 getAttribute()나 비슷한 메서드를 호출하는 것보다는 그냥 자바스크립트 프로퍼티를 사용하는 게 훨씬 쉽다.

**요소 프로퍼티인 HTML 속성**

```tsx
let image = document.querySelector("#main_image");
let url = image.src; // src 속성은 이미지의 URL입니다.
image.id === "main_image" // => true; 이미지를 id로 검색했습니다.

let f = document.querySelector("form"); // 문서의 첫 번째 폼
f.action = "https://www.example.com/submit"; // 제출할 URL을 정합니다.
f.method = "POST"; // HTTP 요청 타입을 설정합니다.
```

<input> 요소 같은 일부 요소에서는 HTML 속성 이름이 다른 이름의 프로퍼티와 연결되기도 한다. 예를 들어 <input>의 HTML value 속성은 자바스크립트 default Value 프로퍼티에 반영된다. <input> 요소의 자바스크립트 value 프로퍼티는 사용자가 현재 입력한 내용이지만, value 프로퍼티를 바꿔도 defaultvalue 프로퍼티나 value 속성은 영향받지 않다.

HTML 속성은 대소문자를 구분하지 않지만 자바스크립트 프로퍼티 이름은 대소문자를 구분한다. 속성 이름을 자바스크립트 프로퍼티로 변환할 때는 소문자를 쓴다. 속성 이름이 둘 이상의 단어로 이루어졌다면 두 번째 이후의 단어 첫 글 자를 대문자로 바꿔서 defaultChecked, tabindex처럼 표기한다. 하지만 onclick 같은 이벤트 핸들러 프로퍼티는 예외이며 모두 소문자로 작성한다.

일부 HTML 속성 이름 중에는 자바스크립트 예약어와 같은 이름도 있다. 이런 경우 일반적인 규칙은 프로퍼티 이름 앞에 전치사 html을 붙이는 것이다. 예를 들어 <label> 요소의 HTML for 속성은 자바스크립트 htmlFor 프로퍼티로 바뀐다. HTML class 속성은 이 규칙의 예외이며 자바스크립트 코드에서는 className 으로 바뀐다

HTML 속성을 나타내는 프로퍼티의 값은 보통 문자열이다. <input> 요소의 defaultChecked, maxLength 속성처럼 불이나 숫자 값을 사용하는 경우에는 프로퍼티도 불 또는 숫자이다. 이벤트 핸들러 속성의 값은 항상 함수 또는 null이다.

하지만 프로퍼티 기반 API에는 요소에서 속성을 제거할 수 있는 방법이 없다. delete 연산자는 이런 목적으로 사용할 수 없다. 속성을 제거하려면 remove Attribute() 메서드를 사용한다.

```tsx
<input id="test" value="test">
<script>
let input = document.getElementById('test')
console.log(input.value) // test
console.log(input.defaultValue) // test
input.value = 'text'
console.log(input.value) // text. 하지만 요소의 value 속성은 여전히 test입니다.
console.log(input.defaultvalue) // test
input.defaultvalue = 'text'
console.log(input.value) // text. 요소의 value 속성도 text로 바뀝니다.
console.log(input.defaultValue) // text
```

**class 속성**

HTML 요소의 class 속성은 특히 중요한 속성이다. 이 속성의 값은 요소에 적용되는 CSS 클래스를 공백으로 구분한 리스트이며 요소의 스타일을 결정한다. class는 자바스크립트 예약어이므로 이 속성은 Element 객체의 className 프로퍼티에 대응한다. className 프로퍼티를 통해 요소의 class 속성을 문자열 형태로 읽고 쓸 수 있다. 하지만 class 속성이라는 이름은 적합하지 않다. 이 값은 단일 CSS 클래스가 아니라 클래스 리스트이며, 클라이언트 사이드 자바스크립트 프로그래밍에서는 리스트를 문자열로 취급하지 않고 개별 클래스 이름을 추가하거나 제거할 때가 많다.

이 문제를 해결하기 위해 Element 객체에는 class 속성을 리스트로 취급하는 classList 프로퍼티가 있다. classList 프로퍼티의 값은 이터러블인 배열 비슷한 객체이다. 프로퍼티 이름이 classList이긴 하지만 이 프로퍼티는 클래스 세트에 더 가깝게 동작하며 , add(), remove(), contains(), toggle() 메서드가 있다.

```tsx
// 모래시계를 써서 사용자에게 현재 작업 중임을 알립니다.
// 이를 위해 hidden 클래스를 제거하고 animated 클래스를 추가합니다.
let spinner = document.querySelector("#spinner");
spinner.classList.remove("hidden");
spinner.classList.add("animated");
```

**데이터셋 속성**

```tsx
<h2 id="title" data-section-number="16.1">Attributes</h2>.
let number = document.querySelector("#title").dataset.sectionNumber;
```

## 요소 콘텐츠

**HTML인 요소 콘텐츠**

웹 브라우저는 HTML 분석에 최적화되어 있으며 innerHTML 설정은 보통 아주 효율적이다. 하지만 += 연산자로 innerHTML 프로퍼티 에 텍스트를 추가하면 요소 콘텐츠를 문자열로 변환하는 직렬화 단계 , 새로운 문자열을 요소 콘텐츠로 변환하는 분석 단계를 모두 거쳐야 하므로 효율적이지 않다.

**일반 텍스트인 요소 콘텐츠**