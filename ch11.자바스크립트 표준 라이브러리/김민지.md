# 11장 자바스크립트 표준 라이브러리

## 11.1 세트와 맵

### 11.1.1 Set 클래스

|                Set                |                Array                 |
| :-------------------------------: | :----------------------------------: |
|       중복을 허용하지 않음        |            중복을 허용함             |
| 고유한 데이터 값을 유지할 수 있음 |     필요한 요소에 접근할 수 있음     |
|       `Set.prototype.add()`       | `Array.prototype.push()` `unshift()` |

**Set**

- `Set()` 생성자의 인자로 이터러블 객체 모두 허용한다.
- 타입이 다른 값도 추가할 수 있다.
- 새로운 값을 추가하거나 변경하면 값 비교가 이루어진다.
- `===` 연산자처럼 엄격하게 일치 여부를 판단한다.
- 요소의 삽입 순서대로 순회할 수 있다.

### 11.1.2 Map 클래스

|              Map               |                     Object                     |
| :----------------------------: | :--------------------------------------------: |
| `key`값으로 모든 타입이 가능함 | `key`값으로 `string` or `Symbol` 타입만 가능함 |
|           `map.size`           |           `Object.keys(obj).length`            |
| 직렬화와 파싱을 지원하지 않음  |          `JSON.stringify()` `parse()`          |

**Map**

- `Map()` 생성자의 인자로 `[key, value]` 이터러블 객체만 허용한다.
- 요소의 삽입 순서대로 순회할 수 있다.

### 11.1.3 WeakMap과 WeakSet

**WeakMap**

`WeakMap` 클래스는 키 값이 가비지 컬렉션에 포함되지 않게 막아 주지 않는다.

- 일반적인 맵은 키 값을 '강하게' 참조하며 키 값에 대한 다른 참조가 더 이상 남아 있지 않더라도 참조 관계를 유지한다. 반면 `WeakMap`은 키 값을 '약하게' 참조하므로 `WeakMap`을 통해 해당 키 값을 참조할 수 없고, 키 값이 `WeakMap`에 존재하더라도 메모리를 회수할 수 있다.
- 키는 반드시 객체 또는 배열이어야 한다. 기본 값은 가비지 컬렉션 대상이 되지 않으며 키로 사용할 수 없다.
- `get()`, `set()`, `has()`, `delete()` 메서드만 있다. 특히 이터러블이 아니며 `keys()`, `values()`, `forEach()` 메서드가 없다. 이터러블이면 키에 접근할 수 있게 되므로 약한 참조가 성립할 수 없다.
- `size` 프로퍼티가 없다. 크기는 가비지 컬렉션이 일어날 때마다 언제든 바뀔 수 있기 때문이다.
- 설계 의도는 메모리 누수를 방지하면서 객체와 값을 연결할 수 있게 하는 것이다.

**WeakSet**

`WeakSet`은 객체가 가비지 컬렉션에 포함되도록 허용하는 객체 세트이다.

- `WeakSet()` 생성자도 `Set()` 생성자와 비슷하게 동작하지만 `WeakMap` 객체가 `Map` 객체와 다르듯 `WeakSet` 객체는 `Set` 객체와 다르다.
- 기본 값을 요소로 허용하지 않는다.
- `add()`, `has()`, `delete()` 메서드만 가지며 이터러블이 아니다.
- `size` 프로퍼티가 없다.

<br />

## 11.2 형식화 배열과 이진 데이터

**형식화 배열**

ES6에 도입한 형식화 배열은 C나 자바의 저수준 배열과 비슷하다.

- 엄밀히 말해 배열은 아니며 `Array.isArray()`도 `false`를 반환한다.
- 요소는 모두 숫자이다. 하지만 일반적인 JS 숫자와 달리 형식화 배열은 저장하는 숫자의 타입과 크기를 지정할 수 있다.
- 생성할 때 반드시 길이를 지정해야 하며 이 길이는 절대 바꿀 수 없다.
- 요소는 항상 0으로 초기화된다.

### 11.2.1 형식화 배열 타입

### 11.2.2 형식화 배열 만들기

```js
let bytes = new Unit8Array(1024); // 1024 바이트
let matrix = new Float64Array(9); // 3x3 행렬
let point = new Int16Array(3); // 3차원 공간의 점
let rgba = new Unit8ClampedArray(4); // 4바이트 RGBA 픽셀 값
let sudoku = new Int8Array(81); // 9x9 스도쿠
```

```js
let white = Uint8ClampedArray.of(255, 255, 255, 0); // 불투명한 RGBA 흰색
```

```js
let buffer = new ArrayBuffer(1024 * 1024);
buffet.byteLength; // => 1024 * 1024 메모리 1메가바이트
```

```js
let asbytes = new Unit8Array(buffer); // 바이트
let asints = new Int32Array(buffer); // 32비트 부호 붙은 정수
let lastK = new Uint8Array(buffer, 1023 * 1024); // 바이트로 표현한 마지막 킬로바이트
let ints2 = new Int32Array(buffer, 1024, 256); // 정수 256개로 표현한 두 번째 킬로바이트
```

### 11.2.3 형식화 배열 사용

```js
// 에라토스테네스의 체를 사용해 n보다 작은 소수 중 가장 큰 값을 구합니다.
function sieve(n) {
  let a = new Uint8Array(n + 1); // x가 배수이면 a[x]는 1입니다.
  let max = Math.floor(Math.sqrt(n)); // 이보다 큰 값은 처리하지 않습니다.
  let p = 2; // 2는 첫 번째 소수입니다.

  while (p <= max) { // max보다 작은 소수에 대해
    for (let i = 2 * p; i <= n; i += p) a[i] = 1; // p의 배수를 배수로 마크합니다.
    while(a[++p]) /* 비었음 */ // 마크가 없는 다음 인덱스는 소수입니다.
  }

  while(a[n]) n--; // 역으로 순회해 마지막 소수를 찾아
  return n; // 반환합니다.
}
```

배열을 사용해도 똑같이 동작하지만, `Array()` 대신 `Uint8Array()`를 사용하면 속도는 네 배 빠르고 메모리는 1/8만 사용한다.

`push()`, `pop()`, `unshift()`, `shift()`, `splice()`처럼 배열 길이를 바꾸는 메서드는 지원되지 않는다. `sort()`, `reverse()`, `fill()`처럼 배열 길이를 바꾸지 않은 채 콘텐츠만 바꾸는 메서드는 지원된다.

### 11.2.4 형식화 배열의 메서드와 프로퍼티

`set()` 메서드는 일반적인 배열이나 형식화 배열의 요소를 복사해 형식화 배열의 요소 여러개를 한 번에 바꾼다.

- 첫 번째 인자로 배열이나 형식화 배열을 받고 선택 사항인 두 번째 인자로 오프셋을 받는다.
- 두 번째 인자를 생략하면 기본 값은 0이다.

```js
let bytes = new Uint8Array(1024); // 1킬로바이트 버퍼
let pattern = new Uint8Array([0, 1, 2, 3]); // 4바이트 배열
bytes.set(pattern); // 다른 형식화 배열의 시작 지점에 복사합니다.
bytes.set(pattern, 4); // 다른 오프셋에 다시 복사합니다.
bytes.set([0, 1, 2, 3], 8); // 일반적인 배열에서 복사할 수도 있습니다.
bytes.slice(0, 12); // => new Uint8Array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3])
```

`subarray` 메서드는 호출된 배열의 일부분을 반환한다.

- 메모리를 전혀 복사하지 않고 기존의 값을 참조하는 새 뷰를 반환한다.

```js
let ints = new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // 10개의 정수
let last3 = ints.subarray(ints.length - 3, ints.length); // 마지막 세 개
last3[0]; // => 7: ints[7]과 같다.
```

```js
ints[9] = -1; // 원래 배열의 값을 변경하면
last3[2]; // => 1: 하위 배열 역시 바뀐다.
```

### 11.2.5 DataView와 엔디안

**엔디안(endian)**

형식화 배열을 사용하면 동일한 바이트 시퀀스를 8, 16, 32, 64비트 덩어리로 볼 수 있다. 이를 통해 바이트 순서인 '엔디안(endian)'이 드러난다.

- 형식화 배열은 효율성을 높이기 위해 하드웨어의 네이티브 엔디안을 사용한다. 리틀 엔디안 시스템에서는 숫자의 바이트가 `ArrayBuffer`에 최하위에서 최상위 순서로 배열된다. 빅 엔디안에서는 최상위에서 최하위 순서로 배열된다.
- 최근 대부분의 CPU 아키텍처는 리틀 엔디안이다. 하지만 네트워크 프로토콜 중 상당수와 이진 파일 형식 중 일부가 빅 엔디안을 요구한다. 따라서 네트워크나 파일에서 가져온 데이터를 형식화 배열에 사용할 때 플랫폼의 엔디안이 그 데이터의 바이트 순서와 일치한다고 확신하면 안 된다.
- 외부 데이터를 사용할 때 `Int8Array`나 `Uint8Array`를 써서 데이터를 개별 바이트 배열로 볼 수 있지만 다른 형식화 배열을 사용해선 안 된다. `ArrayBuffer`의 값을 읽고 쓸 때 바이트 순서를 명시적으로 지정하는 `DateView` 클래스를 사용한다.

```js
// 이진 데이터의 형식화 배열을 처리한다고 가정합시다.
// 먼저 그 바이트 값을 읽고 쓸 수 있는 DateView 객체를 생성합니다.
let view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
let int = view.getInt32(0); // 바이트 0에서 빅 엔디안 부호 붙은 정수를 읽는다.
int = view.getInt32(4, false); // 다음 정수 역시 빅 엔디안이다.
int = view.getUint32(8, true); // 다음 정수는 리틀 엔디안이고 부호는 없다.
view.setUint32(8, int, false); // 빅 엔디안 형식으로 바꾼다.
```

<br />

## 11.3 정규 표현식과 패턴 매칭

[정규 표현식](https://mnxmnz.vercel.app/javascript/regular-expressions/)

<br />

## 11.4 날짜와 시간

`Date()` 생성자에 숫자 인자를 전달하면 그 인자를 1970년 1월 1일 0시 0분 0초에서 몇 밀리초 지났는지 나타내는 숫자로 간주한다.

```js
let epoch = new Date(0); // Midnight, January 1st, 1970, GMT
```

월은 0부터 시작하지만 일은 1부터 시작한다.

시간 관련 매개변수를 생략하면 `Date()` 생성자는 기본 값으로 전부 0을 사용한다.

`Date()` 생성자에 숫자를 여러 개 전달하면 이들을 컴퓨터의 시간대를 기준으로 해석한다.

UTC를 기준으로 날짜와 시간을 설정하기 위해서는 `Date.UTC()`를 사용해야 한다.

날짜를 UTC로 출력하려면 `toUTCString()`이나 `toISOString()` 메서드를 호출해 명시적으로 문자열로 변환한다.

### 11.4.1 타임스탬프

JS는 내부적으로 날짜를 UTC 1970년 1월 1일로부터 몇 밀리초 지났는지 나타내는 정수로 저장한다.

`Date` 객체의 `getTime()` 메서드는 이 내부 값을 반환하며 `setTime()` 메서드는 그 값을 수정한다. 다음과 같이 `Date` 객체에 30초를 더할 수 있다.

```js
d.setTime(d.getTime() + 30000);
```

밀리초 값을 타임스탬프라고 부르기도 하며, `Date` 객체보다는 타임스탬프를 직접 사용하는 것이 편리할 때도 있다.

정적 메서드 `Date.now()`는 현재 시간을 타임스탬프로 반환하며 코드가 실행될 때 얼마나 오래 걸리는지 확인할 때 유용합니다.

### 11.4.2 날짜 연산

날짜에 연, 월, 일을 더하거나 뺄 때는 `setDate()`, `setMonth()`, `setYear()`를 사용한다.

```js
let d = new Date();
d.setMonth(d.getMonth() + 3, d.getDate() + 14);
```

### 11.4.3 날짜 문자열 형식과 분석

`Date` 클래스에는 `Date` 객체를 문자열로 변환하는 다양한 메서드가 존재한다.

```js
let d = new Date(2020, 0, 1, 17, 10, 30); // 2020년 1월 1일 오후 5시 10분 30초
d.toString(); // => "Wed Jan 01 2020 17:10:30 GMT-0800" (Pacific Standard Time)
d.toUTCString(); // => "Thu, 02 Jan 2020 01:10:30 GMT"
d.toLocaleDateString(); // => "1/1/2020": 'en-US' 로케일
d.toLocaleTimeString(); // => "5:10:30 PM": 'en-US' 로케일
d.toISOString(); // => "2020-01-02T01:10:30.00Z"
```

<br />

## 11.5 Error 클래스

JS는 `throw`와 `catch` 문은 기본 값으로 포함하여 어떤 값이든 에러로 일으키고 캐치할 수 있다. 에러를 일으킬 때 반드시 특정 예외 타입을 사용할 필요는 없다. JS에 `Error` 클래스가 정의되어 있고, `throw` 문으로 에러를 일으킬 때는 `Error` 클래스의 인스턴스나 서브클래스를 사용하는 것이 일반적이다.

`Error` 객체를 사용하는 주된 이유는 이 객체가 JS 스택 상태를 캡처하며, 예외를 캐치하지 않은 경우 에러 메시지와 함께 스택 추적이 표시되므로 디버그하기 편해서이다.

<br />

## 11.6 JSON 직렬화와 분석

> **직렬화**
>
> 프로그램에서 데이터를 저장하거나 네트워크 연결을 통해 다른 프로그램에 전송할 때 메모리에 있는 데이터 구조를 반드시 문자열로 변환해야 한다. 데이터 구조를 바이트나 문자 스트림으로 변환하는 것을 **직렬화**라고 부른다.

JS에서 데이터를 직렬화하는 가장 쉬운 방법은 JSON이라는 직렬화 형식이다.

`JSON.stringify()`와 `JSON.parse()`를 통해 JSON 직렬화와 역직렬화를 지원한다.

<br />

## 11.7 국제화 API

`Intl.NumberFormat`, `Intl.DateTimeFormat`, `Intl.Colla-tor` 세 가지 클래스로 구성된다.

이 클래스를 노드에서 사용하려면 별도의 데이터 패키지를 내려받거나 노드의 사용자 지정 빌드를 사용해야 한다.

### 11.7.1 숫자 형식

`Intl.NumberFormat` 클래스의 `format()` 메서드는 이런 모든 문제를 고려해서 만들었다. 생성자는 인자를 두 개 받는다. 첫 번째 인자는 숫자 형식을 적용할 지역이며, 두 번째 인자는 숫자 형식을 더 자세히 지정하는 객체이다.

### 11.7.2 날짜와 시간 형식

`Intl.DateTimeFormat()` 생성자는 `Intl.NumberFormat()`과 마찬가지로 로케일 또는 로케일 배열과 형식 옵션 객체를 인자로 받는다. 마찬가지로 `format()` 메서드를 호출해 `Date` 객체를 문자열로 변환하는 방식으로 `Intl.DateTimeFormat` 인스턴스를 사용한다.

### 11.7.3 문자열 비교

사용자가 자연스럽게 느끼는 순서로 문자열을 표시하려면 문자열 배열에 단순히 `sort()` 메서드만 사용해서는 충분하지 않다. `Intl.Collator` 객체를 생성하고 그 `compate()` 메서드를 `sort()` 메서드에 전달하면 지역에 적합한 순서로 정열할 수 있다. `Intl.Collator` 객체를 설정하기에 따라 `compate()` 메서드가 대소문자를 가리지 않고 비교하거나, 심지어 악센트나 기타 분음 부호를 무시하고 기본 글자만으로 비교하는 것도 가능하다.

`Intl.NumberFormat()`이나 `Intl.DateTimeFormat()`과 마찬가지로 `Intl.Collator()` 생성자 역시 인자 두 개를 받는다. 첫 번재는 로케일 또는 로케일 배열이며 두 번째는 문자열 비교 방법을 정확히 지정하는 옵션 객체이다.

<br />

## 요약

프로그래밍 언어를 배우는 것은 문법을 마스터한다고 끝나는 일이 아니다. 언어에 포함된 도구 전체에 익숙해질 수 있도록 표준 라이브러리를 공부하는 것도 마찬가지로 중요하다.

- 세트, 맵, 형식화 배열 같은 중요한 데이터 구조
- 날짜와 URL을 다루는 `Date`와 URL 클래스
- 자바스크립트의 정규 표현식 문법과 `RegExp` 클래스를 사용한 텍스트 패턴 매칭
- 날짜와 시간, 숫자 형식과 함께 문자열 정렬을 세부 조정하는 국제화 라이브러리
- 데이터 구조를 직렬화하고 역직렬화하는 `JSON` 객체, 메시지 로그에 사용하는 `console` 객체
