# 11장 자바스크립트 표준 라이브러리

## 1. Set

- Set 객체는 Set 생성자로 만든다
- 배열과 달리 세트는 순서가 없고 인덱스도 없다. 하지만 삽입된 순서대로 순회한다.
- 중복을 허용하지 않는다
- 현실에서 세트로 할 수 있는 가장 중요한 일은 요소를 추가하거나 제거하는 일이 아닌 지정된 값이 세트의 요소인지 체크하는 일이다

```jsx
a = new Set([1,2,3,4]) // Set(4) {1,2,3,4}
b = [...new Set([1,2,3,4])] // [1, 2, 3, 4]
c = Array.from(new Set([1,2,3,4])) // [1, 2, 3, 4]

d = new Set();
d.add([1,2,3])
d.delete([1,2,3]) // false => 참조값이 다르니까

d.add(1).add(2).add(3).add(4).add(5)
```

- 세트가 요소의 존재 여부를 확인하는데 최적화되어 있다. 세트에 요소가 얼마나 많든 has() 메서드는 빠르다
배열의 includes() 메서드도 요소의 존재 여부를 확인하지만 배열 크기에 따라 속도가 달라지며, 배열을 세트처럼 사용하면 실제 Set 객체에 비해 훨씬 느릴수 있다!
| 근데
- Set 객체는 이터러블이라서 for/of 루프로 세트의 요소를 열거할 수 있다.

## 2. Map

- 키로 구성된 집합이며 각 키는 다시 다른값과 연결된다
- 연속된 정수를 키로 사용하는 대신 임의의 값을 인덱스로 사용할 수 있다.
- Map 생성자의 선택사항인 인자는 [key, value] 배열을 전달하는 이터러블 객체여야 한다.
그래서 맵을 생성하는 동시에 초기화하고싶으면 원하는 키와 값을 배열의 배열 형태로 준비해야 한다.

```jsx
a = new Map([[2,'123'],['ㅋㅋㅋ',3],[true,4],[5,7]])
// Map(4) {2 => '123', 'ㅋㅋㅋ' => 3, true => 4, 5 => 7}

a.set("one",1).set("two",1).set("one",1)
```

- Map 객체도 이터러블이라서 for/of 루프로 요소를 열거할 수 있다

```jsx
for(let [key, value] of m) {
	...
}
```

- Map도 삽입된 순서대로 순회한다.
- forEach 메서드도 지원하는데 조금 다르게 지원을 한다

```jsx
m.forEach((value, key) => {
	...
})
```

## 3. WeakMap

- 일단 WeakMap을 이해하기 위해서는 가비지 컬렉션을 알아야한다.
가비지 컬렉션은 자바스크립트 인터프리터가 프로그램에서 더는 접근하거나 사용할 수 없는 객체가 사용하던 메모리를 회수하는 작업이다.
일반적인 Map은 **강하게** 참조하며 키 값에 대한 다른 참조가 더 이상 남아 있지 않더라도 참조 관계를 유지한다.
반면 WeakMap은 키 값을 **약하게** 참조하므로 WeakMap을 통해 해당 키 값을 참조할 수 없고 
키 값이 WeakMap에 존재하더라도 메모리를 회수할 수 있다.
