# 11장 자바스크립트 표준 라이브러리

## 1. Set

- Set 객체는 Set 생성자로 만든다
- 배열과 달리 세트는 순서가 없고 인덱스도 없다. 하지만 삽입된 순서대로 순회한다.
- 중복을 허용하지 않는다
- 현실에서 세트로 할 수 있는 가장 중요한 일은 요소를 추가하거나 제거하는 일이 아닌 지정된 값이 세트의 요소인지 체크하는 일이다

```jsx
a = new Set([1,2,3,4]) // Set(4) {1,2,3,4}
b = [...new Set([1,2,3,4])] // [1, 2, 3, 4]
c = Array.from(new Set([1,2,3,4])) // [1, 2, 3, 4]

d = new Set();
d.add([1,2,3])
d.delete([1,2,3]) // false => 참조값이 다르니까

d.add(1).add(2).add(3).add(4).add(5)
```

- 세트가 요소의 존재 여부를 확인하는데 최적화되어 있다. 세트에 요소가 얼마나 많든 has() 메서드는 빠르다
배열의 includes() 메서드도 요소의 존재 여부를 확인하지만 배열 크기에 따라 속도가 달라지며, 배열을 세트처럼 사용하면 실제 Set 객체에 비해 훨씬 느릴수 있다!
| 근데
- Set 객체는 이터러블이라서 for/of 루프로 세트의 요소를 열거할 수 있다.

## 2. Map

- 키로 구성된 집합이며 각 키는 다시 다른값과 연결된다
- 연속된 정수를 키로 사용하는 대신 임의의 값을 인덱스로 사용할 수 있다.
- Map 생성자의 선택사항인 인자는 [key, value] 배열을 전달하는 이터러블 객체여야 한다.
그래서 맵을 생성하는 동시에 초기화하고싶으면 원하는 키와 값을 배열의 배열 형태로 준비해야 한다.

```jsx
a = new Map([[2,'123'],['ㅋㅋㅋ',3],[true,4],[5,7]])
// Map(4) {2 => '123', 'ㅋㅋㅋ' => 3, true => 4, 5 => 7}

a.set("one",1).set("two",1).set("one",1)
```

- Map 객체도 이터러블이라서 for/of 루프로 요소를 열거할 수 있다

```jsx
for(let [key, value] of m) {
	...
}
```

- Map도 삽입된 순서대로 순회한다.
- forEach 메서드도 지원하는데 조금 다르게 지원을 한다

```jsx
m.forEach((value, key) => {
	...
})
```

## 3. WeakMap

- 일단 WeakMap을 이해하기 위해서는 가비지 컬렉션을 알아야한다.
가비지 컬렉션은 자바스크립트 인터프리터가 프로그램에서 더는 접근하거나 사용할 수 없는 객체가 사용하던 메모리를 회수하는 작업이다.
일반적인 Map은 **강하게** 참조하며 키 값에 대한 다른 참조가 더 이상 남아 있지 않더라도 참조 관계를 유지한다.
반면 WeakMap은 키 값을 **약하게** 참조하므로 WeakMap을 통해 해당 키 값을 참조할 수 없고 
키 값이 WeakMap에 존재하더라도 메모리를 회수할 수 있다.
- WeakMap의 키는 반드시 객체 또는 배열이여야 한다. 원시값은 WeakMap의 키가 될 수 없다. 그리고 기본 값은 설정 X
- WeakMap은 이터러블이 아니며 keys(), values(), forEach() 메서드가 없다.
만약 WeakMap이 이터러블이였다면 키에 접근하게 되고 약한 참조가 성립 할 수 가 없다
- 마찬가지로 WeakMap에는 size 프로퍼티가 없다. WeakMap의 크기는 가비지 컬렉션이 일어날 때마다 언제든 바뀔 수 있기 때문이다.

**가비지 컬렉션이 일어나는 시점은 자바스크립트 엔진이 결정한다.** 
객체는 모든 참조를 잃었을 때, 그 즉시 메모리에서 삭제될 수도 있고, 다른 삭제 작업이 있을 때까지 대기하다가 함께 삭제될 수도 있다. 현재 WeakMap에 요소가 몇 개 있는지 정확히 파악하는 것 자체가 불가능하다. 
가비지 컬렉터가 한 번에 메모리를 청소할 수도 있고, 부분 부분 메모리를 청소할 수도 있으므로 WeakMap의 요소(키/값) 전체를 대상으로 무언가를 하는 메서드는 동작 자체가 불가능하다.

그럼 WeakMap은 어떤 경우에 사용할까???

> 인용 : [https://ko.javascript.info/weakmap-weakset#ref-1624](https://ko.javascript.info/weakmap-weakset#ref-1624)
          [https://ko.javascript.info/weakmap-weakset#ref-1625](https://ko.javascript.info/weakmap-weakset#ref-1625)
> 

## 유스케이스: 추가 데이터

`위크맵`은 *부차적인 데이터를 저장*할 곳이 필요할 때 그 진가를 발휘합니다.

서드파티 라이브러리와 같은 외부 코드에 ‘속한’ 객체를 가지고 작업을 해야 한다고 가정해 봅시다. 이 객체에 데이터를 추가해줘야 하는데, 추가해 줄 데이터는 객체가 살아있는 동안에만 유효한 상황입니다. 이럴 때 `위크맵`을 사용할 수 있습니다.

`위크맵`에 원하는 데이터를 저장하고, 이때 키는 객체를 사용하면 됩니다. 이렇게 하면 객체가 가비지 컬렉션의 대상이 될 때, 데이터도 함께 사라지게 됩니다.

```jsx
weakMap.set(john, "비밀문서");
// john이 사망하면, 비밀문서는 자동으로 파기됩니다.
```

좀 더 구체적인 예시를 들어보겠습니다.

아래에 사용자의 방문 횟수를 세어 주는 코드가 있습니다. 관련 정보는 맵에 저장하고 있는데 맵 요소의 키엔 특정 사용자를 나타내는 객체를, 값엔 해당 사용자의 방문 횟수를 저장하고 있습니다. 어떤 사용자의 정보를 저장할 필요가 없어지면(가비지 컬렉션의 대상이 되면) 해당 사용자의 방문 횟수도 저장할 필요가 없어질 겁니다.

아래 함수는 `맵`을 사용해 사용자의 방문 횟수를 세줍니다.

```jsx
// 📁 visitsCount.js
let visitsCountMap = new Map(); // 맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려줍니다.
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```

아래는 John이라는 사용자가 방문했을 때, 어떻게 방문 횟수가 증가하는지를 보여줍니다.

```jsx
// 📁 main.js
let john = { name: "John" };

countUser(john); // John의 방문 횟수를 증가시킵니다.

// John의 방문 횟수를 셀 필요가 없어지면 아래와 같이 john을 null로 덮어씁니다.
john = null;
```

이제 `john`을 나타내는 객체는 가비지 컬렉션의 대상이 되어야 하는데, `visitsCountMap`의 키로 사용되고 있어서 메모리에서 삭제되지 않습니다.

특정 사용자를 나타내는 객체가 메모리에서 사라지면 해당 객체에 대한 정보(방문 횟수)도 우리가 손수 지워줘야 하는 상황입니다. 이렇게 하지 않으면 `visitsCountMap`가 차지하는 메모리 공간이 한없이 커질 겁니다. 애플리케이션 구조가 복잡할 땐, 이렇게 쓸모 없는 데이터를 수동으로 비워주는 게 꽤 골치 아픕니다.

이런 문제는 `위크맵`을 사용해 예방할 수 있습니다.

```jsx
// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // 위크맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려줍니다.
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```

`위크맵`을 사용해 사용자 방문 횟수를 저장하면 `visitsCountMap`을 수동으로 청소해줄 필요가 없습니다. `john`을 나타내는 객체가 도달 가능하지 않은 상태가 되면 자동으로 메모리에서 삭제되기 때문입니다. `위크맵`의 키(`john`)에 대응하는 값(john의 방문 횟수)도 자동으로 가비지 컬렉션의 대상이 됩니다.

## 유스케이스: 캐싱

위크맵은 캐싱(caching)이 필요할 때 유용합니다. 캐싱은 시간이 오래 걸리는 작업의 결과를 저장해서 연산 시간과 비용을 절약해주는 기법입니다. 동일한 함수를 여러 번 호출해야 할 때, 최초 호출 시 반환된 값을 어딘가에 저장해 놓았다가 그다음엔 함수를 호출하는 대신 저장된 값을 사용하는 게 캐싱의 실례입니다.

아래 예시는 함수 연산 결과를 `맵`에 저장하고 있습니다.

```jsx
// 📁 cache.js
let cache = new Map();

// 연산을 수행하고 그 결과를 맵에 저장합니다.
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* 연산 수행 */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

*// 함수 process()를 호출해봅시다.*// 📁 main.js
let obj = {/* ... 객체 ... */};

let result1 = process(obj); // 함수를 호출합니다.

// 동일한 함수를 두 번째 호출할 땐,
let result2 = process(obj); // 연산을 수행할 필요 없이 맵에 저장된 결과를 가져오면 됩니다.

// 객체가 쓸모없어지면 아래와 같이 null로 덮어씁니다.
obj = null;

alert(cache.size); // 1 (엇! 그런데 객체가 여전히 cache에 남아있네요. 메모리가 낭비되고 있습니다.)
```

`process(obj)`를 여러 번 호출하면 최초 호출할 때만 연산이 수행되고, 그 이후엔 연산 결과를 `cache`에서 가져옵니다. 그런데 `맵`을 사용하고 있어서 객체가 필요 없어져도 `cache`를 수동으로 청소해 줘야 합니다.

`맵`을 `위크맵`으로 교체하면 이런 문제를 예방할 수 있습니다. 객체가 메모리에서 삭제되면, 캐시에 저장된 결과(함수 연산 결과) 역시 메모리에서 자동으로 삭제되기 때문입니다.

```jsx
// 📁 cache.js
*let cache = new WeakMap();*// 연산을 수행하고 그 결과를 위크맵에 저장합니다.
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* 연산 수행 */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* ... 객체 ... */};

let result1 = process(obj);
let result2 = process(obj);

// 객체가 쓸모없어지면 아래와 같이 null로 덮어씁니다.
obj = null;

// 이 예시에선 맵을 사용한 예시처럼 cache.size를 사용할 수 없습니다.
// 하지만 obj가 가비지 컬렉션의 대상이 되므로, 캐싱된 데이터 역시 메모리에서 삭제될 겁니다.
// 삭제가 진행되면 cache엔 그 어떤 요소도 남아있지 않을겁니다.
```

여기서 한가지 의문점이 생겼다.
가비지 콜렉터의 목적은 메모리 할당을 모니터링하고 할당된 메모리의 블록이 더 이상 필요하지 않은 시점을 확인하여 회수하는 것인데 더 이상 필요하지 않다고 결정하는 기준이 궁금해졌다.

> 참고 : [https://eblee-repo.tistory.com/52](https://eblee-repo.tistory.com/52)
> 

# Mark-and-sweep 알고리즘

이 알고리즘에서는 "더 이상 필요 없는 객체"를 "닿을 수 없는 객체"로 정의합니다. 이름에서 알 수 있듯이 무엇인 가에 표시(Mark)를 하고, 정리하는(Sweep) 알고리즘입니다.

이 알고리즘은 roots라는 객체의 집합을 가지고 있습니다.(자바스크립트에서는 전역 변수들을 의미합니다.)

주기적으로 가비지 콜렉터는 roots로부터 시작하여 roots가 참조하는 객체들, roots가 참조하는 객체가 참조하는 객체들을 접근할 수 있는 객체라고 표시합니다. 그 후, 접근할 수 없는 객체에 대해 가비지 컬렉션을 수행합니다.

이 알고리즘은 "참조되지 않는 객체"는 모두 "접근할 수 없는 객체"이지만 [역](https://ko.wikipedia.org/wiki/%EC%97%AD_(%EB%85%BC%EB%A6%AC%ED%95%99))은 성립하지 않기 때문에 참조-세기 알고리즘보다 효율적이라고 할 수 있습니다.

2012년 기준, 모든 최신 브라우저들이 가비지 컬렉션에서 Mark-and-sweep 알고리즘을 사용한다고 합니다. 그 후로도 연구되고 있는 자바스크립트 가비지 콜렉션 알고리즘들은 대부분 이 알고리즘을 연구하여 개선한 것이라고 합니다. 그리고 개선된 알고리즘들도 여전히 "더 이상 필요 없는 객체"를 "닿을 수 없는 객체"로 정의하고 있습니다.

# 동작 방식

이 알고리즘은 아래 두 단계로 작동합니다.

1. Mark객체가 생성될 때마다 mark bit가 0 (false)로 설정됩니다.Mark 단계에서 모든 접근 가능한 객체의 mark bit가 1 (true)로 설정됩니다.
2. SweepMark 단계 후에 mark bit가 여전히 0 (false)로 설정된 객체들은 도달할 수 없는 객체이므로 가비지 콜렉터가 수집해 메모리에서 해제됩니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cec2620a-5763-46ef-ada8-8f07edd8efaa/Untitled.png)

### 질문

아래 코드박스에서 john 이라는 사람이 회원탈퇴를 하지않는이상 가비지 컬렉터는 덜 감시할 뿐이지 제거되지 않는 것 아닌가? 

```jsx
weakMap.set(john, "비밀문서");
// john이 사망하면, 비밀문서는 자동으로 파기됩니다.
```

캐시도 Map이나 WeakMap이나 비슷한 성능을 내지 않을까 생각이든다. 그 캐시된 객체가 사용되는지 안되는지 판단하도록 처리해주는것도 결국 개발자가 해야하는것이 아닌가?

### 자문자답

객체가 쓸모 없어지는 시점에 정확히 메모리가 해제되지 않기 때문에 최적의 메모리 관리가 되지 않는다가 GC의 단점이다.

# 4. 형식화 배열 (TypedArray)

- 형식화 배열의 요소는 모두 숫자이다.
- 형식화 배열을 생성할 때 반드시 길이를 지정해야 하며 이 길이는 절대 바꿀 수 없다.
- 형식화 배열의 요소는 항상 0으로 초기화 된다.

# 5. 정규 표현식

[https://github.com/sangbooom/TIL/tree/master/정규식](https://github.com/sangbooom/TIL/tree/master/%EC%A0%95%EA%B7%9C%EC%8B%9D)

적극적(greedy) 반복 

소극적 반복

괄호의 다른목적은 하위 패턴을 정의하는 것이다.

# 6. 날짜와 시간

# 7. 에러 클래스

# 8. JSON 직렬화와 분석

# 9. 국제화 API

# 10. URL API
