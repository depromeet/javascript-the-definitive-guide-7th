# 3장. 타입, 값, 변수

컴퓨터 프로그램은 **값**을 조작하며 동작

프로그래밍 언어에서 표현하고 조작할 수 있는 값의 종류 = **타입**

프로그램에서 값을 나중에 사용하기 위해 유지하려면 **변수**에 값을 할당(저장)함

변수에는 이름이 있으며 프로그램은 변수 이름을 통해 값을 참조함

프로그래밍 언어의 가장 기본적인 특징

- 어떤 타입을 지원하는지
- 변수가 동작하는 방법

## 3.1 개요와 정의

- **기본 타입** : 숫자, 문자열, 불(boolean), null, undefined, 심벌(Symbol)
  심벌의 목적은 하위 호환성을 해치지 않으면서 언어의 확장을 정의하는 것
- **객체 타입** : 객체, 배열
  - 객체 : 이름 붙은 값의 순서 없는 집합
    객체 타입의 멤버이며 프로퍼티의 집합
    각 프로퍼티에는 이름과 값이 있고, 이 값은 기본값일 수도 있고 다른 객체일 수 있음
  - 배열 : 이름 없는 값의 순서 있는 집합이며, 각 값은 숫자로 표현됨
  - Set 객체 : 값의 집합
  - Map 객체 : 키와 값의 연결
  - 형식화 배열 : 바이트 배열과 다른 이진 데이터를 연결
  - RegExp 타입 : 텍스트 패턴이며, 문자열에서 정교한 매칭, 검색, 대체 동작을 할 수 있음
  - Date 타입 : 날짜와 시간을 표현
  - Error 타입 : 자바스크립트 코드 실행 중에 일어날 수 있는 에러를 가리킴
  - 함수, 클래스
    함수, 클래스는 그 자체가 값이므로 프로그램에서 조작할 수 있음
    이 점이 다른 정적 언어와의 차이점
- 자바스크립트 인터프리터는 자동으로 가비지 컬렉션을 수행해 메모리를 관리함
  - 값을 직접 파괴하거나 할당을 해제할 필요가 없음
  - 프로그램에서 어떤 값을 더는 참조하지 않게 되면 인터프리터는 그 값을 다시 사용할 수 없음을 인식하고 그 값이 차지하고 있던 메모리를 자동으로 다시 확보함
- 자바스크립트는 객체 지향 프로그래밍 스타일을 지원함

  - 함수가 다양한 타입의 값을 다루는 것이 아니라 객체(타입 자체)에 그 값을 다루는 메서드를 정의함

    - 배열 a의 요소를 정렬할 때 a를 sort() 함수에 전달하는 것이 아니라, a의 sort() 메서드를 호출함

    ```jsx
    a.sort(); // sort(a)의 객체지향 버전
    ```

  - 오직 객체만 메서드를 가질 수 있음. but, 숫자, 문자열, 불, 심벌도 마치 메서드가 잇는것처럼 동작. 단, null, undefined는 메서드 호출 불가

- 객체 타입은 가변(mutable), 기본 타입은 불변(immutable)
- 자바스크립트는 값의 타입을 자유롭게 변환함
  - 값 변환 규칙은 동등성의 정의에 영향을 미치며, 규칙에 따라 타입을 변환함
  - 동등 연산자(==)는 권장하지 않고, 타입을 변환하지 않는 일치 연산자(===)를 권장함
- 프로그램에서는 상수와 변수의 이름을 통해 값을 참조함
  - 상수는 const, 변수는 let
  - 상수와 변수에는 타입이 없다. 선언할 때 어떤 값이 할당되는지 명시하지 않는다.

## 3.2 숫자

자바스크립트 숫자 타입, Number

IEEE 754 표준애서 정의하는 64비트 부동 소수점 형식을 사용해 숫자를 표현함

최대 ±1.7976931348623157 x 10^308, 최소 ±5 x 10^-324범위의 숫자 표현 가능자바스크립트 숫자 형식은 -9,007,199,254,740,992(—2^53) 이상, 9,007,199,254, 740,992(2^53) 이하 범위의 정수를 정확히 표현 가능

숫자 리터럴 : 자바스크립트 프로그램에 직접 기입한 숫자

### 3.2.1 정수 리터럴

- 10진 정수는 연속된 숫자로 표현
  0
  3
  10000000
- 16진수 리터럴은 0x 또는 0X로 시작, 그 뒤에 16진수 숫자를 씀
  16진수 숫자는 0부터 9까지의 숫자나 a(A)부터 f(F)까지의 문자, 문자는 10부터 15까지
  ```jsx
  0xff; // => 255: (15*16 + 15)
  0xbadcafe; // => 195939070
  ```
- ES6 이후 버전에서는 0b(0B)를 앞에 붙여 2진수를, 0o(0O)를 앞에 붙여 8진수로 정수를 표현할 수 있음
  ```jsx
  0bl0101 //=>21: (1*16+0*8+1*4+0*2+1*1)
  00377 // => 255: (3*64 + 7*8 + 7*1)
  ```

### 3.2.2 부동 소수점 리터럴

- 부동 소수점 리터럴에는 소수점이 포함될 수 있음
  즉, 실수의 전통적 문법을 사용
  값은 정수 부분, 소수점, 소수점 아래 부분을 순서대로 씀
- 지수 표기법으로도 표현할 수 있음
  실수 다음에 e(E)를 쓰고, 선택 사항인 플러스 또는 마이너스 기호, 지수를 나타내는 정수를 쓰는 형식
  실수에 10의 지수 승을 곱하는 방식으로 표현
  ```jsx
  [digits] [.digits] [(E|e) [(+\-)]digits]
  ```
  ```jsx
  3.14;
  2345.6789;
  0.333333333333333333;
  6.02e23; // 6.02 x 10^23 
  1.4738223E-32 // 1.4738223 x 10^-32
  ```
  
  ### 3.2.3 자바스크립트의 산술 연산
  
  - 자바스크립트는 산술 연산자를 통해 숫자를 조작
    덧셈 +, 뺄셈 -, 곱셈 \*, 나눗셈 /, 나머지 %, 지수 \*\* (ES2016에서 추가)
    Math 객체의 프로퍼티로 정의된 함수와 상수를 통해 더 복잡한 수학 계산을 지원
  ```jsx
  Math.pow(2, 53); // => 9007199254740992: 2의 53승
  Math.round(0.6); // => 1.0: 가장 가까운 정수로 반올림
  Math.ceil(0.6); // => 1.0: 정수로 올림
  Math.floor(0.6); // => 0.0: 정수로 내림
  Math.abs(-5); // => 5: 절댓값
  Math.max(x, y, z); // 인자 중 가장 큰 것을 반환합니다.
  Math.min(x, y, z); // 가장 작은 인자를 반환합니다.
  Math.random(); // 0 이상 1.0 미만의 랜덤한 숫자 X
  Math.PI; // PI: 원주율
  Math.E; // e: 자연 로그의 밑
  Math.sqrt(3); // => 3**0.5: 3의 제곱근
  Math.pow(3, 1 / 3); // => 3**(1/3) : 3의 세제곱근
  Math.sin(0); // 삼각함수. Math.cos, Math.atan 등도 있습니다.
  Math.log(10); // 10의 자연 로그
  Math.log(100) / Math.LN10; // 100의 상용 로그
  Math.log(512) / Math.LN2; // 512의 이진 로그
  Math.exp(3); // Math.E의 세제곱
  ```
  ES6에서 Math 객체에 함수가 더 추가됨
  ```jsx
  Math.cbrt(27); // => 3: 세제곱근
  Math.hypot(3, 4); // => 5: 인자의 제곱의 합의 제곱근
  Math.logl0(100); // => 2: 상용 로그
  Math.log2(1024); // => 10: 이진 로그
  Math.loglp(x); // 1+x의 자연 로그. x가 아주 작아야 정확합니다.
  Math.expml(x); // Math.exp(x)-1: Math.loglp()의 역
  Math.sign(x); // 인자의 부호에 따라 -1, 0, 1을 반환합니다.
  Math.imul(2, 3); // => 6: C언어의 방식을 차용한 32비트 정수의 곱셈
  Math.clz32(0xf); // => 28: 32비트 정수에서 맨 앞의 0비트 개수
  Math.trunc(3.9); // => 3: 소수점 아래를 잘라 내어 정수로 변환합니다.
  Math.fround(x); // 가장 가까운 32비트 부동 소수점 숫자로 반올림합니다.
  Math.sinh(x); // 하이퍼볼릭 사인. Math.coshO, Math.tanhO도 있습니다.
  Math.asinh(x); // 하이퍼볼릭 아크사인. Math.acoshO, Math.atanh()도 있습니다.
  ```
- 산술 연산 과정 에 0으로 나누거나 오버플로, 언더플로가 발생해도 에러를 일으키지 않음
  계산 결과가 자바스크립트가 표현할 수 있는 가장 큰 숫자보다 큰 경우(오버플로)에는 특별한 값 `Infinity`를 반환, 음수의 절댓값이 자바스크립트가 표현할 수 있는 가장 큰 음수의 절댓값보다 크다 면 결과는 음의 무한대 인 `-Infinity` 를 반환
  무한한 값에 다른 숫자를 더하거나, 빼 거나, 곱하거나, 나누더라도 결과는 여전히 무한한 값(부호는 바뀔 수 있음)
- 언더플로는 계산 결과가 자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까울 때 일어남 → 0을 반환
  음수에서 언더플로가 일어나면 자바스크립트는 → ‘음의 0’이라는 특별한 값을 반환
  일반적인 0과 완전히 같음
- 0으로 나눠도 에러가 일어나지 않음 → 무한대 또는 음의 무한대를 반환
  예외) 0을 0으로 나누는 경우 → 특별한 값 NaN(숫자가 아님)
  무한대를 무한대로 나누거나, 음수의 제곱근을 구하려 하거나, 숫자가 아니고 숫자로 변 환할 수도 없는 피 연산자에 산술 연산자를 적용하려 할 때도 NaN이 반환됨
- 자바스크립트의 Infinity와 NaN은 전역 상수이며 이들은 Number 객체의 프로퍼티로도 존재

  ```jsx
  Infinity; // 표현하기엔 너무 큰 양수
  Number.POSITIVE_INFINITY; // 같은 값
  1 / 0; // => Infinity
  Number.MAX_VALUE * 2 - // => Infinity; 오버플로
    Infinity; // 표현하기엔 절댓값이 너무 큰 음수
  Number.NEGATIVE_INFINITY - // 같은 값
    1 / 0 - // => -Infinity
    Number.MAX_VALUE * 2; // => -Infinity

  NaN; // 숫자가 아닌 값
  Number.NaN; // NaN과 같은 값이며 표현만 다릅니다.
  0 / 0; // => NaN
  Infinity / Infinity; // => NaN

  Number.MIN_VALUE / 2 - // => 0: 언더플로
    Number.MIN_VALUE / 2 - // => -0: 음의 0
    1 / Infinity - // => -0: 음의 0
    0;

  // 다음 Number 프로퍼티는 ES6에서 정의했습니다.
  Number.parseInt(); // 전역 함수 parseInt()와 같습니다.
  Number.parseFloat(); // 전역 함수 parseFloat()와 갈습니다.
  Number.isNaN(x); // x는 NaN인가?
  Number.isFinite(x); // x는 유한한 숫자인가?
  Number.isInteger(x); // x는 정수인가?
  Number.isSafeInteger(x); // x는 - (2**53)보다 크고 2**53보다 작은 정수인가?
  Number.MIN_SAFE_INTEGER; // => 2**53 - 1
  Number.MAX_SAFE_INTEGER; // => -(2**53 - 1)
  Number.EPSILON; //=>2**-52 : 숫자를 구별할 수 있는 가장 작은 차이
  ```

  NaN 값은 자기 자신을 포함해 어떤 값과도 같지 않다
  즉, x 변수 의값이 NaN인지 알아보기 위해
  `x === NaN` (X)
  `x != x` (O)
  `Number.isNaN(x)` (O)
  → x가 전역 상수 NaN과 같은 값 일 때만 true를 반환

- Number.isNaN() 함수는 인자가 전역 상수 NaN과 같은 값 일 때만 true를 반환
  전역 함수 isNaN()는 인자가 NaN이거나, 숫자가 아니면서 숫자로 변환할 수도 없는 값일 때 true를 반환
  Number.isFinite() 함수는 인자가 NaN, Infinity, -Infinity가 아닐 때 true를 반환
  전역 함수 isFinite()는 인자가 유한한 숫자이거나 유한한 숫자로 변환할 수 있을 때 true를 반환
- 음의 0은 통상적인 값은 아님. 이 값은 일치 연산자(===)로 양의 0과 비교해 도 true를 반환하므로 두 값에 차이가 없다고 해도 무방하지만, 다음과 같이 제수 (분모)로 사용될 때는 예외
  ```jsx
  let zero = 0; // 일반적인 0
  let negz = -0; // 음의 0
  zero === negz; // => true: 0와 음의 0은 일치합니다.
  1 / zero === 1 / negz; // => false: Infinity와 -Infinity는 일치하지 않습니다.
  ```

### **3.2.4** 이진 부동 소수점 숫자와 반올림 오류

실수는 무한히 많지만, 자바스크립트의 부동 소수점 형식으로 정확히 표현할 수 있는 숫자는 유한하므로, 자바스크립트로 실수를 다룰 때 실제 숫자의 근삿값으로 표현된다

이진 부동 소수점 표현은 0.1 같은 단순한 숫자를 정확히 표현하지 못한다

```jsx
let x = 0.3 - 0.2; // 0.3 빼기 0.2
let y = 0.2 - 0.1; //0.2 빼기 0.1
x === y; // => false: 두 값은 같지 않습니다!
x === 0.1; // => false: 0.3 - 0.2는 0.1과 같지 않습니다.
y === 0.1; // => true: 0.2 - 0.1은 0.1입니다.
```

반올림 오류 때문에 0.3과 0.2의 차이의 근삿값은 0.2와 0.1의 차이의 근삿값과 같지 않다

이 문제는 자바스크립트 뿐만 아니라, 이진 부동 소수점 숫자를 사용하는 프로그래밍 언어에서 모두 발생

부동 소수점 근삿값 때문에 프로그램에 문제가 생긴다면 정수로 변환하는 것이 좋다

예를 들어 돈을 계산할 때 0.1달러 대신 10센트로 계산

### **3.2.5 Biglnt**로 임의 정확도를 부여한 정수

Biglnt : 값이 정수인 숫자 타입
Biglnt는 ES2020에서 정의한 자바스크립트의 최신 기능

다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가되었다

Bi이nt 리터럴은 연속된 숫자 다음에 소문자 n을 붙인 형식

Biglnt는 기본 적으로 10진수지만 0b, 0o, 0x를 앞에 붙여 이진, 8진, 16진수 Biglnt를 만들 수 있다

```jsx
1234n; // 그렇게 크지는 않은 BigInt 리터럴
Ob111111n; // 이진 BigInt
0o7777n; // 8진 BigInt
0x8000000000000000n; // => 2n**63n: 64비트 정수
```

Biglnt() 함수를 써서 일반적인 자바스크립트 숫자나 문자열을 Biglnt로 변환할 수 있다

```jsx
Biglnt(Number.MAX_SAFE_INTEGER); // => 9007199254740991n
let string = "1" + "0".repeat(100); // 1 뒤에 0이 100개 있습니다.
Biglnt(string); // => 10n**100n: 1구골
```

BigInt 값의 산술 연산은 일반적인 자바스크립트 숫자의 산술 연산과 비슷하지만, 나눗셈을 할 때 나머지를 버린다는 점이 다르다

```jsx
1000n + 2000n; // => 3000n
3000n - 2000n; // => 1000n
2000n * 3000n; // => 6000000n
3000n / 997n; // => 3n : 몫은 3이다.
(3000n %
  997n(
    // => 9n : 나머지는 9이다.
    2n ** 131071n
  )) -
  1n; // 39457 자리의 메르센 소수(Mersenne prime)^3
```

BigInt에 +, \*, /, %, \*\* 같은 표준 연산자를 쓸 수 있긴 하지만, Biglnt 피연산자와 일반적인 숫자 피연산자를 섞어 쓸 수는 없다

반면 비교 연산자는 피 연산자를 섞어도 괜찮다

```jsx
1 < 2n; // => true
2 > 1n; // => true
0 == 0n; // => true
0 === 0n; // => false: ===는 타입까지 같은지 체크합니다.
```

비트 연산자도 Biglnt를 피연산자로 받을 수 있으나, Math 객체의 함수에는 Biglnt 피 연산자를 받을 수 있는 것이 없다

### **3.2.6** 날짜와 시간

Date 클래스는 날짜와 시간에 대응하는 숫자를 표현하고 조작한다

```jsx
let timestamp = Date.nowO; // 현재 시간을 타임스탬프(숫자) 형식으로 표시합니다
let now = new DateO(); // 현재 시간을 Date 객체로 표시합니다.
let ms = now.getTimeO; // 밀리초 타임스탬프로 변환합니다.
let iso = now.toISOStringO; // 표준 형식의 문자열로 변환합니다.
```

## 3.3 텍스트

텍스트를 표현하는 타입은 문자열

문자열은 16비트 값이 순서에 따라 이어진 형태이며, 기본 값이므로 불변

각 값은 일반적으로 유니코드 문자

문자열의 길이(length)는 그 문자열에 포함된 16비트 값의 개수

자바스크립트 문자열과 그 배열 형태의 위치(인덱스)는 0에서 시작

빈 문자열은 길이가 0인 문자열

![Untitled](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%20fdc1a/Untitled%201.png)

### 3.3.1 문자열 리터럴

문자열을 앞뒤가 맞는 작은따옴표(‘), 큰따옴표(“), 백틱(') 쌍으로 묶어 사용

```jsx
"" // 빈 문자열: 문자가 들어 있지 않습니다.
'testing' "3.14"
,name=,,myfom,''
"Wouldn't you prefer O'Reilly's book?"
"t is the ratio of a circle's circumference to its radius"
'"She said 'hi'", he said.'
```

백 틱으로 감싼 문자열은 ES6 기능이며 문자열 리터럴 안에 자바스크립트 표현식을 넣을 수 있다 → 보간(interpolation)

ES5부터는 각 행의 마지막에 역슬래시(\)를 써서 문자열 리터럴을 여러 행으로 구분

이 때, 역슬래시나 줄 끝 문자는 문자열 리터럴에 미포함

작은따옴표나 큰따옴표로 감싼 문자열 리터럴 안 에 뉴라인 문자를 써야 할 때는 문자 시퀀스 \n을 사용

ES6 백틱 문법의 경우 줄 끝 문자가 문자열 리터럴에 포함된다

```jsx
// 두 행을 한 행으로 표현했습니다.
"two\nlines";
// 한 행을 세 행으로 나눠 썼습니다.
"one\
long\
line"// 두 행 문자열을 두 행에 나눠 썼습니다.
`이 행의 마지막에 있는 줄바꿈 문자는
있는 그대로 문자열의 일부입니다`;
```

아포스트로피 = 작은따옴표

작은따옴표로 감싼 문자열 안에 아포스트로피를 쓸 때는 반드시 역슬래시로 이스케이프해야한다

```jsx
can\’t
O\’Reilly\’s
```

클라이언트 사이드 자바스크립트 프로그래밍 에서는 자바스크립트 코드에 HTML 문자열이 들어갈 수 있고, HTML 안에 자바스크립트 코드가 들어갈 수 있다

자바스크립트와 HTML을 섞어 쓸 때는 따옴표를 구분하는 규칙을 정해 두는 게 좋다

ex)

```jsx
<button onclick="alert('Thank you')">Click Me</button>
```

### **3.3.2** 문자열 리터럴 안의 이스케이프 시퀀스

자바스크립트 이스케이프 시퀀스와 그 시퀀스가 표현하는 문자 리스트

| 시퀀스 | 표현하는 문자                                                                                         |
| ------ | ----------------------------------------------------------------------------------------------------- |
| \0     | NUL 문자 (\u0000)                                                                                     |
| \b     | 백스페이스 (\u0008)                                                                                   |
| \t     | 탭 (\u0009)                                                                                           |
| \n     | 뉴라인 (\u000A)                                                                                       |
| \v     | 세로 탭 (\u000B)                                                                                      |
| \f     | 폼 피드 (\u000C)                                                                                      |
| \r     | 캐리지 리턴 (\u000D)                                                                                  |
| \”     | 큰따옴표 (\U0022)                                                                                     |
| \’     | 작은따옴표(아포스트로피) (\u0027)                                                                     |
| \\     | 역슬래시 (\u005C)                                                                                     |
| \xnn   | 16진수 숫자 두 개 nn으로 표현하는 유니코드 문자                                                       |
| \unnnn | 16진수 숫자 네 개 nnnn으로 표현하는 유니코드 문자                                                     |
| \u{n}  | 코드 포인트 n으로 표현하는 유니코드 문자. 여기서 n은 0에서 10FFFF 범위에 있는 16진수 숫자 입니다(ES6) |

마지막 세 가지 이스케이프 시퀀스는 범용적이며 그 뒤에 유니코드 문자 코드를 16진수 숫자로 써서 어떤 문자든 표현할 수 있다

예를 들어 \xA9는 저작권 기호인데, 16진수 숫자 A9가 유니코드 인코딩을 나타낸다

\u 이스케이프도 임의의 유니코드 문자를 표현. 이 뒤에는 16진수 숫자를 네 개 쓰거나, 중괄호 안에 16진수 숫자를 1~6개 쓰는 두 가지 형식이 있다

예를 들어 \u03c0은 pi 문자이고, \u{1f600}은 웃는 얼굴 이모지

표에 없는 문자 앞에 역슬래시를 쓰면 그 역슬래시는 무시된다

예를 들어 \#은 #과 마찬가지

ES5부터는 줄 바꿈 앞에 역슬래시를 삽입해 문자열 리터럴을 여러 행으로 나눠 쓰는 표기법을 허용

### **3.3.3** 문자열 다루기

자바스크립트에는 문자열을 ‘병합(연결)’하는 기능이 내장되어 있다

- 연산자 를 숫자와 함께 쓰면 이 연산자는 숫자를 더한다

- 연산자를 문자열에 쓰면 두 번째 문자열을 첫 번째 문자열 뒤에 이어 붙인다

```jsx
let msg = "Hello, " + "world"; // 문자열 "Hello, world"
let greeting = "Welcome to my blog," + " " + name;
```

문자열을 비교할 때는 일치 연산자 ===와 불일치 연산자 !==가 표준이다

두 문자열이 정확히 같은 16비트 값의 연속으로 이루어졌을 때에만 일치한다

문자열을 16비트 값을 비교하여 <, <=, >, >= 연산자로 비교할 수도 있다

문자열의 길이, 즉 그 안에 포함된 16비트 값의 개수는 length 프로퍼티로 알 수 있다

```jsx
s.length; // 문자열의 길이
let s = "Hello, world"; // o| 텍스트를 예제에 사용합니다.

// 문자열의 일부를 가져옵니다.
s.substring(1, 4); // => "ell": 두 번째, 세 번째, 네 번째 문자
s.slice(1, 4); // => "ell": 같은 결과입니다.
s.slice(-3); // => "rld": 마지막 세 문자
s.split(", "); // => ["Hello", "world"] 구분자를 기준으로 나눕니다.

// 문자열 검색
s.indexOf("l"); // => 2: l이 처음 나타나는 위치
s.indexOf("l", 3); // => 3: 3번 문자부터 시작해 l이 처음 나타나는 위치
s.indexOf("zz"); // => -1: S에는 ZZ라는 문자열이 들어 있지 않습니다.
s.lastIndexOf("l"); // => 10: l이 마지막으로 나타나는 위치

// 불을 반환하는 검색 함수는 ES6에서 추가됐습니다.
s.startsWith("Hell"); // => true: s는 Hell로 시작합니다.
s.endsWith("!"); // => false: S는 로 끝나지 않습니다.
s.includes("or"); // => true: s에는 or이 들어 있습니다.

// 문자열을 변경합니다.
s.replace("llo", "ya"); // => "Heya, world"
s.toLowerCase(); // => "hello, world"
s.toUpperCase(); // => "HELLO, WORLD"
s.normalize(); // 유니코드 NFC 정규화는 ES6에서 추가됐습니다.
s.normalize("NFD"); // NFD 정규화. NFKC, NFKD도 있습니다.

// 문자열의 각 16비트 문자를 검사합니다.
s.charAt(0); // => "H": 첫 번째 문자
s.charAt(s.length - 1); // => "d": 마지막 문자
s.charCodeAt(0); // => 72: 주어진 위치의 16비트 숫자
s.codePointAt(0); // => 72: 16비트보다 큰 코드 포인트에서 동작하는 ES6 기능

// 패딩 함수는 ES2017에서 추가됐습니다.
"x".padStart(3); // => "   x": 왼쪽에 스페이스를 세 개 더합니다.
"x".padEnd(3); // => "x   ": 오른쪽에 스페이스를 세 개 더합니다.
"x".padStart(3, "*"); // => "**x" : *를 왼쪽에 붙여 길이를 3에 맞춥니다.
"x".padEnd(3, "-"); // => "x--" : -를 오른쪽에 붙여 길이를 3에 맞춥니다.

// 공백 제거. trim()은 ES5, 나머지는 ES2019 기능입니다.
" test ".trim(); // => "test": 앞뒤 공백을 제거합니다.
" test ".trimStart(); // => "test ": 왼쪽 공백을 제거합니다. trimLeft도 있습니다.
" test ".trimEnd(); // => " test": 오른쪽의 공백을 제거합니다. trimRight도 있습니다.

// 그 외의 문자열 메서드
s.concat("!"); // => HHello, world!H: + 연산자를 쓰는 게 더 간단합니다.
"<>".repeat(5); //=> Hooooo": n번 복사합니다. ES6에서 추가됐습니다.
```

주의할 점은, 자바스크립트의 문자열은 불변이다!

replace()나 toUpperCase() 같은 메서드는 기존 문자열을 수정하는 것이 아니라 새 문자열을 반환하는 것이다

문자열은 읽기 전용 배열로 취급할 수 있다

charAt() 메서드 대신 대괄호를 써서 문자열의 개별 문자(16비트 값)에 접근할 수 있다

```jsx
let s = "hello, world";
s[0]; // => "h"
s[s.length - 1]; // => "d"
```

### **3.3.4** 템플릿 리터럴

ES6부터 백틱으로 감싼 문자열 리터럴

임의의 자바스크립트 표현식을 넣을 있다

백틱으로 둘러싼 문자열 리터럴의 최종 값은 그 안에 포함된 표현식을 **평가**해서 그 표현식의 값을 문자열로 변환한 다음, 변환된 문자열을 백틱 안에 들어 있는 리터럴 문자와 결합한 값으로 결정된다

```jsx
let name = "Bill";
let greeting = `Hello ${name}.`; // greeting == "Hello Bill."
```

${} 안에 있는 것은 자바스크립트 표현식으로 해석되고,

중괄호 밖에 있는 것은 일반적인 문자열 리터럴 텍스트

중괄호 안의 표현식을 평가하고 문자열로 변환한 후 템플릿에 삽입할 때 달러 기호와 중괄호, 그 안에 있는 것을 대체한다

템플릿 리터 럴 안에 쓸 수 있는 표현식 개수에는 제한이 없다

```jsx
let errorMessage = `\
\u2718 Test failure at ${filename}:${linenumber}: 
${exception.message}
Stack trace:
${exception.stack}
`;
```

**태그된 템플릿 리터럴**
여는 백틱 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수 에 전달된다

‘태그된 템플릿 리터럴’의 값이 함수의 반환 값이다

HTML이나 SQL을 텍스트에 붙이기 전에 이스케이프하는 용도로 사용

```jsx
`\n`.length; // => 1: 이 문자열에는 뉴라인 문자 하나만 있습니다.
String.raw`\n`.length; // => 2: 역슬래시 문자와 n
```

태그된 템플릿 리터럴의 태그 부분이 함수임에도 불구하고 괄호 없이 호출되었으며, 백틱 문자가 여닫는 괄호를 대체했다

### **3.3.5** 패턴 매칭

정규 표현식(RegExp) : 문자열 내부의 패턴을 정의하고 매칭

정규 표현식 리터럴은 슬래시 한 쌍 사이에 텍스트를 쓰는 형태

두 번째 슬래시 뒤에도 글자 하나 이상 쓸 수 있으며 패턴의 의미를 수정

```jsx
/^HTML/; // 문자열의 시작 부분에 있는 H T M L에 일치합니다.
/[1-9][0-9]*/; // 0이 아닌 숫자가 하나 있어야 하고 그 뒤의 숫자는 제한이 없습니다.
/\bjavascript\b/i; // javascript가 한 단어로 들어가야 하고 대소문자를 구분하지 않습니다.

let text = "testing: 1, 2, 3"; // 샘플 텍스트
let pattern = /\d+/g; // 연속된 숫자 전체에 일치합니다.
pattern.test(text); // => true: 패턴에 맞는 것이 있습니다.
text.search(pattern); // => 9: 첫 번째로 일치하는 부분의 위치
text.match(pattern); // => [“1", "2", "3"]: 일치하는 부분이 모두 포함된 배열
text.replace(pattern, "#"); // => "testing: #, #, #"
text.split(/\D+/); // => ["","1","2",“3"]: 숫자 아닌 것에서 나눕니다.
```

## **3.4** 불 값

true(참)와 false(거짓)

일반적으로 비교 결과를 나타낸다

```jsx
a === 4;
```

제어문에서 자주 사용된다

```jsx
if (a === 4) {
  b = b + 1;
} else {
  a = a + 1;
}
```

다음은 모두 false로 변환되며, false처럼 동작한다

```jsx
undefined;
null;
0 - 0;
NaN;
(""); //빈문자열
```

객체와 배열을 포함해 다른 값은 모두 true로 변환되며 true처럼 동작한다

false, 그리고 false로 변환되는 여섯 가지 값을 묶어서 false 같은(falsy)값, 나머지 값을 true 같은(truthy) 값

```jsx
if (o !== null) ...
or
if (o) ...
```

첫 번째 예제는 o가 null이 아닐 때만 if의 바디가 실행된다

두 번째 예제는 o가 false, 또는 false 같은 값이 아니면 if의 바디가 실행된다

null과 0과 ""를 구분해야 한다면 첫 번째 예제처 럼 명시적으로 비교해야한다

불 값에는 “true”나 “false” 문자열로 변환할 수 있는 toString() 메소드가 있다

&& 연산자 : 두 피연산자가 모두 true 같은 값일 때만 true로 평가되며, 그 외의 경우는 모두 false로 평가

|| 연산자 : 두 피연산자 중 하나 또는 모두가 true 같은 값이면 true로 평가 되고, 두 피연산자가 모두 false 같은 값이면 false로 평가

! 연산자 : 피연산자가 false 같은 값 이면 true로, 피연산자가 true 같은 값이면 false로 평가

```jsx
if ((x === 0 && y === 0) || !(z === 0)) {
  //x와y가모두0이거나, z가0이아닐때
}
```

## **3.5 null과 undefined**

null은 값이 없음을 나타낸다

null에 typeof 연산자를 사용하면 문자열 “object”를 반환

null은 ‘객체가 없다’는 것을 의미

undefined도 값이 없음을 나타낸다

초기화되지 않은 변수의 값 이며 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환되는 값

값을 명시적으로 반환하지 않는 함수의 반환 값이며, 전달되지 않은 인자의 값

undefined는 미리 정의된 전역 상수이며 그 값은 undefined로 초기화된다

undefined에 typeof 연산자를 적용하면 문자열 “undefined”를 반환

null과 undefined 공통점과 차이점

동등 연산자 ==는 두 값이 동등하다고 간주

일치 연산자 ===는 두 값을 구분

둘 다 false 같은 값이므로 불 값을 써야 하는 곳에서는 false로 동작

null과 undefined는 모두 프로퍼티나 메서드가 없다

undefined를 시스템 레벨이고 예측되지 않았거나 에러 비슷한 상황 에서 값이 없는 것

null은 프로그램 레벨이고 정상적이거나 예측된 상황에서 값이 없는 것

이들 중 하나를 변수나 프로퍼티에 할당하거나 함수와 주고받아야 한다면 보통 null을 사용

## **3.6** 심벌

'심볼(symbol)'은 유일한 식별자(unique identifier)를 만들고 싶을 때 사용

(참고 : [https://ko.javascript.info/symbol](https://ko.javascript.info/symbol) )

심벌(Symbol)은 문자열이 아닌 프로퍼티 이름으로 ES6에서 추가됐다

자바스크립트의 객체 타입이 프로퍼티의 순서 없는 집합이며 각 프로퍼티에 이름과 값이 있다는 것

프로퍼티 이름은 일반적 으로 문자열이지만(ES6 전에는 오로지 문자열이었습니다) ES6 이후에는 심벌 역시 문자열과 같은 목적으로 사용할 수 있다.

```jsx
let strname = “string name"; // 프로퍼티 이름에 문자열을 썼습니다.
let symname = SymbolCpropname"); // 프로퍼티 이름에 심벌을 썼습니다.
typeof strname // => "string": strname은 문자열입니다.
typeof symname // => "symbol": symname은 심벌입니다.
let o = {}; // 새 객체를 생성합니다.
o[strname] = 1; // 문자열 이름으로 프로퍼티를 정의합니다.
o[symname] = 2; // 심벌 이름으로 프로퍼티를 정의합니다.
o[strname] // => 1: 이름이 문자열인 프로퍼티에 접근합니다.
o[symname] // => 2: 이름이 심벌인 프로퍼티에 접근합니다.
```

심벌 타입에는 리터럴 문법이 없고, 심벌 값을 가져올 때는 Symbol() 함수를 호출한다

이 함수는 절대 같은 값을 반환하지 않고, 같은 인자로 호출하더라도 다른 값을 반환한다

Symbol()을 호출해 심벌 값을 얻었다면 객체의 기존 프로퍼티를 같은 이름으로 덮어 쓸 염려 없이 그 값을 프로퍼티 이름으로 추가할 수 있다는 뜻. 마찬가지로 심벌인 프로퍼티 이름을 사용하고 그 심벌을 공유하지 않는다면 프로그램의 다른 모듈에서 실수로 여러분의 프로퍼티를 덮어 쓸 일이 없다는 뜻.

Symbol() 함수는 선택 사항인 인자로 문자열을 받고 고유한 심벌 값을 반환한다

문자열 인자를 전달하면 그 문자열은 심벌의 toStringO()메서드 결과에 포함된다
하지만 같은 문자열을 전달해 Symbol()을 다시 호출하더라도 그 결과는 완전히 다른 값

```jsx
let s = Symbol("sym_x");
s.toString(); // => "Symbol(sym_x)"
```

Symbol을 다른 코드에서도 쓸 수 있도록 심벌을 정의하고 공유할 수 있도록 전역 심벌 레지스트리를 정의했다

Symbol.for() 함수는 문자열 인자를 받고 그 문자열과 연관된 심벌 값을 반환

그 문자열과 연관된 심벌이 존재하지 않으면 새 심벌을 생성해 반환하고, 존재하면 기존 심벌을 반환

Symbol()은 절대 같은 값을 반환하지 않지만, Symbol.for()는 같은 문자열로 호출했을 때 항상 같은 값을 반환

Symbol.for()에 전달된 문자열은 반환된 심벌의 toString() 결과에 나타난다

반환된 심벌에 Symbol.keyFor()를 호출해도 해당 문자열을 얻을 수 있다

```jsx
let s = Symbol.forC'shared");
let t = Symbol.forC'shared");
s === t // => true
s.toStringO // => "Symbol(shared)"
Symbol.keyFor(t) // => "shared"
```

## **3.7** 전역 객체

전역 객체의 프로퍼티는 전역으로 정의된 식별자이며 모든 자바스크립트 프로그램에서 사용 가능

자바스크립트 인터프리터를 시작 할 때마다(또는 웹 브라우저가 새 페이지를 로드할 때마다) 다음과 같은 프로퍼티 를 가진 새 전역 객체를 생성한다

```jsx
• undefined. Infinity, NaN 같은 전역 상수
• isNaN(), parselnt()(3.9.2절), eval()(4.12절) 같은 전역 함수
• Date(), RegExp(), String(), Object(), Array()(3.9.2절) 같은 생성자 함수
• Math와 JS0N(6.8절) 같은 전역 객체
```

전역 객체의 초기 프로퍼티는 예약어가 아니지만 예약어로 간주해야한다

웹 브라우저에서는 Window 객체가 모든 자바스크립트 코드의 전역 객체다

이 전역 Window 객체에는 자신을 참조하는 window 프로퍼티가 있으므로 이 프로퍼티를 통해 전역 객체를 참조할 수 있다

## **3.8** 불변인 기본 값과 가변인 객체 참조

기본 값은 불변이며, 기본값을 변경하는 방법은 없다

```jsx
let s = "hello"; // 소문자 텍스트로 시작합니다.
s.toUpperCase(); // HELLO를 반환하지만 s는 그대로입니다.
s; // => "hello": 원래 문자열은 변하지 않았습니다.
```

기본 값은 값으로 비교한다

객체 값은 가변이며, 값을 바꿀 수 있다

객체는 값으로 비교하지 않는다

객체를 기본 타입과 구별하기 위해 참조 타입이라 부른다

객체 값은 참조이며, 객체는 참조로 비교한다는 뜻

두 객체 값이 같다는 말 은 오직 두 값이 같은 객체를 참조할 때에만 성립한다

```jsx
leta = []; // 변수a는빈배열을가리킵니다.
let b = a; // 이제 변수 b도 같은 배열을 가리킵니다.
b[0] = 1; // b가 참조하는 배열을 변경합니다.
a[0]; // => 1: 바뀐 부분은 변수 a를 통해서도 보입니다.
a === b; // => true: a와 b는 같은 객체를 참조하므로 같은값입니다
```

객체나 배열을 변수에 할당하는 것은 참조를 할당하는 것이다

객체나 배열을 변수에 할당한다고 해서 객체의 사본이 새로 생기는 것은 아니다

객체나 배열의 사본을 만들기 위해서는 반드시 객체 프로퍼티나 배열 요소 를 직접 복사해야 한다

```jsx
let a = ["a", "b", "c"]; // 복사할 배열
let b = []; //복사해넣을대상
for (let i = 0; i < a.length; i++) {
  // a의각 인덱스에 대해
  b[i] = a[i]; // a의 요소를 b에 복사합니다.
}
let c = Array.from(b); // ES6에서는 Array.from()으로 배열을 복사할 수 있 습니다.
```

별개의 객체나 배열을 비교할 때는 양쪽의 프로퍼티나 요소를 비교해야 한다

```jsx
function equalArrays(a, b) {
  if (a === b) return true; // 같은 배열을 참조한다면 일치합니다.
  if (a.length !== b.length) return false; // 크기가 다르다면 일치하지 않습니다.
  for (let i = 0; i < a.length; i++) {
    // 요소를 순회합니다.
    if (a[i] !== b[i]) return false; // 어느 하나라도 다르다면 일치하지 않습니다.
  }
  return true; // 모두 같다면 일치합니다.
}
```

## **3.9** 타입 변환

자바스크립트는 필요에 맞게 값을 변환한다

```jsx
10 + " objects"; // => "10 objects": 숫자 10이 문자열로 변환됩니다.
"7" * "4"; // => 28: 두 문자열을 모두 숫자로 변환
let n = 1 - "x"; // n == NaN; 문자열 x는 숫자로 변환할 수 없습니다.
n + " objects"; // => "NaN objects": NaN은 문자열 "NaN"으로 변환됩니다.
```

자바스크립트의 타입 변환 표 (빈 셀은 변환되지 않는다는 뜻)

| 값                         | 문자열로             | 숫자로       | 불 값으로 |
| -------------------------- | -------------------- | ------------ | --------- | ---- |
| undefined                  | "undefined"          | NaN          | false     |
| null                       | "null"               | 0            | false     |
| true                       | "true"               | 1            |           |
| false                      | "false"              | 0            |           |
| “” (빈 문자열)             |                      | 0            | false     |
| "1.2" (숫자)               |                      | 1.2          | true      |
| "one" (문자열)             |                      | NaN          | true      |
| 0                          | "0"                  |              | false     |
| -0                         | "0"                  |              | false     |
| 1(00                       | 아닌유한한숫자)      | “1”          |           | true |
| Infinity                   | "Infinity"           |              | true      |
| -Infinity                  | "-Infinity"          |              | true      |
| NaN                        | “NaN”                |              | false     |
| {} (객체)                  | 3.9.3절 참고         | 3.9.3절 참고 | true      |
| [] (빈 배열)               | “”                   | 0            | true      |
| [9] (숫자 요소 하나)       | “9”                  | 9            | true      |
| [‘a'] (임의의 배열)        | join() 메서드를 사용 | NaN          | true      |
| function(){} (임의의 함수) | 3.9.3절 참고         | NaN          | true      |

### **3.9.1** 변환과일치

일치 연산 자 `===`는 두 피연산자가 **다른 타입이면 같지 않다**고 판단하며, 동등 연산자 `==`를 선택하는 것보다 거의 항상 더 좋다

자바스크립트는 타입 변환이 엄격 하지 않으므로 좀 더 관대한 기준을 가진 동등 연산자도 정의했다

```jsx
null == undefined; // => true: 두 값을 같은 것으로 취급합니다.
"0" == 0; // => true: 비교하기 전에 문자열을 숫자로 변환합니다.
0 == false; // => true: 비교하기 전에 불 값을 숫자로 변환합니다.
"0" == false; // => true: 비교하기 전에 두 피연산자를 모두 0으로 변환합니다.
```

하지만 값을 다른 타입으로 변환할 수 있다 해도 두 값이 무조건 동등하다는 것은 아님

### **3.9.2** 명시적 변환

자바스크립트 자동으로 타입을 변환하기는 하지만 때때로 직접 변환해야 할 때도 있다

명시적 변환하는 방법은 Boolean(), Number(), String() 함수 사용

```jsx
Number("3"); // => 3
String(false); // => "false": false.toString()도 같습니다.
Boolean([]); // => true
```

묵시적인 타입 변환을 수행하는 자바스크립트 연산자를 타입 변환을 목적으로 쓸 때도 있다

- - 연산자의 피연산자 중 하나가 문자열이면 다른 피연산자도 문자열로 변환
- 단항 + 연산자는 피연산자를 숫자로 변환
- 단항 ! 연산자는 피연산자를 불로 변환한 후 다시 부정

```jsx
x +
  "" + // => String(x)
  x; // => Number(x)
x - 0; // => Number(x)
!!x; // => Boolean(x): !가 두 개입니다.
```

Number 클래스의 toString() 메서드는 선택적으로 기수를 인자로 받는다

인자를 생략하면 10진수로 변환

2 이상 36 이하의 기수를 넘겨서 그에 맞게 변환

```jsx
let n = 17;
let binary = "0b" + n.toString(2); // binary == "0bl0001"
let octal = "0o" + n.toString(8); // octal == "0o21"
let hex = "0x" + n.toString(16); // hex == "0x11"
```

숫자를 문자열로 변환하는 세 가지 메서드

- `toFixed()` 숫자를 문자열로 변환할 때 소수점 아래 몇 자리를 표시할지 지정
- `toExponential()` 지수 표기법을 사용해서 숫자를 문자열로 변환
  소수점 앞에는 숫자 하나가 오며, 소수점 아래에는 지정된 자릿수만큼 숫자가 표시된다(즉, 유효 숫자는 인자보다 한 자리가 더 크다).
- `toPrecision()` 지정하는 유효 숫자에 따라 숫자를 문자열로 변환

이 세 가지 메서드는 반올림을 하거나 0을 덧붙인다

```jsx
let n = 123456.789;
n.toFixed(0); // => "123457"
n.toFixed(2); // => "123456.79"
n.toFixed(5); // => "123456.78900"
n.toExponential(1); // => "1.2e+5"
n.toExponential(3); // => ”1.235e+5"
n.toPrecision(4); // => "1.235e+5"
n.toPrecision(7); // => N123456.8"
n.toPrecision(10); // => "123456.7890"
```

`parselnt()`는 오직 정수 부분만 유지하지만

`parseFloat()`는 정수와 부동 소수점 숫자를 모두 유지

문자열이 0x나 0X로 시작할 경우 parselnt()는 이 문자열을 16진수로 해석

시작 부분의 공백은 무시하고 숫자를 최대한 해석한 뒤 숫자가 아닌 문자가 등장하면 그 뒤는 모두 무시, NaN을 반환

```jsx
parselnt("3 blind mice"); // => 3
parseFloat(" 3.14 meters"); // => 3.14
parselnt("-12.34"); // => -12
parseInt("0xFF"); // => 255
parselnt("0xff"); // => 255
parseInt("-0XFF"); // => -255
parseFloat(".1"); // => 0.1
parseInt("0.1"); // => 0
parseInt(".1"); // => NaN: 정수는 .로 시작할 수 없습니다.
parseFloat("$72.47"); // => NaN: 숫자는 $로 시작할 수 없습니다.
```

`parselnt()`는 선택 사항인 두 번째 인자로 기수를 받는다. 기수는 2 이상 36 이하 범위

```jsx
parseInt("11", 2); // => 3: (1*2 + 1)
parseInt("ff", 16); // => 255: (15*16 + 15)
parseInt("zz", 36); // => 1295: (35*36 + 35)
parseInt("077", 8); // => 63: (7*8 + 7)
parseInt("077", 10); // => 77: (7*10 + 7)
```

### **3.9.3** 객체를 기본 값으로 변환

자바스크립트 명세에는 객체를 기본 값으로 변환하는 세 가지 기본적인 알고리즘이 정의되어 있다

**문자열 선호 :** 기본 값을 반환할 때 문자열로 변환할 수 있다면 문자열 값을 우선함

**숫자 선호 :** 기본 값을 반환할 때 숫자로 변환할 수 있다면 숫자 값을 우선함

**선호 없음 :** 어떤 기본 타입을 선호하는지 정해 놓지 않았으며 클래스에서 변환 방법을 정의할 수 있음. (Date를 제외한 모든 타입이 이 알고리즘에 숫자 선호를 적용, Date 클래스는 이 알고리즘에 문자열 선호를 적용)

**객체를 불로 변환**
객체는 모두 true로 변환됨

**객체를 문자열로 변환**

문자열 선호 알고리즘

**객체를 숫자로 변환**

숫자 선호 알고리즘

**특별한 케이스인 연산자 변환**

예외

- 연산자

==, ≠ 연산자

**toString()과 valueOf() 메서드**
toString()은 객체의 문자열 표현을 반환

```jsx
({x: 1, y: 2}).toString() // => "[object Object]"
[1,2,3].toString() //=> "1,2,3"
(function(x) { f(x); }).toString() // => "function(x) { f(x); }"
/\d+/g.toString() // => "/\\d+/g"
let d = new Date(2020,0,1);
d.toString() // => "Wed Jan 01 2020 00:00:00 GMT+0900 (GMT+09:0이,1
```

valueOf()는 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 변환

```jsx
let d = new Date(2010, 0, 1); // 2010년 1월 1일
d.valueOf(); // => 1262271600000
```

**객체에서 기본 값으로 변환하는 알고리즘**

- 문자열 선호 알고리즘은 먼저 toString() 메서드를 시도, valueOf() 시도, TypeError
- 숫자 선호 알고리즘은 valueOf()를 먼저 시도하고 toString()을 두 번째로 시도
- 선호 없음 알고리즘은 객체가 Date 객체일 경우 문자열 선호 알고리즘을 사용. 그 외의 객체에서는 숫자 선호 알고리즘을 사용

숫자 선호 알고리즘이 빈 배열을 숫자 0으로 변환하고 요소가 단 하나 있는 배열도 숫자로 변환

```jsx
Number([]); // => [] => "" => 0
Number([99]); // => "99" => 99
```

## **3.10** 변수 선언과 할당

이름 또는 식별자를 사용해 값을 표현

값에 이름을 부여하면 프로그램에서 그 값을 참조하고 사용할 수 있다

이런 과정을 일반적으로 변수에 값을 할당한다고 한다

변수라는 용어는 새로운 값을 할당할 수 있음을 암시한다

프로그램이 실행됨에 따라 변수에 연결된 값이 바뀔 수 있다

변수나 상수를 쓰기 전에 let과 const 키워드를 사용해 반드시 선언을 먼저 해야한다

### **3.10.1 let**과 **const**를 사용한 선언

선언

```jsx
let i;
let sum;
let i, sum;
```

선언할 때 초깃값을 할당하는 것이 좋음

```jsx
let message = "hello";
let i = 0,
  j = 0,
  k = 0;
let x = 2,
  y = x * x; // 직전에 선언한 변수를 이용해 초기화할 수도 있습니다.
```

let 문에서 변수에 초깃값을 할당하지 않으면 값을 할당할 때까지 undefined로 남아있다

`const`는 선언 할 때 반드시 값을 할당해 초기화해야 한다

상수의 값은 바꿀 수 없으며, 바꾸려 하면 TypeError가 난다

보통 대문자

```jsx
const H0 = 74; // 허블 상수 (km/s/Mpc)
const C = 299792.458; // 진공에서의 광속 (km/s)
const AU = 1.496e8; // 태양까지의 거리를 나타내는 천문학 단위 (km)
```

for, for/in, for/of 루프 문법에서는 `let`을 사용

```jsx
for (let i = 0, len = data.length; i < len; i++) console.log(data[i]);
for (let datum of data) console.log(datum);
for (let property in object) console.log(property);

// const 도 루프의 변수를 선언할 때 가능
for (const datum of data) console.log(datum);
for (const property in object) console.log(property);
```

**변수와 상수 스코프**

`변수의 스코프(scope)` : 프로그램 소스 코드에서 해당 변수가 정의된 영역

let과 const로 선언한 변수와 상수는 **블록 스코프**를 가진다

let이 나 const 문이 존재하는 블록 안에서만 해당 변수와 상수가 유효하다는 뜻

중괄호 안에서 변수나 상수를 선언하면 그 중괄호가 변수와 상수가 정의된 영역

`전역 스코프` : 선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨에 있을 경우

전통적인 클라이언트 사이드 자바스크립트에서 전역 변수의 스코프는 그 변수가 정의된 HTML 문서다

`<script>`에서 전역 변수나 상수를 선언하면 그 변수나 상수는 해당 문서의 `<script>` 요소 전체에 존재

**반복 선언**

중첩된 스코프에서 같은 이름의 변수 를 선언하는 것은 가능

```jsx
const x = 1; // x를 전역 상수로 선언합니다. 
if (x === 1) {
	let x = 2; // 블록 안에서 다시 선언할 수 있습니다.
	console.log(x); // 2 
}
console.log(x); // 1: 지금은 전역 스코프에 있습니다.
let x = 3; // 에러. x를 다시 선언하려 하는 것은 문법 에러입니다.
```

**선언과 타입**

정적 타입 언어는 변수 선언의 주된 목적이 그 변수에 할당할 수 있는 값의 타입을 정하는 것

자바스크립트의 변수 선언에서 타입을 지정하지는 않는다

자바스크립트의 변수는 어떤 타입의 값이든 가질 수 있다

### **3.10.2 var**를 사용한 변수 선언

- var로 선언한 변수는 블록스코프를 갖지않고 함수 바디를 스코프로 가진다
- 함수 바디 바깥에서 var를 사용하면 전역 변수로 선언된다
- 같은 변수를 몇 번이고 선언할 수 있다
- 호이스팅(끌어올림)
    - var로 변수를 선언하면 이 선언문은 함수의 맨 위로 끌어올려진다
    - 어디든지 에러 없이 사용 가능
    - ES6 이후에 let으로 수정한 중요한 결점 중 하나

### **3.10.3** 분해 할당

선언과 할당을 합친 복합 문법.

할당 연산자의 오른쪽 : 배열이나 객체같은, 구조적인 값

왼쪽 : 하나 이상의 변수이름이며, 배열이나 객체 리터럴 문법

분해 할당이 일어나면 오른쪽 값에서 하나 이상의 값을 추출(분해)해서 왼쪽에 있는 변수에 할당한다

```jsx
let [x,y] = [1,2]; // let x=l, y=2와 같습니다.
[x,y]= [x+l,y+l]; //x=x+1,y=y+1과같습니다.
[x,y] = [y,x]; // 두 변수의 값을 바꿉니다.
[x,y] // => [3,2]: 값을 증가시킨 후 서로 바꿨습니다.
```

배열을 반환하는 함수를 쉽게 사용 가능

```jsx
// [x,y] 좌표를 [r,theta] 극좌표로 변환합니다. 
function toPolar(x, y) {
	return [Math.sqrt(x*x+y*y), Math.atan2(y,x)]; 
}

// 극좌표를 카르테시안 좌표로 변환합니다.
function toCartesian(r, theta) {
	return [r*Math.cos(theta), r*Math.sin(theta)];
}

let [r,theta] = toPolar(1.0, 1.0); // r == Math.sqrt(2); theta == Math.PI/4 
let [x,y] = toCartesian(r,theta); // [x, y] == [1.0, 1,0]
```

루프

```jsx
let o = { x: 1, y: 2 }; // 순회할 객체
for(const [name, value] of Object.entries(o)) {
	console.log(name, value); // "x 1", "y 2" 
}
```

왼쪽의 변수가 남으면 undefined가 할당되고, 오른쪽의 값이 남으면 무시된다

왼쪽의 변수 리스트에 콤마를 추가로 넣어서 값 일부를 무시할 수도 있다

```jsx
let [x,y] = [1]; //x == 1; y == undefined
[x,y] = [1,2,3]; //x == 1; y == 2
[,x,,y] = [1,2,3,4]; //x == 2; y == 4
```

마지막 변수 이름 앞에 점 세 개(...)를 써서 배열을 분해하고 남은 값을 변수 하나에 모을 수 있다

```jsx
let [x, ...y] = [1,2,3,4]; // y == [2,3,4]
```

중첩된 배열

```jsx
let [a, [b, c]] = [1, [2,2.5], 3]; // a == 1; b == 2; c == 2.5
let [first, ...rest] = "Hello"; // first == "H"; rest == ["e","l","l","o"]
let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0}; // RGBA 색깔 
let{r,g,b}=transparent; //r==0.0;g==0.0;b==0.0
```

이름이 없는 것은 모두 무시됨, 프로퍼티 이름이 아닌 변수가 더 있었다면 undefined가 할당됨

콜론(:)을 사용해 프로퍼티 이름을 정할 수 있다

```jsx
// const sin=Math.sin, cos=Math.cos, tan=Math.tan과 같습니다. 
const {sin, cos, tan} = Math;

// const cosine = Math.cos, tangent = Math.tan과 같습니다. 
const { cos: cosine, tan: tangent } = Math;
```

중첩된 객체, 객체의 배열, 배열의 객체

```jsx
let points= [{x:1,y:2},{x:3,y:4}]; //좌표 객체가 두 개 있는 배열 
let [{x: xl, y: yl}, {x: x2, y: y2}] = points; // 변수 네 개로 분해했습니다. 
(xl === 1 && yl === 2 && x2 == 3 && y2 === 4) // => true

let points = { pl: [1,2], p2: [3,4] }; // 배열 두 개가 있는 객체 
let { pl: [x1, y1], p2: [x2, y2] } = points; // 변수 네 개로 분해했습니다. 
(x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // => true
```

## **3.11** 요약

- 자바스크립트에서 숫자와 문자열을 만들고 조작하는 법
- 자바스크립트법의 다른 기본 타입인 불, 심벌, null, undefined를 다루는 법
- 불변인 기본 타입 과 가변인 참조 타입의 차이
- 자바스크립트가 묵시적으로 타입을 변환하는 과정, 그리고 프로그램에서 직접 변환하는 법
- 상수와 변수를 선언하고 초기화하는 법(분해 할당 포함), 선언하는 변수와 상수의 어휘적 스코프
