# 8장 함수

## 🍂 8.1 함수 정의

> **`function`**
>
> 함수를 정의하는 가장 단순한 방법이다. 선언으로도, 표현식으로도 사용할 수 있다.

> **화살표 함수**
>
> ES6에서 `function` 키워드 없이 함수를 정의하는 새로운 방법이다.

- 함수를 다른 함수에 인자로 전달할 때 유용하다.

### 8.1.1 함수 선언

함수 선언은 `function` 키워드 뒤에 다음 세 가지 구성 요소를 사용한다.

1. **함수 이름이 될 식별자**

   - 이름은 함수 선언에서 뺼 수 없는 부분이다. 이 이름은 변수 이름으로 쓰이며, 새로 정의된 함수 객체가 이 변수에 할당된다.

2. **괄호로 감싸고 콤마로 구분한 0개 이상의 식별자 리스트**

   - 이 식별자들은 함수 매개변수 이름이며 함수 바디 안에서 로컬 변수로 동작한다.

3. **중괄호로 감싼 0개 이상의 자바스크립트 문**

   - 이 문이 함수 바디이며 함수를 호출할 때마다 실행된다.

함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 정의하기 전에도 호출할 수 있다. 블록 안에서 선언된 함수는 모두 그 블록 전체에 존재하며, 자바스크립트 인터프리터가 해당 블록의 코드를 실행하기 전에 정의된다고 봐도 된다.

**`return`**

`return` 문은 함수 실행을 멈추고 바로 다음에 있는 표현식의 값을 호출자에게 반환한다. 함수에 `return` 문이 없으면 함수는 함수 바디의 문을 끝까지 실행하고 호출자에게 `undefined`를 반환한다.

### 8.1.2 함수 표현식

> **함수 표현식**
>
> 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로서 존재하고 이름을 붙이지 않아도 된다는 점이 다르다.

```js
const square = function (x) {
  return x * x;
};
```

- 이 함수 표현식은 인자의 제곱을 계산하는 함수를 정의한다.
- 함수를 변수에 할당했다.

```js
const f = function fact(x) {
  if (x <= 1) return 1;
  else return x * fact(x - l);
};
```

- 함수 표현식에도 이름을 쓸 수 있으며 재귀 호출에 유용하다.

```js
[3, 2, 1].sort(function (a, b) {
  return a - b;
});
```

- 함수 표현식을 다른 함수의 인자로 사용할 수도 있다.

```js
let tensquared = (function (x) {
  return x * x;
})(10);
```

- 함수 표현식을 정의하는 즉시 호출할 때도 있다.

표현식으로 정의한 함수에 이름을 붙이는 것은 선택 사항이다. 함수 표현식을 쓸 때는 실수로 함수를 덮어 쓰지 않도록 `const` 를 사용하는 것이 좋은 습관이다. 함수는 이름으로 자기 자신을 참조할 수 있다. 함수 표현식에 이름이 있으면, 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다. 즉, 함수 이름은 함수 안에서 로컬 변수가 된다. 표현식으로 정의한 함수는 대부분 이름이 필요 없으므로 정의가 더 간결하다.

| 함수 선언                                                                                                    | 함수 표현식                                                                                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하며 정의하기 전에 호출할 수 있다. | 함수를 정의하는 표현식이 실제로 평가되기 전에는 함수가 존재하지 않는다. 함수를 호출하려면 반드시 함수를 참조할 수 있어야 하는데, 표현식으로 정의된 함수는 변수에 할당되기 전에는 참조할 수 없다. |

### 8.1.3 화살표 함수

화살표 함수는 문이 아니라 표현식이므로 `function` 키워드는 사용하지 않으며 함수 이름도 필요 없다. 화살표 함수의 일반적인 형태는 괄호 안에 콤마로 구분한 매개변수 리스트를 쓰고, 그 뒤에 => 화살표와 중괄호로 감싼 함수 바디를 쓰는 형태이다.

```js
const sum = (x, y) => {
  return x + y;
};
```

화살표 함수를 작성할 때 함수 매개변수와 => 사이에서 줄바꿈을 해선 안 된다. 줄바꿈을 하면 `const polynomial = x`처럼 문법적으로 유효한 할당문이 만들어진다.

**객체 리터럴 반환**

화살표 함수의 바디가 `return` 문 하나라고 해도, 반환할 표현식이 객체 리터럴이라면 객체 리터럴을 명시적으로 괄호 안에 써서 함수 바디의 중괄호와 객체 리터럴의 중괄호를 혼동하지 않게 해야 한다.

```js
const f = x => { return { value: x }; }; // 좋음: f()는 객체를 반환합니다.
const g = x => ({ value: x }); // 좋음: g()는 객체를 반환합니다.
const h = x => { value: x }; // 나쁨: h()는 아무것도 반환하지 않습니다.
const i = x => { v: x, w: x }; // 나쁨: 문법 에러
```

**배열 메서드 사용**

`map()`, `filter()`, 같은 배열 메서드를 사용할 때 화살표 함수 형태를 자주 사용한다.

```js
// null 요소를 제거한 배열 사본을 만듭니다.
let filtered = [1, null, 2, 3].filter(x => x !== null); // filtered == [1, 2, 3]
// 숫자의 제곱을 구합니다.
let squares = [1, 2, 3, 4].map(x => x * x); // squares == [1, 4, 9, 16]
```

## 🍂 8.2 함수 호출

함수는 다섯 가지 방법으로 호출할 수 있다.

1. 함수로 호출

2. 메서드로 호출

3. 생성자로 호출

4. `call()`, `apply()` 메서드를 통해 간접적으로 호출

5. 자바스크립트 언어 기능을 통한 묵시적 호출

### 8.2.1 함수로 호출

함수 표현식이 프로퍼티 접근 표현식이라면, 즉 해당 함수가 객체 프로퍼티거나 배열 요소라면, 표현식은 메서드 호출 표현식이다.

```js
printprops({ x: 1 });
let total = distance(0, 0, 2, 1) + distanced(2, 1, 3, 5);
let probability = factorial(5) / factorial(13);
```

괄호 안에 들어 있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 된다. 함수 바디에서는 각 매개변수가 이에 대응하는 인자로 평가된다.

**`this`**

일반 모드에서 함수의 호출 컨텍스트(this)는 전역 객체이다. 스트릭트 모드의 호출 컨텍스트는 `undefined` 이다. 단, 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 `this` 값을 상속한다. 메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 `this` 키워드를 전혀 사용하지 않는다. 하지만 `this` 키워드를 사용해서 스트릭트 모드에 있는지 확인하는 것은 가능하다.

- 스트릭트 모드에 있는지 판단하는 함수

```js
const strict = (function () {
  return !this;
})();
```

### 8.2.2 메서드로 호출

메서드 호출의 인자와 반환 값은 일반적인 함수 호출과 똑같다. 하지만 메서드 호출과 함수 호출은 호출 컨텍스트가 다르다는 중요한 차이가 있다.

```js
let calculator = { // 객체 리터럴
	operand1: 1,
	operand2: 1,
	add() { // 메서드 단축 문법을 썼습니다.
		// this 키워드는 포함하는 객체를 참조합니다.
		this.result = this.operandl + this.operand2;
	}
}；
calculator.add(); // 메서드 호출을 통해 1 + 1을 계산합니다.
calculator.result // => 2
```

메서드 호출은 대괄호 표현식으로도 메서드를 호출할 수 있다.

```js
o['m'](x, y); // o.m(x, y)와 동등합니다.
a[0](z); // a[0]이 함수라면 역시 메서드 호출입니다.
customer.surname.toUpperCase(); // customer.surname의 메서드를 호출합니다.
f().m(); // f()의 반환 값의 메서드인 m()을 호출합니다.
```

**`this`**

메서드와 `this` 키워드는 객체 지향 프로그래밍 패러다임의 핵심이다. 메서드로 사용되는 함수는 모두 자신을 호출하는 객체를 묵시적인 인자로 받는다. 메서드는 일반적으로 그 객체에서 동작하며, 메서드 호출 문법은 함수가 객체에서 동작한다는 의미를 명쾌하게 전달한다.

```js
rect.setSize(width, height);
setRectSize(rect, width, height);
```

`this` 키워드는 변수의 스코프 규칙을 따르지 않는다. 화살표 함수의 예외를 제외하면 중첩된 함수는 포함하는 함수의 `this` 값을 상속하지 않는다. 중첩된 함수를 메서드로 호출하면 그 `this` 값은 호출한 객체이다. 중첩된 함수를 함수로 호출하면 그 `this` 값은 일반 모드에서는 전역 객체이고, 스트릭트 모드에서는 `undefined` 이다. 메서드 안에 정의된 함수를 함수로 호출하면 this를 통해 메서드의 호출 컨텍스트를 참조할 수 있다고 생각하기도 하는데, 이는 흔히 저지르는 실수이다.

```jsx
let o = {
  // 객체 o
  m: function () {
    // 객체의 메서드 m
    let self = this; // this 값을 변수에 저장합니다.
    this === o; // => true: this는 객체 o입니다.
    f(); // 보조 함수 f()를 호출합니다.

    function f() {
      // 중첩된 함수 f
      this === o; // => false: this는 전역 객체이거나 undefined입니다.
      self === o; // => true: self는 외부 this 값입니다.
    }
  },
};
o.m(); // 객체 o에서 메서드 m을 호출합니다.
```

중첩된 함수 `f()` 에서 `this` 키워드는 객체 `o` 와 같지 않다. 자바스크립트 언어의 결함으로 지적받는 부분이고, 반드시 인지하고 있어야 한다. 위 코드는 널리 쓰이는 우회 방법을 제시한다. 메서드 `m` 안에서 `this` 값을 변수 `self` 에 할당하면, 중첩된 함수 `f` 안에서 포함하는 객체를 `this` 대신 `self` 로 참조할 수 있다.

**`this` 상속**

ES6 이후에는 중첩된 함수 `f` 를 화살표 함수로 변환해 `this` 값을 상속하게 하는 방법도 가능하다.

```jsx
const f = () => {
  this === o; // true: 화살표 함수는 항상 this를 상속합니다.
};
```

표현식으로 정의된 함수는 끌어올려지지 않으므로 이 코드가 동작하기 위해서는 메서드 `m` 안에서 `f`를 정의하는 부분을 호출 이전으로 옮겨야 한다.

### 8.2.3 생성자로 호출

생성자를 호출하면 생성자의 `prototype` 프로퍼티에서 지정된 객체를 상속하는 빈 객체를 새로 생성한다. 생성자 함수는 객체를 초기화할 의도로 만들어졌으며, 이렇게 새로 생성된 객체가 호출 컨텍스트로 사용되므로 생성자 함수는 새 객체를 `this` 키워드로 참조할 수 있다.

**`return`**

생성자 함수는 일반적으로 `return` 키워드를 사용하지 않는다. 생성자 함수는 일반적으로 새 객체를 초기화하여 함수 바디의 끝에 도달하면 종료한다. 이 경우 새 객체가 생성자 호출 표현식의 값이다. 생성자가 명시적으로 `return` 문을 사용해 객체를 반환하면 그 객체가 호출 표현식의 값이 된다. 생성자가 `return` 문을 값 없이 사용하거나 기본 값을 반환한다면 반환 값을 무시하고 새 객체를 호출 표현식의 값으로 사용한다.

### 8.2.4 간접적 호출

`call()`과 `apply()`는 함수를 간접적으로 호출한다. 두 메서드 모두 호출 시점에 `this` 값을 직접 명시할 수 있으므로, 함수를 어떤 객체의 메서드로도 호출할 수 있다.

### 8.2.5 묵시적 함수 호출

묵시적으로 호출한 함수에서 버그, 부작용, 성능 문제가 발생한다면, 단순히 코드를 들여다보는 것으로는 언제 호출되는지 명확히 알기 어려우므로 일반적인 함수에 비해 해결하기가 훨씬 어렵다.

1. 객체에 게터나 세터가 있다면 프로퍼티 값에 접근할 때 이 메서드가 호출될 수 있다.

2. 문자열을 받는 컨텍스트에 객체를 사용하면 `toString()` 메서드가 호출된다. 마찬가지로, 객체를 숫자 컨텍스트에 사용하면 `valueOf()` 메서드가 호출된다.

3. 이터러블 객체의 요소를 순회할 때 여러가지 메서드가 호출될 수 있다.

4. 태그된 템플릿 리터럴도 함수 호출을 일으킬 수 있다.

5. 프록시 객체는 완전히 함수에 의해 제어된다. 이런 객체에는 어떤 동작을 취하든 항상 함수가 호줄된다.

## 🍂 8.3 함수 매개변수

함수는 매개변수로 어떤 타입을 받는지 정의하지 않으며, 함수 호출 시점에서도 전달받은 값의 타입을 체크하지 않는다. 함수를 호출할 때 전달받은 인자의 개수조차 체크하지 않는다.

### 8.3.1

선언된 매개변수보다 적은 인자로 함수를 호출하면, 대응하는 인자가 없는 매개변수는 기본 값으로 정해지며 일반적으로 이 값은 `undefined`이다.

```js
// 객체 o의 열거 가능한 프로퍼티를 배열 a에 추가하고 a를 반환합니다.
// a를 생략하면 새 배열을 생성해 반환합니다.
function getPropertyNames(o, a) {
  if (a === undefined) a = []; // 정의되지 않았으면 새 배열을 사용합니다.
  for (let property in o) a.push(property);
  return a;
}

// getPropertyNames()는 인자 한 개나 두 개로 호출할 수 있습니다.
let o = { x: 1 },
  p = { y: 2, z: 3 }; // 테스트용 객체
let a = getPropertyNames(o); // a == ["x"]; o의 프로퍼티를 새 배열에 담습니다.
getPropertyNames(p, a); // a == ["x","y","z"]; p의 프로퍼티를 추가합니다.
```

선택 사항인 인자를 받는 함수를 만들 때는 선택 사항인 인자를 인자 리스트 마지막에 써서 생략하기 쉽게 만들어야 한다.

첫 번째 인자를 생략하고 두 번째만 전달하려면 첫 번째 인자에 명시적으로 `undefined`를 써야 한다.

**매개변수의 기본 값**

매개변수 이름 뒤에 등호(=)를 쓰고, 그 매개변수가 생략됐을 때 사용할 기본 값을 쓰면 된다.

```js
// 객체 o의 열거 가능한 프로퍼티를 배열 a에 추가하고 a를 반환합니다.
// a를 생략하면 새 배열을 생성해 반환합니다.
function getPropertyNames(o, a = []) {
  for (let property in o) a.push(property);
  return a;
}
```

매개변수 기본 값 표현식은 함수를 정의할 때가 아니라 호출할 때 평가된다. `getPropertyNames()` 함수를 인자 하나로 호출할 때마다 빈 배열로 새로 생성해서 전달한다.

**매개변수가 여러 개인 함수의 기본 값**

매개변수 여러 개를 받는 함수에서 앞의 매개변수의 값을 사용해 그다음 매개변수의 기본 값을 정의할 수 있다.

```js
// 이 함수는 사각형의 크기를 나타내는 객체를 반환합니다.
// 너비가 제공됐을 때만 높이를 너비의 두 배로 정합니다.
const rectangle = (width, height = width * 2) => ({ width, height });
rectangle(1); // => { width: 1, height: 2 }
```

### 8.3.2 나머지 매개변수와 가변 길이 인자 리스트

정의된 매개변수보다 더 많은 인자를 써서 함수를 호출할 수 있다.

```js
function max(first = -Infinity, ...rest) {
  let maxValue = first; // 첫 번째 인자가 가장 크다고 가정합니다.
  // 나머지 인자를 순회하면서 더 큰 값을 찾습니다.
  for (let n of rest) {
    if (n > maxValue) {
      maxValue = n;
    }
  }
  // 가장 큰 값을 반환합니다.
  return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // => 1000
```

함수 바디 안에서 나머지 매개변수의 값은 항상 배열이다. 배열이 비어 있더라도 나머지 매개변수는 절대 `undefined`가 되지 않는다. 따라서 나머지 매개변수에 매개변수 기본 값을 지정할 필요도 없고, 허용되지도 않는다.

**가변 함수**

앞의 예제처럼 인자 개수에 제한이 없는 함수를 가변 함수(variadic function, variable arity function, vararg function)라고 부른다.

### 8.3.3 Argument 객체

나머지 매개변수는 ES6에서 자바스크립트에 도입했다. ES6 전에는 Arguments 객체를 써서 가변 함수를 만들었다. 함수 바디 안에서 식별자 `arguments`는 해당 호출의 Arguments 객체를 참조한다.

```js
function max(x) {
  let maxValue = -Infinity;
  // 인자를 순회하며 가장 큰 값을 찾아 기억합니다.
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > maxValue) maxValue = arguments[i];
  }
  // 가장 큰 값을 반환합니다.
  return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // => 1000
```

Arguments 객체는 자바스크립트 초기 버전부터 있었지만, 좀 이상하게 동작하고 비효율적이며 최적화하기도 어렵다. 여전히 Arguments 객체가 포함된 코드를 볼 수 있겠지만, 새로 작성하는 코드에는 사용하지 말아야 한다. 오래된 코드를 리팩터링할 때 `arguments`를 사용하는 함수를 `...args` 나머지 매개변수로 대체할 수 있을 때가 많다.

스트릭트 모드에서는 `arguments`를 예약어로 취급하므로 이 이름을 써서 함수 매개변수나 로컬 변수를 선언할 수 없다.

### 8.3.4 함수 호출과 분해 연산자

분해 연산자 ... 는 개별 값이 예상되는 컨텍스트에서 배열이나 문자열 같은 이터러블 객체를 분해한다.

```js
let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers); // => -1
```

... 는 평가를 통해 값을 얻을 수 없다는 점에서 진정한 연산자로는 볼 수 없다. ... 는 배열 리터럴과 함수 호출에 사용할 수 있는 특별한 자바스크립트 문법이다.

함수 정의에서 ... 문법은 분해 연산자의 정반대로 동작한다. 함수 정의에서 사용한 ... 는 여러 개의 인자를 배열에 모아서 사용한다.

```js
// 이 함수는 함수를 받아 래퍼 버전을 반환합니다.
function timed(f) {
  return function (...args) {
    // 인자를 나머지 매개변수 배열에 모읍니다.
    console.log(`Entering function ${f.name}`);
    let startTime = Date.now();
    try {
      // 인자를 모두 래퍼 버전에 전달합니다.
      return f(...args); // 인자를 다시 분해합니다.
    } finally {
      // 반환하기 전에 소요된 시간을 출력합니다.
      console.log(`Exiting ${f.name} after ${Date.now() - startTime}ms`);
    }
  };
}

// 1 과 n 사이의 숫자의 합을 계산합니다.
function benchmark(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) sum += i;
  return sum;
}

// 테스트 함수의 래퍼 버전을 호출합니다.
timed(benchmark)(1000000); // => 500000500000; 숫자의 합입니다.
```

### 8.3.5 함수 인자를 매개변수로 분해

함수를 호출할 때 전달한 인자는 함수 정의 시 선언된 매개변수에 할당된다.

함수를 정의할 때 매개변수 이름을 대괄호 안에 쓰면, 대괄호 한 쌍마다 배열 값을 받는다고 정의하게 된다. 호출 과정에서 배열 인자는 개별 매개변수로 분해된다.

```js
function vectorAdd(v1, v2) {
  return [v1[0] + v2[0], vl[l] + v2[l]];
}
vectorAdd([1, 2], [3, 4]); // => [4, 6]

function vectorAdd([x1, y1], [x2, y2]) {
  // 인자 두 개를 매개변수 네 개로 분해합니다.
  return [x1 + x2, y1 + y2];
}
vectorAdd([1, 2], [3, 4]); // => [4, 6]
```

객체 인자를 받는 함수를 정의할 때도 인자로 받은 객체를 매개변수로 분해할 수 있다.

```js
// 스칼라 값을 벡터에 곱합니다.
function vectorMultiply({ x, y }, scalar) {
  return { x: x * scalar, y: y * scalar };
}
vectorMultiply({ x: 1, y: 2 }, 2); // => {x: 2, y: 4}
```

분해된 매개변수 이름이 전달된 객체의 프로퍼티 이름과 일치하므로 훨씬 이해하기 쉽다. 프로퍼티를 다른 이름의 매개변수로 분해해야 한다면 문법이 복잡해진다.

```js
function vectorAdd(
  { x: x1, y: y1 }, // 첫 번째 객체를 x1과 y1 매개변수로 분해합니다.
  { x: x2, y: y2 },
) {
  // 두 번째 객체를 x2와 y2 매개변수로 분해합니다.
  return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({ x: 1, y: 2 }, { x: 3, y: 4 }); // => {x: 4, y: 6}
```

프로퍼티 이름은 항상 콜론 왼쪽에 있고, 매개변수나 변수 이름은 항상 오른쪽에 있다.

매개변수 분해와 매개변수 기본 값을 섞어 쓸 수 있다.

```js
// {x,y} 또는 {x,y,z} 벡터에 스칼라 값을 곱합니다.
function vectorMultiply({ x, y, z = 0 }, scalar) {
  return { x: x * scalar, y: y * scalar, z: z * scalar };
}
vectorMultiply({ x: 1, y: 2 }, 2); // => {x: 2, y: 4, z: 0}
```

### 8.3.6 인자 타입

자바스크립트 메서드는 매개변수 타입을 선언하지 않으며 값을 전달할 때도 타입을 체크하지 않는다. 함수 인자에 뜻이 분명한 이름을 쓰고, 함수에 주석을 달아 두면 코드 자체가 문서가 될 수 있다.

문자열 인자를 받는 함수를 만들고 그 함수를 다른 타입의 값으로 호출한다면, 전달된 값은 함수가 그 값을 문자열로 사용하려고 하는 시점에 문자열로 변환된다.

기본 타입은 모두 문자열로 변환될 수 있으며 객체에는 모두 `toString()` 메서드가 있으므로 이런 경우에는 절대 에러가 일어나지 않는다.

하지만 항상 그런 것은 아니다. 함수가 잘못된 값을 받은 채 실행을 시작하고 명확하지 않은 에러 메시지를 보내며 실패하는 것보다는, 예측 가능한 형태로 즉시 실패하는 편이 더 좋다.

```jsx
// 이터러블 객체 a의 요소 합계를 반환합니다. 요소는 모두 반드시 숫자여야 합니다.
function sum(a) {
  let total = 0;
  for (let element of a) {
    // a 가 이터러블이 아니면 TypeError가 일어납니다.
    if (typeof element !== 'number') {
      throw new TypeError('sum(): elements must be numbers');
    }
    total += element;
  }
  return total;
}
sum([1, 2, 3]); // => 6
sum(1, 2, 3); // TypeError: 1 은 이터러블이 아닙니다.
sum([1, 2, '3']); // TypeError: 인덱스 2는 숫자가 아닙니다.
```

## 🍂 8.4 값인 함수

함수의 가장 중요한 특징은 정의하고 호출할 수 있다는 것이다. 문법 구조일 뿐만 아니라 값으로써 변수에 할당될 수도 있고, 객체 프로퍼티나 배열 요소에 저장될 수도 있으며, 다른 함수에 인자로 전달될 수도 있고, 기타 여러 가지로 기능하다.

```js
function square(x) {
  return x * x;
}
```

함수는 다른 변수에 할당할 수 있고 여전히 똑같이 동작한다.

```js
let s = square; // 이제 s는 square와 같은 함수를 참조합니다.
square(4); // => 16
s(4); // => 16
```

함수를 변수가 아닌 객체 프로퍼티에 할당할 수도 있다. 이런 함수를 메서드라고 부른다.

```js
let o = {
  square: function (x) {
    return x * x;
  },
}; // 객체 리터럴
let y = o.square(16); // y == 256
```

배열 요소에 할당할 때는 이름 자체가 필요하지 않다.

```js
let a = [x => x * x, 20]; // 배열 리터럴
a[0](a[1]); // => 40
```

함수를 값으로 취급할 수 있는 점은 대단히 유용한 특징이다. 함수를 값으로 사용했을 때 어떤 일을 할 수 있는지에 대한 예제이다.

```js
// 단순한 함수를 몇 개 정의합니다.
function add(x, y) {
  return x + y;
}
function subtract(x, y) {
  return x - y;
}
function multiply(x, y) {
  return x * y;
}
function divide(x, y) {
  return x / y;
}

// 앞에서 정의한 함수 중 하나를 인자로 받아, 그 함수에 다른 두 인자를 전달해 호출하는 함수입니다.
function operate(operator, operand1, operand2) {
  return operator(operand1, operand2);
}

// 이 함수를 사용해 (2 + 3) + (4 * 5) 같은 값을 계산할 수 있습니다.
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// 같은 함수를 이번에는 객체 리터럴로 만듭니다.
const operators = {
  add: (x, y) => x + y,
  subtract: (x, y) => x - y,
  multiply: (x, y) => x * y,
  divide: (x, y) => x / y,
  pow: Math.pow, // 미리 정의된 함수도 사용할 수 있습니다.
};

// 이 함수는 연산자 이름을 받고 객체에서 연산자를 찾은 다음, 제공받은 피연산자를 전달해 호출합니다.
// 연산자 함수를 호출할 때 쓴 문법을 눈여겨보십시오.
function operate2(operation, operand1, operand2) {
  if (typeof operators[operation] === 'function') {
    return operators[operation](operand1, operand2);
  } else throw 'unknown operator';
}

operate2('add', 'hello', operate2('add', ' ', 'world')); // => "hello world"
operate2('pow', 10, 2); // => 100
```

### 8.4.1 함수 프로퍼티 직접 정의

함수는 기본 값이 아니라 특별한 객체이므로 함수 역시 프로퍼티를 가질 수 있다. 함수를 언제 호출하든 일정한 '정적' 변수가 필요하다면 그 변수를 함수 자체의 프로퍼티로 정의하는 게 편리하다.

```js
// 함수 객체의 counter 프로퍼티를 초기화합니다.
// 함수 선언은 끌어올려지므로 함수 선언 이전에 할당해도 괜찮습니다.
uniqueInteger.counter = 0;

// 이 함수는 호출할 때마다 다른 정수를 반환합니다.
// 자신의 프로퍼티를 사용해 어떤 값을 반환할지 판단합니다.
function uniqueInteger() {
  return uniqueInteger.counter++; // counter 프로퍼티를 반환하고 증가시킵니다.
}
uniqueInteger(); // => 0
uniqueInteger(); // => 1
```

## 🍂 8.5 네임스페이스인 함수

함수 안에서 선언한 변수는 함수 바깥에서 보이지 않는다. 따라서 전역 네임스페이스를 어지럽히지 않도록, 임시 네임스페이스 기능을 하는 함수를 정의하는 것이 유용할 때도 있다.

코드가 다양한 프로그램에서 사용되기 때문에 코드에서 정의하는 변수가 다른 프로그램의 변수와 충돌할지 확실히 알 수 없다. 그 해결책은 코드를 함수에 넣고 호출하는 것이다. 이렇게 하면 전역에서 사용됐을 변수를 함수의 로컬 변수로 만들 수 있다.

```js
function chunkNamespace() {
  // 코드가 여기 존재합니다. 코드에서 정의한 변수는 모두 함수의 로컬 변수이므로
  // 전역 네임스페이스를 어지럽히는 일은 없습니다.
}
chunkNamespace(); // 단, 이 함수 호출은 잊지 말아야 합니다.
```

프로퍼티 하나라도 전역에 남겨 두고 싶지 않다면 표현식 하나로 익명 함수를 정의하고 즉시 호출할 수 있다.

```js
(function () {
  // chunkNamespace() 함수를 익명의 표현식으로 고쳐 씁니다.
  // 코드가 여기 존재합니다.
})(); // 함수 리터럴을 종료하고 즉시 호출합니다.
```

표현식 하나에서 함수를 정의하고 호출하는 기법은 워낙 널리 사용되므로 '즉시 호출하는 함수 표현식(IIFE)'이라는 이름도 따로 있다.

`function` 앞에 있는 여는 괄호가 없으면 자바스크립트 인터프리터가 `function` 키워드를 함수 선언으로 분석하기 때문에 반드시 필요하다. 괄호가 있으면 인터프리터는 이를 함수 정의 표현식으로 정확히 인식한다. 맨 앞에 괄호가 있으면 사람이 보기에도 지금 정의한 함수를 즉시 호출할 것이라고 이해하기 쉽다.

이렇게 함수를 네임스페이스로 사용하는 방법은 네임스페이스 안에 있는 변수를 사용해 하나 이상의 함수를 정의하고, 정의된 함수를 네임스페이스 함수의 반환 값으로 사용할 때 아주 유용하다. 이런 함수를 클로저라고 부른다.

## 🍂 8.6 클로저

대부분의 최신 프로그래밍 언어와 마찬가지로 자바스크립트 역시 어휘적 스코프(lexical scope)를 사용한다. 어휘적 스코프란 함수가 호출 시점의 스코프가 아니라 자신이 정의된 시점의 변수 스코프를 사용하여 실행된다는 뜻이다. 어휘적 스코프를 구현하기 위해서는 자바스크립트 함수 객체의 내부 상태에 함수의 코드뿐 만 아니라 함수가 정의된 스코프에 대한 참조도 반드시 포함되어 있어야 한다. 이렇게 함수 객체와 스코프를 조합한 것을 클로저라 부른다.

엄밀히 말해 자바스크립트 함수는 모두 클로저이지만, 대부분의 함수가 자신이 정의된 곳과 같은 스코프에서 호출되므로 보통은 클로저인지 아닌지를 따질 필요가 없다. 클로저가 유용할 때는 함수가 정의된 곳과 다른 스코프에서 호출될 때뿐이다.

가장 흔한 경우는 함수가 함수를 정의해 반환하는 경우이다. 여러 강력한 프로그래밍 기법에서 이런 형태의 중첩된 함수 클로저를 사용하며, 자바스크립트 프로그래밍에서 비교적 흔히 사용되는 편이다.

```js
let scope = 'global scope'; // 전역 변수
function checkscope() {
  let scope = 'local scope'; // 로컬 변수
  function f() {
    return scope;
  } // 이 스코프에 있는 값을 반환합니다.
  return f();
}
checkscope(); // => "local scope"
```

`checkscope()`가 `"local scope"`를 반환하는 이유를 명확히 이해하기 위해 괄호 한 쌍을 `checkscope()` 내부에서 외부로 이동했다.

```js
let scope = 'global scope'; // 전역 변수
function checkscope() {
  let scope = 'local scope'; // 로컬 변수
  function f() {
    return scope;
  } // 이 스코프에 있는 값을 반환합니다.
  return f;
}
let s = checkscope()(); // 무엇을 반환할까요?
```

`checkscope()`는 이제 중첩된 함수를 호출하고 그 결과를 반환하는 대신, 중첩된 함수 객체 자체를 반환한다.

자바스크립트 함수는 자신이 정의된 스코프에서 실행된다. 중첩된 함수 `f()`는 변수 `scope`가 `"local scope"`였던 스코프에서 정의됐다. 이 연결은 `f`를 어디에서 실행하든 상관 없이 계속 유지된다. 따라서 위 코드의 마지막 행은 `"global scope"`가 아니라 `"local scope"`를 반환한다.

클로저는 자신을 정의한 외부 함수의 로컬 변수와 매개변수를 그대로 캡처한다.

```js
let uniqueInteger = (function () {
  // 다음 함수의 비공개 상태를 정의하고 호출합니다.
  let counter = 0;
  return function () {
    return counter++;
  };
})();
uniqueInteger(); // => 0
uniqueInteger(); // => 1
```

즉시 호출하는 함수 표현식을 사용했으므로 `uniqueInteger`에 할당되는 것은 내부 함수이다. 중첩된 함수는 자신의 스코프에 있는 변수에 접근할 수 있으며 외부 함수에 정의된 `counter` 변수도 사용할 수 있다.

일단 외부 함수가 종료되면 다른 코드에서는 `counter` 변수를 볼 수 없다. 오직 내부 함수만이 `counter` 변수에 접근할 수 있다.

`counter` 같은 비공개 변수를 클로저 하나에서만 배타적으로 써야 하는 것은 아니다. 두 개 이상의 중첩된 함수가 같은 외부 함수에서 정의되고, 같은 스코프를 공유해도 아무 문제 없다.

```js
function counter() {
  let n = 0;
  return {
    count: function () {
      return n++;
    },
    reset: function () {
      n = 0;
    },
  };
}

let c = counter(),
  d = counter(); // 카운터 두 개를 생성합니다.
c.count(); // => 0
d.count(); // => 0: 이들은 별도로 계산됩니다.
c.reset(); // reset()과 count() 메서드는 상태를 공유합니다.
c.count(); // => 0: c는 리셋했습니다.
d.count(); // => 1: d는 리셋하지 않았습니다.
```

`counter()` 함수는 '카운터' 객체를 반환한다. 이 객체에는 다음 정수를 반환하는 `count()`, 내부 상태를 리셋하는 `reset()` 두 가지 메서드가 있다.

첫 번째로 이해해야 할 것은 두 메서드가 같은 비공개 변수 `n`에 접근한다는 것이다.

두 번째로 이해해야 할 것은 `counter()`를 호출할 때마다 이전 호출과 독립된 새 스코프가 생성되며, 그 스코프 안에서 비공개 변수 역시 새로 생성된다는 것이다.

`counter()`를 두 번 호출하면 카운터 객체가 두 개 생기며 이들의 비공개 변수는 각각 다르다.

클로저 기법과 프로퍼티 게터와 세터를 조합할 수 있다는 점도 알아 두면 좋다.

```js
function counter(n) {
  // 함수 인자 n은 비공개 변수입니다.
  return {
    // 프로퍼티 게터 메서드는 비공개 카운터 변수를 반환하고 증가시킵니다.
    get count() {
      return n++;
    },
    // 프로퍼티 세터는 n 값의 감소를 허용하지 않습니다.
    set count(m) {
      if (m > n) n = m;
      else throw Error('카운트는 더 큰 값으로만 바꿀 수 있습니다.');
    },
  };
}

let c = counter(1000);
c.count; // => 1000
c.count; // => 1001
c.count = 2000;
c.count; // => 2000
c.count = 2000; // Error: 카운트는 더 큰 값으로만 바꿀 수 있습니다.
```

`counter()` 함수는 로컬 변수를 선언하지 않고 매개변수 `n`에 프로퍼티 접근자 메서드에서 공유한 비공개 상태를 담았다. 이렇게 하면 `counter()`의 호출자에서 비공개 변수의 초깃값을 정할 수 있다.

```js
// 이 함수는 지정된 이름의 프로퍼티에 대한 프로퍼티 접근자 메서드를 객체 o에 추가합니다.
// 메서드 이름은 get<name>과 set<name>으로 지정됩니다. 판별 함수가 제공됐다면
// 세터 메서드는 인자를 저장하기 전에 판별 함수를 사용해 유효성을 테스트합니다.
// 판별 함수가 false를 반환한다면 세터 메서드는 예외를 일으킵니다.

// 이 함수의 독특한 점은 게터와 세터 메서드가 조작하는 프로퍼티 값이
// 객체 o에 저장되지 않는다는 점입니다. 값은 이 함수의 로컬 변수에만 저장됩니다.
// 게터와 세터 메서드는 함수에 로컬로 정의됐으므로 로컬 변수에 접근할 수 있습니다.

// 따라서 값은 두 접근자 메서드에서만 사용할 수 있으며, 세터 메서드를 통하지 않고서는
// 값을 수정하거나 저장할 수 없습니다.

function addPrivateProperty(o, name, predicate) {
  let value; // 프로퍼티 값입니다.

  // 게터 메서드는 단순히 그 값을 반환합니다.
  o[`get${name}`] = function () {
    return value;
  };

  // 세터 메서드는 판별 함수의 판단에 따라 값을 저장하거나 예외를 일으킵니다.
  o[`set${name}`] = function (v) {
    if (predicate && !predicate(v)) {
      throw new TypeError(`set${name}: invalid value ${v}`);
    } else {
      value = v;
    }
  };
}

// 다음 코드는 addPrivateProperty() 메서드의 사용 방법 예시입니다.
let o = {}; // 빈 객체입니다.

// 프로퍼티 접근자 메서드 getName()과 setName()을 추가합니다. 오직 문자열 값만 허용합니다.
addPrivateProperty(o, 'Name', x => typeof x === 'string');

o.setName('Frank'); // 프로퍼티 값을 저장합니다.
o.getName(); // => "Frank"
o.setName(0); // TypeError: 올바르지 않은 타입을 사용했습니다.
```

클로저가 접근을 공유하면 안 되는 변수에 대한 접근까지 부주의하게 공유할 수도 있다는 점 역시 반드시 기억해야 한다.

```js
// 이 함수는 항상 v를 반환하는 함수를 반환합니다.
function constfunc(v) {
  return () => v;
}

// 정적 함수 배열을 생성합니다.
let funcs = [];
for (var i = 0; i < 10; i++) f니ncs[i] = constfunc(i);

// 인덱스 5의 함수는 5를 반환합니다.
funcs[5](); // => 5
```

루프에서 클로저를 여러 개 생성하는 코드를 사용할 때, 흔히 루프를 클로저를 정의하는 함수 안으로 옮기려 하는 실수를 하곤 한다.

```js
// 0부터 9까지의 값을 반환하는 함수 배열을 반환합니다.
function constfuncs() {
  let funcs = [];
  for (var i = 0; i < 10; i++) {
    funcs[i] = () => i;
  }
  return funcs;
}

let funcs = constfuncs();
funcs[5](); // => 10;
```

이 클로저들은 모두 같은 함수 호출에서 정의되므로 모두 변수 `i`에 대한 접근을 공유한다. `constfuncs()`가 종료되면 변수 `i`의 값은 10이며, 클로저 10개는 모두 이 값을 공유한다.

클로저와 연관된 스코프는 '살아 있다'는 점을 기억하는 것이 중요하다. 중첩된 함수는 스코프의 비공개 사본을 만들거나 변수의 스냅샷을 만들지 않는다.

여기서 문제는 변수를 `var`로 선언했다는 것이다. `for` 루프에서 루프 변수를 `var i`로 선언했으므로 변수 `i`는 루프 바디 안에만 존재하는 것이 아니라 함수 전체에 존재한다.

ES6에서 블록 스코프를 도입하면서 문제가 해결됐다. `var`를 `let`이나 `const`로 바꾸기만 하면 문제는 사라진다. `let`과 `const`는 블록 스코프를 사용하므로 매 반복마다 독립적인 스코프가 생성 되므로 각 스코프는 각자의 `i`를 참조한다.

클로저를 만들 때는 `this`가 변수가 아니라 자바스크립트 키워드라는 점도 기억해야 한다. 앞에서 설명했듯 화살표 함수는 자신을 포함한 함수의 `this` 값을 상속하지만, `function` 키워드로 정의한 함수는 그렇지 않다. 따라서 외부 함수의 `this` 값을 사용하는 클로저를 만들 때는 화살표 함수를 사용하거나, 클로저를 반환하기 전에 `bind()`를 호출하거나, 외부의 `this`값을 클로저가 상속할 변수에 할당해야 한다.

```js
const self = this; // this 값을 중첩된 함수에서 사용할 수 있게 합니다.
```

## 🍂 8.7 함수 프로퍼티, 메서드, 생성자

자바스크립트의 함수는 값이다. 함수에 `typeof` 연산자를 적용하면 문자열 `"function"`을 반환하지만, 사실 함수는 특별한 종류의 자바스크립트 객체이다.

함수는 객체이므로 다른 객체와 마찬가지로 프로퍼티와 메서드를 가질 수 있다. 심지어 새 함수 객체를 생성하는 `Function()` 생성자까지 있다.

### 8.7.1 length 프로퍼티

읽기 전용인 `length` 프로퍼티는 함수의 '항', 즉 정의된 매개변수 개수이며 보통 함수가 예상하는 인자 개수이기도 하다. 함수에 나머지 매개변수가 있다면 그 매개변수는 이 `length` 프로퍼티에 포함되지 않는다.

### 8.7.2 name 프로퍼티

읽기 전용인 `name` 프로퍼티는 함수가 정의될 때 이름이 있었다면 그 이름, 또는 익명의 함수 표현식이라면 처음 생성됐을 때 할당된 변수나 프로퍼티 이름이다. 이 프로퍼티는 디버깅이나 에러 메시지에 유용하게 사용된다.

### 8.7.3 prototype 프로퍼티

화살표 함수를 제외하면 모든 함수에는 프로토타입 객체를 참조하는 `prototype` 프로퍼티가 있다. 함수의 프로토타입 객체는 모두 다르다. 함수를 생성자로 사용하면 새로 생성된 객체는 프로토타입 객체에서 프로퍼티를 상속한다.

### 8.7.4 call()과 apply() 메서드

`call()`과 `apply()`는 함수를 마치 다른 객체의 메서드인 것처럼 간접적으로 호출한다. `call()`과 `apply()`의 첫 번째 인자는 함수를 호출할 객체이다. 이 인자가 호출 컨텍스트이며 함수 바디 안에서 `this` 키워드의 값이다. 함수 `f()`를 인자 없이 객체 `o`의 메서드로 호출할 때는 `call()`과 `apply()` 중 아무거나 써도 된다.

```js
f.call(o);
f.apply(o);
```

`o`에 `m`이라는 프로퍼티가 없다면 위 두 행은 모두 다음 코드와 비슷합니다.

```js
o.m = f; // f를 임시로 o의 메서드로 만듭니다.
o.m(); // 인자 없이 m을 호출합니다.
delete o.m; // 임시 메서드를 제거합니다.
```

화살표 함수는 자신이 정의된 컨텍스트의 `this` 값을 상속한다. 이 값은 `call()`과 `apply()` 메서드로 덮어 쓸 수 없다. 화살표 함수에서 이들 메서드를 호출하면 첫 번째 인자는 무시되는 것이나 마찬가지이다.

`call()`을 사용할 때 첫 번째 인자인 호출 컨텍스트 다음에 오는 인자는 호출될 함수에 전달된다. 이 인자는 화살표 함수에서도 무시되지 않는다. 예를 들어 함수 `f()`에 숫자 두 개를 전달하면서 `f()`가 객체 `o`의 메서드인 것처럼 호출하려면 다음과 같은 코드를 사용한다.

```js
f.call(o, 1, 2);
```

`apply()` 메서드도 `call()` 메서드와 비슷하지만, 함수에 전달할 인자가 배열로 제공된다는 점이 다르다.

```js
f.apply(o, [1, 2]);
```

함수가 받는 인자 개수에 제한이 없다면 `apply()` 메서드를 써서 임의의 길이를 가진 배열을 전달해 함수를 호출할 수 있다.

ES6 이후라면 그냥 분해 연산자를 써도 되지만, ES5 코드에서는 `apply()`를 사용한 경우도 있을 것이다.

### 8.7.5 bind() 메서드

`bind()`의 주요 목적은 함수를 객체에 결합(bind)하는 것이다. 함수 `f`에서 `bind()` 메서드를 호출하면서 객체 `o`를 전달하면 새 함수를 반환한다. 새 함수를 함수로 호출하면 원래 함수 `f`가 `o`의 메서드로 호출된다. 새 함수에 전달한 인자는 모두 원래 함수에 전달된다.

```js
function f(y) {
  return this.x + y;
} // 결합할 함수입니다.
let o = { x: 1 }; // 결합될 객체입니다.
let g = f.bind(o); // g(x)를 호출하면 o에서 f()를 호출합니다.
g(2); // => 3
let p = { x: 10, g }; // g()를 이 객체의 메서드로 호출합니다.
p.g(2); // => 3: g는 여전히 o에 결합되어 있습니다.
```

화살표 함수는 자신이 정의된 환경의 `this` 값을 상속하며 이 값은 `bind()`에서 덮어 쓸 수 없으므로, 위 코드의 함수 `f()`를 화살표 함수로 정의했다면 결합은 제대로 이루어지지 않았을 것이다.

`bind()`를 호출하는 목적은 대개 화살표 함수가 아닌 함수를 화살표 함수처럼 사용하는 것이므로 화살표 함수에서 결합이 이루어지지 않는다는 것은 사실 문제가 되지 않는다.

`bind()`에 전달하는 인자 중 첫 번째를 제외한 나머지는 `this` 값과 함께 결합된다. 이러한 부분 적용(partial application)은 화살표 함수에도 동작한다. 부분 적용은 함수형 프로그래밍에서 널리 쓰이는 기법이며 커링(currying)이라고 부르기도 한다. 다음은 `bind()` 메서드의 부분 적용 예제이다.

```js
let sum = (x, y) => x + y; // 인자의 합을 반환합니다.
let succ = sum.bind(null, 1); // 첫 번째 인자와 1을 결합합니다.
succ(2); // => 3: x는 1이고 y 인자로 2를 전달했습니다.

function f(y, z) {
  return this.x + y + z;
}
let g = f.bind({ x: 1 }, 2); // this와 y를 결합합니다.
g(3); // => 6: this.x는 1, y는 2에 결합됐으며 z는 3입니다.
```

`bind()`가 반환하는 함수의 `name` 프로퍼티는 `bind()`를 호출한 함수의 `name` 앞에 `"bound"`를 붙인 값이다.

### 8.7.6 toString() 메서드

ECMAScript 명세는 이 메서드가 함수 선언문의 문법을 지키는 문자열을 반환해야 한다고 규정한다. 하지만 현실에서는 대부분의 환경에서 함수의 `toString()` 메서드가 소스 코드 전체를 반환한다. 내장 함수는 일반적으로 `"[native code]"` 같은 문자열을 함수 바디로 반환한다.

### 8.7.7 Function() 생성자

함수는 객체이므로 `Function()` 생성자를 사용해 새 함수를 생성할 수 있다.

```js
const f = new Function('x', 'y', 'return x * y;');
```

```js
const f = function (x, y) {
  return x * y;
};
```

`Function()` 생성자는 문자열 인자를 개수 제한 없이 받는다. 마지막 인자는 함수 바디인 텍스트이다. 이 텍스트에는 자바스크립트 문을 제한 없이 넣을 수 있으며 각 문은 세미콜론으로 구분한다. 다른 인자는 모두 함수가 받을 매개변수 이름이다. 인자를 받지 않는 함수를 정의할 때는 생성자에 함수 바디 문자열만 전달하면 된다.

`Function()` 생성자에 전달하는 인자 중 함수 이름에 해당하는 것은 없다. 함수 리터럴과 마찬가지로 `Function()` 생성자 역시 익명 함수를 생성한다.

`Function()` 생성자에 대해 이해해야 할 중요한 포인트가 몇 가지 있다.

- `Function()` 생성자는 런타임에 자바스크립트 함수를 동적으로 생성하고 컴파일 할 수 있다.

- `Function()` 생성자는 호줄될 때마다 함수 바디를 분석하고 새 함수 객체를 생성한다. 루프나 자주 호출되는 함수 안에서 생성자를 호출하는 것은 효율적이지 않다. 중첩된 함수와 함수 표현식은 루프 안에 있더라도 매번 재컴파일되지 않는다.

- 마지막으로, `Function()` 생성자에서 아주 중요한 포인트는 생성자가 만드는 함수는 어휘적 스코프를 사용하지 않는다는 점이다. 생성자가 만드는 함수는 항상 최상위 함수로 컴파일된다.

```js
let scope = 'global';
function constructFunction() {
  let scope = 'local';
  return new Function('return scope'); // 로컬 스코프를 캡처하지 않습니다.
}
// 이 행이 global을 반환하는 이유는 Function() 생성자가 반환하는 함수는 로컬 스코프를
// 사용하지 않기 때문입니다.
constructFunction()(); // => "global"
```

`Function()` 생성자는 전역 스코프를 사용하는 `eval()`이고 자신만의 비공개 스코프에 새 변수와 함수를 정의한다고 생각하면 된다. 이 생성자를 사용할 일은 아마 없을 것이다.

## 🍂 8.8 함수형 프로그래밍

자바스크립트는 함수를 객체처럼 조작할 수 있으므로 함수형 프로그래밍 기법을 사용할 수 있다. `map()`과 `reduce()` 같은 배열 메서드는 특히 함수형 프로그래밍 스타일에 알맞는다.

### 8.8.1 함수로 배열 처리

숫자로 이루어진 배열이 있고 이 값들의 평균과 표준 편차를 구하려 한다.

```js
let data = [1, 1, 3, 5, 5]; // 테스트에 사용할 배열입니다.

// 평균은 요소의 합을 요소 개수로 나눈 값입니다.
let total = 0;
for (let i = 0; i < data.length; i++) total += data[i];
let mean = total / data.length; // mean == 3; 숫자의 평균은 3입니다.

// 표준 편차를 계산하려면 먼저 각 요소와 평균 간 편차의 제곱을 모두 합합니다.
total = 0;
for (let i = 0; i < data.length; i++) {
  let deviation = data[i] - mean;
  total += deviation * deviation;
}
let stddev = Math.sqrt(total / (data.length - 1)); // stddev == 2
```

같은 계산을 배열 메서드 `map()`과 `reduce()`를 사용해 간결한 함수형 스타일로 바꿀 수 있다.

```js
// 먼저 단순한 함수 두 개를 정의합니다.
const sum = (x, y) => x + y;
const square = x => x * x;

// 두 함수와 배열 메서드를 사용해 평균과 표준 편차를 계산합니다.
let data = [1, 1, 3, 5, 5];
let mean = data.reduce(sum) / data.length; // mean == 3
let deviations = data.map(x => x - mean);
let stddev = Math.sqrt(deviations.map(square).reduce(sum) / (data.length - 1));
stddev; // => 2
```

`map`과 `reduce()`메서드의 함수형 버전을 만들어 보자.

```js
const map = function (a, ...args) {
  return a.map(...args);
};
const reduce = function (a, ...args) {
  return a.reduce(...args);
};
```

### 8.8.2 고계 함수

고계 함수(higher-order function)는 하나 이상의 함수를 인자로 받아 새 함수를 반환하는 함수이다.

```js
// 이 고계 함수는 인자를 f에 전달하고 f의 반환 값의 논리 부정을 반환하는 새 함수를 반환합니다.
function not(f) {
  return function (...args) {
    // 새 함수를 반환합니다.
    let result = f.apply(this, args); // 이 함수는 f를 호출하고
    return !result; // 그 결과를 부정합니다.
  };
}

const even = x => x % 2 === 0; // 숫자가 짝수인지 판단하는 함수
const odd = not(even); // 그 반대를 행하는 새 함수
[1, 1, 3, 5, 5].every(odd); // => true: 배열 요소는 전부 홀수입니다.
```

함수 인자를 받고 그 함수를 사용해 배열을 다른 배열로 변환하는 새 함수를 반환한다.

```js
// 배열 인자를 받아 각 요소에 f를 호출하고, 반환 값으로 이루어진 배열을 반환하는 함수를 반환합니다.
// 이전에 정의한 map() 함수와 비교해 보십시오.
const map = function (a, ...args) {
  return a.map(...args);
};

function mapper(f) {
  return a => map(a, f);
}

const increment = x => x + 1;
const incrementAll = mapper(increment);
incrementAll([1, 2, 3]); // => [2,3,4]
```

`f`와 `g` 두 함수를 받고 `f(g())`를 계산하는 새 함수를 반환한다.

```js
// f(g(...))를 계산하는 새 함수를 반환합니다. 반환되는 함수 h는 인자 전체를
// g에 전달하고, g의 반환 값을 f에 전달한 다음 f의 반환 값을 반환합니다.
// f와 g는 모두 h가 호출된 this 값을 공유합니다.
function compose(f, g) {
  return function (...args) {
    // f에는 값 하나만 전달하므로 call()을 썼고 g에는 값 배열을 전달하므로
    // apply()를 썼습니다.
    console.log(args);
    return f.call(this, g.apply(this, args));
  };
}

const sum = (x, y) => x + y;
const square = x => x * x;
compose(square, sum)(2, 3); // => 25; 합의 제곱
```

### 8.8.3 함수의 부분 적용

`bind()` 메서드는 왼쪽에 있는 인자를 부분적으로 적용한다. 즉, `bind()`에 전달하는 인자는 원래 함수에 전달되는 인자 리스트의 시작 부분에 위치한다는 뜻이다.

```js
// 이 함수의 인자는 왼쪽에 전달됩니다.
function partialLeft(f, ...outerArgs) {
  return function (...innerArgs) {
    // 함수를 반환합니다.
    let args = [...outerArgs, ...innerArgs]; // 인자 리스트를 만들고
    return f.apply(this, args); // 전달해서 f를 호출합니다.
  };
}

// 이 함수의 인자는 오른쪽에 전달됩니다.
function partialRight(f, ...outerArgs) {
  return function (...innerArgs) {
    // 함수를 반환합니다.
    let args = [...innerArgs, ...outerArgs]; // 인자 리스트를 만들고
    return f.apply(this, args); // 전달해서 f를 호출합니다.
  };
}

// 이 함수의 인자는 템플릿 구실을 합니다. 인자 리스트에서 정의되지 않은 값은 내부
// 세트의 값으로 채워집니다
function partial(f, ...outerArgs) {
  return function (...innerArgs) {
    let args = [...outerArgs]; // 외부 인자 템플릿의 로컬 사본
    let innerIndex = 0; // 그다음에 내부 인자가 위치합니다.
    // 인자를 순회하며 정의되지 않은 값을 내부 인자로 채웁니다.
    for (let i = 0; i < args.length; i++) {
      if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
    }
    // 남은 내부 인자를 이어 붙입니다.
    args.push(...innerArgs.slice(innerIndex));
    return f.apply(this, args);
  };
}

// 인자 세 개를 받는 함수입니다.
const f = function (x, y, z) {
  return x * (y - z);
};
// 세 가지 부분 적용이 어떻게 다르게 동작하는지 보십시오.
partialLeft(f, 2)(3, 4); // => -2: 첫 번째 인자에 결합합니다. 2 * (3 - 4)
partialRight(f, 2)(3, 4); // =>  6: 마지막 인자에 결합합니다. 3 * (4 - 2)
partial(f, undefined, 2)(3, 4); // => -6: 중간 인자에 결합합니다. 3 * (2 - 4)
```

부분 적용 함수를 사용하면 이미 정의한 함수를 활용해서 더 흥미로운 함수를 쉽게 정의할 수 있다.

```js
const sum = (x, y) => x + y;
const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1 / 3);
cuberoot(increment(26)); // => 3
```

부분 적용과 고계 함수를 조합할 수 있다.

```js
function compose(f, g) {
  return function (...args) {
    return f.call(this, g.apply(this, args));
  };
}

const not = partialLeft(compose, x => !x);
const even = x => x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) && isNumber(2); // => true
```

### 8.8.4 메모이제이션

이전에 계산한 결과를 캐시하는 팩토리얼 함수를 만들었다. 함수형 프로그래밍에서는 이런 캐싱을 메모이제이션(memoization)이라고 부른다.

```js
// f를 캐시를 활용하도록 수정해 반환합니다.
// f의 인자가 모두 고유한 문자열 표현일 때만 동작합니다.
function memoize(f) {
  const cache = new Map(); // 값 캐시는 클로저에 저장됩니다.

  return function (...args) {
    // 인자를 캐시 키로 사용할 문자열로 바꿉니다
    let key = args.length + args.join('+');
    if (cache.has(key)) {
      return cache.get(key);
    } else {
      let result = f.apply(this, args);
      cache.set(key, result);
      return result;
    }
  };
}
```

`memoize()` 함수는 캐시로 사용할 새 객체를 생성하고 이 객체를 로컬 변수에 할당한다. 반환된 함수 외에는 이 객체를 볼 수 없다.

## 🍂 8.9 요약

- `function` 키워드나 ES6의 화살표 문법으로 함수를 정의할 수 있습니다.

- 함수는 메서드나 생성자로도 사용할 수 있습니다.

- ES6 기능 중에는 선택 사항인 함수 매개변수에 기본 값을 할당하는 기능, 나머지 매개변수를 사용해 인자 여럿을 배열에 모으는 기능, 객체와 배열을 분해해 함수 매개변수로 사용하는 기능 등이 있습니다.

- 분해 연산자 `...` 를 사용해 배열이나 이터러블 객체의 요소를 함수 인자로 전달해 호출할 수 있습니다.

- 외부 함수 안에서 정의되고 반환된 함수는 외부 함수의 어휘적 스코프에 대한 접근을 유지하고 있으므로, 외부 함수에서 정의한 변수에 접근할 수 있습니다. 이런 함수를 클로저라 부르며, 클로저는 충분히 알아 둘 만한 기법입니다.

- 함수는 자바스크립트에서 조작할 수 있는 객체이며, 이를 통해 함수형 프로그래밍 스타일을 사용할 수 있습니다.
