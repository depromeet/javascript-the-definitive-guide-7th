# 8장 함수

- JS 함수는 매개 변수화 된다
- 매개 변서라고 불리는 식별자 리스트가 있고, 함수 바디에서 로컬 변수처럼 동작
- 각 호출에는 호출 컨텍스트가 존재하고, 이것이 this 키워드의 값
- 객체를 새로 만들 목적으로 설계한 함수를 생성자 함수

- 함수 선언은 함수의 이름이 변수이고, 그 값은 함수 자체
- 블록 맨 위로 끌어올려져 → 함수 정의 전에도 호출 가능
- 블록 안에서 선언된 함수는 모두 그 블록 전체에 존재하고,
JS 인터프리터가 해당 블록의 코드를 실행하기 전에 정의

- ES6 스트릭트모드에서는 블록 안에서 함수 선언 가능
- 이전에는 JS파일이나 다른 함수의 최상위 레벨에서만 함수를 선언 할 수 있었음

[함수 표현식]

- 함수 선언과 비슷하지만 이름을 붙이지 않아도 된다는 점
- 함수 선언은 실제로 변수를 선언하고, 변수에 할당하지만
→ 함수 표현식은 변수를 선언하지 않음
- 함수 표현식은 함수를 정의하는 표현식이 실제로 평가되기 전에는 함수가 존재하지 않음 → 이전에 호출 할 수 없음

### 화살표 함수

- 화살표 함수는 자신이 정의된 환경의 this 키워드 값을 상속한다.
- prototype 프로퍼티가 없어 → 새로운 클래스의 생성자로 사용 할 수 없다.(9.2절)

- 화살표 함수의 예외를 제외하면 중첩된 함수는 포함하는 함수의 this의 값을 상속하지 않음
- 중첩된 함수를 메서드로 호출하면 그 this 값은 호출한 객체
- 중첩된 함수를 함수로 호출하면 this는 일반 모드에서 전역이고, 
스트릭트 모드에서는 undefined
- 메서드 안에 정의된 함수를 함수로 호출하면 this를 통해 메서드의 호출 컨텍스트 참조 할 수 있다고 생각하는 것은 → 실수!!!!
- this대신 self로 참조하는 방법을 사용했지만 최근에는 화살표 함수를 이용하는 것도 좋음

### 화살표 함수의 잘못된 사용

```jsx
const h = x => { value: x }; // undefined
const i = x => { v:x, w: x }; // 문법에러 
```

### 함수 호출 방법

- 함수로 호출
- 메서드로 호출
- 생성자로 호출
- call(), apply() 메서드를 통해 간접 호출
- JS 언어 기능을 통한 묵시적 호출

[함수로 호출]

- 일반 모드에서는 함수의 호출 컨텍스트는 전역 객체, 
스트릭트 모드의 호출 컨텍스트는 undefined
- 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 this 값 상속

### 생성자로 호출

- 함수나 메서드를 호출할 때 앞에 키워드를 붙이면 생성자로 호출
- 생성자로 호출하면 생성자의 prototype 프로퍼티에서 지정된 객체를 상속하는 빈객체를 새로 생성
- 생성자 함수는 객체를 초기화 하는 의도로 만들어졌고, 새로 생성된 객체가 호출 컨텍스트로 사용되므로 생성자 함수는 새 객체를 this키워드로 참조 가능

### Argument 객체

- ES6 전에는 Arguments 객체를 써서 가변 함수를 만들었음
- 함수 바디 안에서 식별자 arguments는 해당 호출의 arguments 객체 참조
- 함수에 전달된 인자 값을 이름이 아닌 숫자로 참조
- 최근에는 `…args` 나머지 매개 변수로 대체 할 수 있음

### 인자 타입

- 문자열 인자를 받는 함수를 만들고, 그 함수를 다른 타입의 값으로 호출하면 → 전달된 값은 함수가 그 값을 문자열로 사용하려고 하는 시점에 문자열로 변환 sadsad
- 기본 타입은 모두 문자열로 변환될 수 있으며 객체에는 모두 toString 메서드가 있어, 절대 에러가 나지 않음
- 그러나 배열 인자를 한 개 또는 두 개 받는데 이들 중 잘못된 타입이 있으면 제대로 동작하지 않음

### 값인 함수

- 함수의 가장 중요한 특징은 정의하고 호출할 수 있음
- JS 함수는 문법 구조일 뿐만 아니라 값으로써 변수에 할당도 가능

### 함수 프로퍼티 직접 정의

- JS 함수는 기본 값이 아니라 특별한 객체이므로 프로퍼티를 가질 수 있음
- 함수를 언제 호출하든 일정한 정적 변수가 필요하다면 그 변수를 함수 자체의 프로퍼티로 정의하는게 편리
- ex) 호출할 때 마다 서로 다른 고유한 정수를 반환하는 함수 등
- → 반환한 값을 추적할 방법이 필요

```jsx
uniqueInt.counter = 0;

function uniqueInt() {
	return uniqueInt.counter++;
}

uniqueInt() // 0
uniqueInt() // 1
```

### 임시 네임스페이스인 함수

- 임시 네임스페이스 기능을 하는 함수를 정의 가능
- 코드를 함수에 넣고 호출
- 전역에서 사용됐을 변수를 함수의 로컬 변수로 만들 수 있음
- IIFE 사용 가능

### 클로저

- 엄밀히 말해 JS 함수는 모두 클로저
- 그러나 함수가 자신이 정의된 곳과 같은 스코프에서 호출되므로 보통은 클로저인지 따질 필요가 없음
- 유용할 때는 함수가 정의된 곳과 다른 스코프에서 호출될때 뿐
- 가장 흔한 경우는 함수가 함수를 정의해 반환하는 경우
- 사라지지 않는 지역 변수를 만들 수 있고, private 필드와 같은 속성을 누릴 수 있음
- 클로저는 함수 호출 시점의 로컬 변수를 캡쳐해 
→ 이 변수를 비공개 상태로 사용

- 클로저 기법과 게터 세터를 조합도 가능

```jsx
function counter(n){
  return {
    get count(){return n++;}
    set count(m){
      if(m > n ) n = m;
			else throw Error('~~')
}
```

### 왜 이럴까?

![Screen Shot 2022-06-08 at 10.53.59 PM.png](8%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%2029f34f76f3954080af5da2ced9030752/Screen_Shot_2022-06-08_at_10.53.59_PM.png)

- 클로저를 10개 생성하고 배열에 저장
- 이 클로저들은 모두 같은 함수 호출에서 정의되므로 모두 변수 i에 대한 접근 공유
- tmp 함수가 종료되면 변수 i의 값은 10이고, 클로저는 모두 이 값을 공유
- 따라서 반환된 배열에 포함된 함수는 모두 같은 값을 반환
- 중요한 문제는 변수를 var로 선언했다는 것
- for 루프에서 루프 변수를 var로 선언해 변수 i는 루프 바디 안에만 존재하지 않고, 함수 전체에 존재
- let으로 변경하면 문제 사라짐

### this는 변수가 아니라 키워드

- 클로저를 만들 때 this가 변수가 아니라 JS 키워드
- 그래서 외부 함수의 this 값을 사용하는 클로저를 만들 때는 화살표 함수를 사용하나 클로저를 반환하기 전에 bind 호출하거나 외부의 this 값을 클로저가 상속할 변수에 할당해야 한다
